{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///bundle.js","webpack:///webpack/bootstrap 76c7519a5fa8b0cdb02b","webpack:///../node_modules/style-loader/lib/addStyles.js","webpack:///../node_modules/promise-polyfill/promise.js","webpack:///../node_modules/style-loader/lib/urls.js","webpack:///../node_modules/preact-habitat/dist/preact-habitat.es.js","webpack:///./components/chatbox/model.js","webpack:///./components/chatbox/index.js","webpack:///./index.js","webpack:///../node_modules/preact/dist/preact.min.js","webpack:///./components/chatbox/style.scss","webpack:///../node_modules/unfetch/dist/unfetch.es.js","webpack:///../node_modules/isomorphic-unfetch/browser.js","webpack:///../node_modules/falcor/dist/falcor.browser.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./components/chatbox/style.scss?84c6","webpack:///../node_modules/css-loader/lib/css-base.js","webpack:///../node_modules/preact-cli/lib/lib/webpack/polyfills.js","webpack:///../node_modules/preact-cli/lib/lib/entry.js"],"names":["root","factory","exports","module","define","amd","a","i","self","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","BMrJ","addStylesToDom","styles","options","length","item","domStyle","stylesInDom","id","refs","j","parts","push","addStyle","listToStyles","list","newStyles","base","css","media","sourceMap","part","insertStyleElement","style","target","getElement","insertInto","Error","lastStyleElementInsertedAtTop","stylesInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","removeStyleElement","parentNode","removeChild","idx","indexOf","splice","createStyleElement","document","createElement","attrs","type","addAttrs","createLinkElement","link","rel","el","keys","forEach","key","setAttribute","obj","update","remove","result","transform","singleton","styleIndex","singletonCounter","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","autoFixUrls","undefined","convertToAbsoluteUrls","fixUrls","unescape","encodeURIComponent","JSON","stringify","blob","oldSrc","isOldIE","fn","memo","apply","arguments","window","all","atob","selector","querySelector","DEBUG","newList","mayRemove","textStore","replacement","filter","Boolean","join","BtxX","noop","thisArg","Promise","TypeError","_state","_handled","_value","_deferreds","doResolve","handle","deferred","_immediateFn","cb","onFulfilled","onRejected","resolve","reject","promise","ret","e","newValue","then","finale","_unhandledRejectionFn","len","Handler","done","value","reason","ex","setTimeoutFunc","setTimeout","prom","constructor","arr","res","val","args","remaining","Array","slice","race","values","setImmediate","err","console","warn","_setImmediateFn","_setUnhandledRejectionFn","DRTY","location","baseUrl","protocol","host","currentDir","pathname","replace","fullMatch","origUrl","unquotedOrigUrl","trim","$1","test","newUrl","JkW7","__webpack_exports__","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","writable","setPrototypeOf","__proto__","preact_min","preact_min_default","_extends","assign","source","camelcasize","str","letter","toUpperCase","getExecutedScript","currentScript","scripts","getElementsByTagName","collectPropsFromElement","element","defaultProps","attributes","props","dataAttrName","propName","split","pop","nodeValue","scrp","propsObj","hasAttribute","getAttribute","parse","innerHTML","getHabitatSelectorFromClient","scriptTagAttrs","widgetDOMHostElements","ref","inline","clientSpecified","hostNodes","querySelectorAll","queriedTag","preact_habitat_es_preactRender","widget","hostElements","cleanRoot","elm","hostNode","_habitat","render","h","habitat","Widget","clean","elements","loaded","elements$1","addEventListener","preact_habitat_es","style_default","falcor_browser","falcor_browser_default","pathValue","model","Model","HttpDataSource","api_url","crossDomain","headers","Content-Type","ApiModel","getAllAgents","account_id","addResponse","intent","intent_id","agent_id","intent_action","addAgent","agent_name","flg_active","trainModel","generateIntents","dsl","resetSession","addConnection","from","to","log","delInteraction","setResponse","response_id","data","paths","message","set","setAgent","doChat","getAllResponses","getAllIntents","chatbox_model","ENTER_KEY","chatbox_UserMessage","_Component","UserMessage","_ref","chat","isbot","class","new","avatar","src","message_personal","chatbox_App","_Component2","App","_temp","_this2","_ret","_len","_key","concat","state","account","showChatBox","session","started","messages","onEnter","which","alert","setState","sendChat","image","renderChat","that","apiDoChat","responses","map","r","json","response","text","getElementById","focus","handleChange","bodychat","scrollTop","scrollHeight","chat_title","title","messages_content","message_box","onKeyUp","message_input","placeholder","message_submit","KM04","t","M","T","children","S","nodeName","L","vnode","__d","D","debounceRendering","P","C","splitText","_componentConstructor","__n","toLowerCase","createElementNS","u","W","__html","substring","removeEventListener","__l","removeAttribute","removeAttributeNS","setAttributeNS","className","event","_","E","afterMount","componentDidMount","V","A","ownerSVGElement","H","f","_component","replaceChild","__preactattr_","x","dangerouslySetInnerHTML","b","v","y","g","w","N","k","__k","lastChild","previousSibling","B","__b","__x","__r","getDerivedStateFromProps","componentWillMount","componentWillReceiveProps","context","__c","__p","syncComponentUpdates","__s","U","shouldComponentUpdate","componentWillUpdate","getChildContext","getSnapshotBeforeUpdate","__u","unshift","componentDidUpdate","afterUpdate","__h","beforeUnmount","componentWillUnmount","forceUpdate","F","cloneElement","Component","rerender","LFiD","version","sources","names","mappings","file","sourcesContent","sourceRoot","locals","bg","timestamp","bounce","loading","ball","mCSB_scrollTools","mCSB_inside","mCSB_container","mCSB_dragger","mCSB_dragger_bar","QAmr","fetch","url","header","request","getAllResponseHeaders","ok","status","statusText","responseURL","clone","responseText","entries","has","XMLHttpRequest","open","method","setRequestHeader","withCredentials","credentials","onload","onerror","send","body","VS7n","default","XLyV","global","require","code","1","falcor","jsong","atom","error","125","130","34","2","_root","ModelRoot","_path","path","_scheduler","scheduler","ImmediateScheduler","_source","_request","RequestQueue","_ID","ID","_maxSize","maxSize","_maxRetries","maxRetries","_collectRatio","collectRatio","boxed","_boxed","materialized","_materialized","treatErrorsAsValues","_treatErrorsAsValues","_useServerPaths","_allowFromWhenceYouCame","allowFromWhenceYouCame","_treatDataSourceErrorsAsJSONGraphErrors","cache","setCache","ModelDataSourceAdapter","ModelResponse","CallResponse","InvalidateResponse","ASAPScheduler","TimeoutScheduler","arrayClone","arraySlice","collectLru","pathSyntax","getSize","isObject","isPrimitive","isJSONEnvelope","isJSONGraphEnvelope","setJSONGraphs","validateInput","noOp","getCache","GET_VALID_INPUT","_progressive","Math","pow","_getOptimizedBoundPath","_getWithPaths","observe","preload","out","onError","obs","subscribe","onCompleted","argsIdx","argsLen","arg","argType","isArray","invalidate","fromPath","deref","_hasValidParentReference","getValue","setValue","_getValueSync","_setValueSync","_derefSync","cacheOrJSONGraphEnvelope","modelRoot","boundPath","expired","getWithPathsAsPathMap","getWithPathsAsJSONGraph","jsonGraph","_setMaxSize","oldMaxSize","modelCache","currentVersion","$_version","getVersion","pathArg","_getVersion","_syncCheck","syncRefCount","unsafeMode","_clone","opts","batch","schedulerOrDelayArg","schedulerOrDelay","round","abs","schedule","unbatch","asDataSource","_materialize","_dematerialize","boxValues","unboxValues","withoutDataSource","toJSON","$type","getPath","_fromWhenceYouCame","allow","_getBoundValue","_getPathValuesAsPathMap","_getPathValuesAsJSONG","_setPathValues","_setPathMaps","_setJSONGs","_setCache","_invalidatePathValues","_invalidatePathMaps","113","134","17","18","20","22","23","28","3","38","39","4","40","44","5","50","51","52","57","58","59","6","61","63","67","68","69","7","70","71","72","73","74","75","79","85","95","96","97","99","_model","pathSets","_toJSONG","jsongResponse","suffixes","collectionScheduler","_pathObservers","isFunction","comparator","errorSelector","onChange","pathMapsIntersect","left","right","leftKeys","hasOwn","cacheNode","messageNode","$expires","onObserve","affectedPaths","affectedPathMap","pathObserver","pathMap","observer","onNext","hasObservers","88","93","reference","_referenceContainer","$_parent","$_invalidated","InvalidDerefInputError","getCachePosition","$ref","boundJSONArg","referenceContainer","absolutePath","$__path","refPath","$__refPath","toReference","$__toReference","validContainer","containerPath","118","19","9","getBoundValue","InvalidModelError","boundPathArg","boundValue","node","found","10","8","BoundJSONGraphModelError","instance","getPrototypeOf","captureStackTrace","14","shortedPath","11","InvalidSourceError","innerError","12","MaxRetryExceededError","missingOptimizedPaths","is","13","NullInPathError","applyErrorPrototype","errorType","15","followReference","nodeArg","referenceContainerArg","referenceArg","seed","isJSONG","next","depth","$_context","isExpired","createHardlink","onValue","promote","26","30","41","81","16","mergeInto","targetValue","defaultEnvelope","walk","optimizedPath","optimizedLength","nextSeed","valueNode","results","optimizedPaths","currentCachePosition","requestedPath","derefInfo","criticalError","getValueSync","shorted","21","cloneBoxedValue","boxedValue","clonedValue","isInternalKey","_copyCache","cacheNext","outNext","isUserCreatedcacheNext","$_modelCreated","94","maxDepth","parsedPath","pathIdx","pathLen","curr","$atom","$error","simplePath","noClone","refNode","shouldShort","116","117","29","gen","walkPath","33","24","outerResults","errors","25","concatAndInsertMissing","remainingPath","requestedMissingPaths","fastCat","optimizedMissingPaths","depthDifferences","isEmptyAtom","support","fastCopy","pathSlice","32","branchInfo","prevK","prev","nodeType","isUserCreatedNode","hasValues","27","onMissing","isMaterialized","expireNode","currentCacheVersion","fromReference","currType","31","82","83","privatePrefix","outValue","substr","35","92","iArg","arr1","arr2","onValueType","iterateKeySet","optimizedPathArg","fromReferenceArg","keySet","isKeySet","nextDepth","iteratorNote","optimizedLengthPlus1","nextOptimizedPath","nextOptimizedLength","nType","$_absolutePath","145","37","36","invalidatePathMap","parent","lru","__prefix","child","branch","invalidateNode","nextNode","nextParent","removeNodeAndDescendants","updateNodeAncestors","invalidateReference","container","count","$_key","pathUtils","toTree","toPaths","incrementVersion","pathMapEnvelopes","_comparator","_errorSelector","bound","initialVersion","pathMapIndex","pathMapCount","reduce","allPaths","envelope","newVersion","rootChangeHandler","106","112","89","invalidatePathSet","note","backRefs","$_refsLength","__ref","$_refIndex","pathIndex","pathCount","removeNode","totalArg","max","ratioArg","total","ratio","size","shouldUpdate","targetSize","$size","$_tail","$_prev","$_head","$_next","105","EXPIRES_NEVER","head","119","42","43","createDisposable","disposed","_disposed","_callbacks","_optimizedPaths","_requestedPaths","_count","disposable","_disposable","unsubscribe","dispose","requestQueue","removeRequest","flattenRequestedPaths","requested","outLen","innerLen","complement","flushGetRequest","REQUEST_ID","GetRequestType","GetRequest","setPathValues","emptyArray","GetRequestV2","sent","scheduled","_pathMap","_collapsed","requestedPaths","callback","oPaths","rPaths","callbacks","flushedDisposable","scheduleDisposable","getCurrentVersion","setVersion","mergeContext","hasInvalidatedResult","pathsErr","_merge","add","optimized","optimizedComplement","requestedComplement","complementTuple","inserted","nextPaths","pathValues","45","46","47","RequestQueueV2","requests","_requests","RequestTypes","sendSetRequest","falcorPathUtils","setScheduler","collapse","refCountCallback","disposables","oRemainingPaths","rRemainingPaths","48","findPartialIntersections","currentTree","rCurrentPath","oCurrentPath","depthDiff","intersections","rComplementPaths","oComplementPaths","keyType","innerKey","nextTree","arrayConcat","intersectionData","jLen","kLen","hasIntersection","tree","requestedIntersection","intersectionLength","complementLength","oPath","rPath","subTree","76","listOfPaths","listKeys","listIdx","listLen","pathSet","pathSetsByLength","pathMapKeys","pathMapIdx","pathMapLen","pathMapKey","jsonGraphData","getRequest","collapsedPaths","_collasped","arrayMap","emptyDisposable","originalJsonGraph","resultingJsonGraphEnvelope","setObservable","jsonGraphEnvelope","dataSourceError","78","49","AssignableDisposable","disosableCallback","currentDisposable","callPath","suffix","_subscribe","callArgs","extraPaths","rootModel","boundCallPath","invalidations","invalidated","group","groupType","groups","argIndex","argCount","isPathValue","inputType","_groups","empty","progressively","operationFunc","98","ModelResponseObserver","$$observable","toEsObservable","subscription","_closed","_promise","rejected","115","156","164","53","onNextOrObserver","onErrorFn","onCompletedFn","_observer","102","54","checkCacheAndReport","getRequestCycle","GetResponse","isJSONGraph","isProgressive","forceCollect","currentRemainingPaths","55","56","gets","progressive","completed","errs","errorsLength","getResponse","boundRequestedMissingPaths","boundPathLength","currentRequestDisposable","nextRequestedMissingPaths","nextResults","fromPathsOrPathValues","60","ObserveResponse","uniqueId","autoIncrementingId","observerId","pathObservers","pathObs","find","po","62","setRequestCycle","SetResponse","_isJSONGraph","_isProgressive","_initialArgs","65","setValidInput","66","64","pluckPath","pluckEnvelopePaths","arrayFlatMap","groupIndex","groupCount","returnValue","methodArgs","operationName","successfulPaths","77","getJSONGraph","subscribeToFollowupGet","setGroupsIntoCache","requestedAndOptimizedPaths","prevVersion","currentJSONGraph","requestDisposable","jsonGraphEnv","isCompleted","asap","action","scheduleWithState","123","delay","TimerDisposable","clearTimeout","setJSONGraphPathSet","messageRoot","messageParent","replacedPaths","optimizedIndex","setNode","setReference","mergeJSONGraphNode","jsonGraphEnvelopes","jsonGraphEnvelopeIndex","jsonGraphEnvelopeCount","100","91","setPathMap","getKeys","keyIndex","keyCount","mergeValueOrInsertBranch","itr","pathMapEnvelope","101","setPathSet","pathValueIndex","pathValueCount","pv","valueArg","errorSelectorArg","comparatorArg","array","array2","other","array3","indexArg","endArg","80","dest","84","86","$timestamp","87","anyType","prop","90","now","$now","$never","exp","103","120","func","getTimestamp","wrapNode","insertNode","replaceNode","reconstructPath","sizeOffset","cType","mType","cIsObject","mIsObject","cTimestamp","mTimestamp","isDistinct","104","107","114","getType","updateBackReferenceVersions","111","Date","currentPath","unlinkBackReferences","unlinkForwardReference","109","110","prefix","key2","transferBackReferences","108","fromNode","destNode","fromNodeRefsLength","destNodeRefsLength","destination","stack","offset","allowedInput","valid","String","expiresNow","getExpires","atomType","typeArg","modelCreated","atomSize","expires","FromEsObserverAdapter","esObserver","ToEsSubscriptionAdapter","_self","complete","121","throwFirstError","pendingErrors","shift","task","rawTask","freeTasks","RawTask","rawAsap","requestErrorThrow","makeRequestCallFromTimer","122","queue","requestFlush","flushing","flush","currentIndex","capacity","scan","newLength","handleTimer","timeoutHandle","clearInterval","intervalHandle","setInterval","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","toggle","characterData","124","scope","simpleExtend","obj2","XMLHttpSource","jsongUrl","config","_jsongUrl","timeout","_config","buildQueryObject","queryObject","jsongEnv","pathSuffix","queryData","126","129","qData","isQueryParamUrl","startUrl","127","xhr","XDomainRequest","128","progId","progIds","ActiveXObject","Observable","isDone","async","responseType","hasOwnProp","onBeforeRequest","getCORSRequest","getXMLHttpRequest","user","password","onreadystatechange","readyState","onXhrLoad","ontimeout","onXhrError","abort","_handleXhrError","textStatus","errorThrown","responseData","sentinel","copy","errorValue","pathInvalidation","131","integers","ranges","132","token","dotSeparator","commaSeparator","openingBracket","closingBracket","openingBrace","closingBrace","escape","space","colon","quote","unknown","133","indexer","nested","needQuotes","leadingDot","leadingComma","requiresComma","routedTokens","range","precedingNaN","suceedingNaN","routed","invalid","illegalEscape","unexpectedToken","invalidIdentifier","invalidPath","throwError","tokenizer","parseString","Tokenizer","RoutedTokens","parser","string","extendedRules","ext","135","140","TokenTypes","first","isNaN","136","idxE","openingToken","allowedMaxLength","routedIndexer","137","138","139","quoteE","innerToken","openingQuote","escaping","peek","dotCount","inclusive","toNumber","routedE","routeToken","named","toOutput","getNext","output","specialChars","EXT_SPECIAL_CHARACTERS","SPECIAL_CHARACTERS","character","DOT_SEPARATOR","COMMA_SEPARATOR","OPENING_BRACKET","CLOSING_BRACKET","OPENING_BRACE","CLOSING_BRACE","SPACE","DOUBLE_OUOTES","SINGE_OUOTES","ESCAPE","COLON","_string","_idx","_extended","nextToken","_nextToken","NaN","141","collapseMap","acc","collapseKey","154","155","142","innerReferences","circularReference","143","cloneArray","cacheRoot","maxRefFollow","current","referenceCount","throwToNext","152","153","144","intersects","146","pathsComplementFromTree","pathsComplementFromLengthTree","optimizePathSets","147","148","149","150","initializeRange","rangeOffset","initializeNote","arrayOffset","nextValue","optimizePathSet","catAndSlice","nextOptimized","optimizedPathLength","refResults","$types","151","getRangeOrKeySize","rangeOrKey","getRangeSize","parseInt","getPathCount","numPaths","segment","numKeys","outLength","typeOfObject","collapsePathMap","pathmap","subPath","subCode","subKeys","subKeysIndex","subKeysCount","subSets","subSetsIndex","subSetsCount","pathset","pathsetIndex","pathsetCount","firstSubKey","pathsetClone","getHashCode","subs","codes","codesIndex","codesCount","pathsets","pathsetsCount","getSortedKeys","sets","isSafeNumber","collapsePathSetIndexes","keysetIndex","keysetCount","keyset","collapseIndex","isSparseRange","sort","sortListAscending","charCodeAt","num","typeOfString","MIN_SAFE_INTEGER_DIGITS","safeNumberRegEx","MAX_SAFE_INTEGER_DIGITS","typeOfNumber","MAX_SAFE_INTEGER","lengths","allPathsLength","pathsIndex","pathsCount","_isSafeNumber","innerToTree","161","157","getThen","LAST_ERROR","IS_ERROR","tryCallOne","tryCallTwo","_75","_83","_18","_38","safeThen","_47","handleResolved","_71","_44","158","159","valuePromise","TRUE","FALSE","NULL","UNDEFINED","ZERO","EMPTYSTRING","160","162","163","denodeifyWithCount","argumentCount","callbackFn","Function","denodeifyWithoutCount","fnLength","denodeify","Infinity","nodeify","ctx","enableSynchronous","isPending","getState","isFulfilled","isRejected","getReason","disableSynchronous","_ponyfill","_ponyfill2","165","symbolObservablePonyfill","_Symbol","Symbol","observable","h6ac","eval","kTIn","content","lcwS","cssWithMappingToString","useSourceMap","cssMapping","sourceMapping","toComment","toString","mediaQuery","alreadyImportedModules","m+Gh","pwNi","_preact","interopDefault","firstElementChild","init","app"],"mappings":"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","file":"bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"pwNi\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"BMrJ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar memoize = function memoize(fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = function (fn) {\n\tvar memo = {};\n\n\treturn function (selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector];\n\t};\n}(function (target) {\n\treturn document.querySelector(target);\n});\n\nvar singleton = null;\nvar singletonCounter = 0;\nvar stylesInsertedAtTop = [];\n\nvar fixUrls = __webpack_require__(\"DRTY\");\n\nmodule.exports = function (list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif (newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif (domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t}delete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom(styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif (domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor (; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor (var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = { id: item.id, refs: 1, parts: parts };\n\t\t}\n\t}\n}\n\nfunction listToStyles(list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = { css: css, media: media, sourceMap: sourceMap };\n\n\t\tif (!newStyles[id]) styles.push(newStyles[id] = { id: id, parts: [part] });else newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement(options, style) {\n\tvar target = getElement(options.insertInto);\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif (idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement(options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs(el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle(obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t\tresult = options.transform(obj.css);\n\n\t\tif (result) {\n\t\t\t// If transform returns a value, use that instead of the original css.\n\t\t\t// This allows running runtime transformations on the css.\n\t\t\tobj.css = result;\n\t\t} else {\n\t\t\t// If the transform function returns a falsy value, don't add this css.\n\t\t\t// This allows conditional loading of css\n\t\t\treturn function () {\n\t\t\t\t// noop\n\t\t\t};\n\t\t}\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\t} else if (obj.sourceMap && typeof URL === \"function\" && typeof URL.createObjectURL === \"function\" && typeof URL.revokeObjectURL === \"function\" && typeof Blob === \"function\" && typeof btoa === \"function\") {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function remove() {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif (style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function remove() {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif (newObj) {\n\t\t\tif (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif (media) {\n\t\tstyle.setAttribute(\"media\", media);\n\t}\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile (style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n \tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n \tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n \ton by default.  Otherwise default to the convertToAbsoluteUrls option\n \tdirectly\n */\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif (oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n/***/ }),\n\n/***/ \"BtxX\":\n/***/ (function(module, exports) {\n\n(function (root) {\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {}\n\n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  function Promise(fn) {\n    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    Promise._immediateFn(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise._immediateFn(function () {\n        if (!self._handled) {\n          Promise._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var prom = new this.constructor(noop);\n\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function (arr) {\n    return new Promise(function (resolve, reject) {\n      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');\n      var args = Array.prototype.slice.call(arr);\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  // Use polyfill for setImmediate for performance gains\n  Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {\n    setImmediate(fn);\n  } || function (fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\n  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  /**\n   * Set the immediate function to execute callbacks\n   * @param fn {function} Function to execute\n   * @deprecated\n   */\n  Promise._setImmediateFn = function _setImmediateFn(fn) {\n    Promise._immediateFn = fn;\n  };\n\n  /**\n   * Change the function to execute on unhandled rejection\n   * @param {function} fn Function to execute on unhandled rejection\n   * @deprecated\n   */\n  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n    Promise._unhandledRejectionFn = fn;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  }\n})(this);\n\n/***/ }),\n\n/***/ \"DRTY\":\n/***/ (function(module, exports) {\n\n\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n\t// get current location\n\tvar location = typeof window !== \"undefined\" && window.location;\n\n\tif (!location) {\n\t\tthrow new Error(\"fixUrls requires window.location\");\n\t}\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t\treturn css;\n\t}\n\n\tvar baseUrl = location.protocol + \"//\" + location.host;\n\tvar currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n This regular expression is just a way to recursively match brackets within\n a string.\n \t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n    (  = Start a capturing group\n      (?:  = Start a non-capturing group\n          [^)(]  = Match anything that isn't a parentheses\n          |  = OR\n          \\(  = Match a start parentheses\n              (?:  = Start another non-capturing groups\n                  [^)(]+  = Match anything that isn't a parentheses\n                  |  = OR\n                  \\(  = Match a start parentheses\n                      [^)(]*  = Match anything that isn't a parentheses\n                  \\)  = Match a end parentheses\n              )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n  \\)  = Match a close parens\n \t /gi  = Get all matches, not the first.  Be case insensitive.\n  */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function (fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl.trim().replace(/^\"(.*)\"$/, function (o, $1) {\n\t\t\treturn $1;\n\t\t}).replace(/^'(.*)'$/, function (o, $1) {\n\t\t\treturn $1;\n\t\t});\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t\treturn fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t\t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n/***/ }),\n\n/***/ \"JkW7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ../node_modules/preact/dist/preact.min.js\nvar preact_min = __webpack_require__(\"KM04\");\nvar preact_min_default = /*#__PURE__*/__webpack_require__.n(preact_min);\n\n// CONCATENATED MODULE: ../node_modules/preact-habitat/dist/preact-habitat.es.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n/**\r\n * Removes `-` fron a string and capetalize the letter after\r\n * example: data-props-hello-world =>  dataPropsHelloWorld\r\n * Used for props passed from host DOM element\r\n * @param  {String} str string\r\n * @return {String} Capetalized string\r\n */\nvar camelcasize = function camelcasize(str) {\n  return str.replace(/-([a-z])/gi, function (all, letter) {\n    return letter.toUpperCase();\n  });\n};\n\n/**\r\n * [getExecutedScript internal widget to provide the currently executed script]\r\n * @param  {document} document [Browser document object]\r\n * @return {HTMLElement}     [script Element]\r\n */\nvar getExecutedScript = function getExecutedScript() {\n  return document.currentScript || function () {\n    var scripts = document.getElementsByTagName(\"script\");\n    return scripts[scripts.length - 1];\n  }();\n};\n\n/**\r\n * Get the props from a host element's data attributes\r\n * @param  {Element} tag The host element\r\n * @return {Object}  props object to be passed to the component\r\n */\nvar collectPropsFromElement = function collectPropsFromElement(element, defaultProps) {\n  if (defaultProps === void 0) defaultProps = {};\n\n  var attrs = element.attributes;\n\n  var props = _extends({}, defaultProps);\n\n  // collect from element\n  Object.keys(attrs).forEach(function (key) {\n    if (attrs.hasOwnProperty(key)) {\n      var dataAttrName = attrs[key].name;\n      if (!dataAttrName || typeof dataAttrName !== \"string\") {\n        return false;\n      }\n      var propName = dataAttrName.split(/(data-props?-)/).pop() || '';\n      propName = camelcasize(propName);\n      if (dataAttrName !== propName) {\n        var propValue = attrs[key].nodeValue;\n        props[propName] = propValue;\n      }\n    }\n  });\n\n  // check for child script text/props\n  [].forEach.call(element.getElementsByTagName('script'), function (scrp) {\n    var propsObj = {};\n    if (scrp.hasAttribute('type')) {\n      if (scrp.getAttribute('type') !== 'text/props') {\n        return;\n      }\n      try {\n        propsObj = JSON.parse(scrp.innerHTML);\n      } catch (e) {\n        throw new Error(e);\n      }\n      _extends(props, propsObj);\n    }\n  });\n\n  return props;\n};\n\nvar getHabitatSelectorFromClient = function getHabitatSelectorFromClient(currentScript) {\n  var scriptTagAttrs = currentScript.attributes;\n  var selector = null;\n  // check for another props attached to the tag\n  Object.keys(scriptTagAttrs).forEach(function (key) {\n    if (scriptTagAttrs.hasOwnProperty(key)) {\n      var dataAttrName = scriptTagAttrs[key].name;\n      if (dataAttrName === 'data-mount-in') {\n        selector = scriptTagAttrs[key].nodeValue;\n      }\n    }\n  });\n  return selector;\n};\n\n/**\r\n * Return array of 0 or more elements that will host our widget\r\n * @param  {id} attrId the data widget id attribute the host should have\r\n * @param  {document} scope  Docuemnt object or DOM Element as a scope\r\n * @return {Array}        Array of matching habitats\r\n */\nvar widgetDOMHostElements = function widgetDOMHostElements(ref) {\n  var selector = ref.selector;\n  var inline = ref.inline;\n  var clientSpecified = ref.clientSpecified;\n\n  var hostNodes = [];\n  var currentScript = getExecutedScript();\n\n  if (inline === true) {\n    var parentNode = currentScript.parentNode;\n    hostNodes.push(parentNode);\n  }\n  if (clientSpecified === true && !selector) {\n    // user did not specify where to mount - get it from script tag attributes\n    selector = getHabitatSelectorFromClient(currentScript);\n  }\n  if (selector) {\n    [].forEach.call(document.querySelectorAll(selector), function (queriedTag) {\n      hostNodes.push(queriedTag);\n    });\n  }\n  return hostNodes;\n};\n\n/**\r\n * preact render function that will be queued if the DOM is not ready\r\n * and executed immeidatly if DOM is ready\r\n */\nvar preact_habitat_es_preactRender = function preactRender(widget, hostElements, root, cleanRoot, defaultProps) {\n  hostElements.forEach(function (elm) {\n    var hostNode = elm;\n    if (hostNode._habitat) {\n      return;\n    }\n    hostNode._habitat = true;\n    var props = collectPropsFromElement(elm, defaultProps) || defaultProps;\n    if (cleanRoot) {\n      hostNode.innerHTML = \"\";\n    }\n    return preact_min_default.a.render(preact_min_default.a.h(widget, props), hostNode, root);\n  });\n};\n\nvar habitat = function habitat(Widget) {\n  // Widget represents the Preact component we need to mount\n  var widget = Widget;\n  // preact root render helper\n  var root = null;\n\n  var render = function render(ref) {\n    if (ref === void 0) ref = {};\n    var selector = ref.selector;if (selector === void 0) selector = null;\n    var inline = ref.inline;if (inline === void 0) inline = false;\n    var clean = ref.clean;if (clean === void 0) clean = false;\n    var clientSpecified = ref.clientSpecified;if (clientSpecified === void 0) clientSpecified = false;\n    var defaultProps = ref.defaultProps;if (defaultProps === void 0) defaultProps = {};\n\n    var elements = widgetDOMHostElements({\n      selector: selector,\n      inline: inline,\n      clientSpecified: clientSpecified\n    });\n    var loaded = function loaded() {\n      if (elements.length > 0) {\n        var elements$1 = widgetDOMHostElements({\n          selector: selector,\n          inline: inline,\n          clientSpecified: clientSpecified\n        });\n\n        return preact_habitat_es_preactRender(widget, elements$1, root, clean, defaultProps);\n      }\n    };\n    loaded();\n    document.addEventListener(\"DOMContentLoaded\", loaded);\n    document.addEventListener(\"load\", loaded);\n  };\n\n  return { render: render };\n};\n\n/* harmony default export */ var preact_habitat_es = (habitat);\n//# sourceMappingURL=preact-habitat.es.js.map\n// EXTERNAL MODULE: ./components/chatbox/style.scss\nvar style = __webpack_require__(\"kTIn\");\nvar style_default = /*#__PURE__*/__webpack_require__.n(style);\n\n// EXTERNAL MODULE: ../node_modules/falcor/dist/falcor.browser.js\nvar falcor_browser = __webpack_require__(\"XLyV\");\nvar falcor_browser_default = /*#__PURE__*/__webpack_require__.n(falcor_browser);\n\n// CONCATENATED MODULE: ./components/chatbox/model.js\n\n\nvar $ref = falcor_browser_default.a.Model.ref;\nvar $atom = falcor_browser_default.a.Model.atom;\nvar pathValue = falcor_browser_default.a.pathValue;\n\nvar api_url = 'http://81.17.61.67';\n\nvar model = new falcor_browser_default.a.Model({\n  source: new falcor_browser_default.a.HttpDataSource(api_url + ':3001/model.json', {\n    crossDomain: true,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  })\n});\n\nvar ApiModel = {\n  getAllAgents: function getAllAgents(account_id) {\n    return model.call('agent.all', [{ account_id: account_id }]);\n  },\n  addResponse: function addResponse(intent) {\n    var args = {\n      intent_id: intent.intent_id,\n      agent_id: intent.agent_id,\n      intent_action: intent.intent_action\n    };\n    return model.call('response.add', [args]);\n  },\n  addAgent: function addAgent() {\n    var args = {\n      agent_name: 'NewAgent',\n      account_id: 'abc',\n      flg_active: true\n    };\n    return model.call('agent.add', [args]);\n  },\n  trainModel: function trainModel(agent_id) {\n    var args = {\n      agent_id: agent_id\n    };\n    return model.call('train.do', [args]);\n  },\n  generateIntents: function generateIntents(dsl, agent_id) {\n    var args = {\n      dsl: dsl,\n      agent_id: agent_id\n    };\n    return model.call('intent.generate', [args]);\n  },\n  resetSession: function resetSession(id) {\n    var args = {\n      id: id\n    };\n    return model.call('session.reset', [args]);\n  },\n  addConnection: function addConnection(from, to) {\n    console.log({ from: from, to: to });\n    return model.call('connection.add', [{ from: from, to: to }]);\n  },\n  delInteraction: function delInteraction(id) {\n    var args = { id: id };\n    return model.call('interaction.remove', [args]);\n  },\n  setResponse: function setResponse(response_id, data) {\n    var paths = [pathValue(['response', response_id, 'message'], data.message)];\n    return model.set(paths[0]);\n  },\n  setAgent: function setAgent(agent_id, data) {\n    var paths = [pathValue(['agent', agent_id, 'agent_name'], data.agent_name)];\n    console.log(paths);\n    return model.set(paths[0]);\n  },\n  doChat: function doChat(data) {\n    return model.call('chat.add', [data]);\n  },\n  getAllResponses: function getAllResponses(intent_id) {\n    return model.call('response.all', [{ intent_id: intent_id }]);\n  },\n  getAllIntents: function getAllIntents(agent_id) {\n    return model.call('intent.all', [{ agent_id: agent_id }]);\n  }\n};\n\n/* harmony default export */ var chatbox_model = (ApiModel);\n// CONCATENATED MODULE: ./components/chatbox/index.js\n\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar ENTER_KEY = 13;\n\nvar chatbox_UserMessage = function (_Component) {\n  _inherits(UserMessage, _Component);\n\n  function UserMessage() {\n    _classCallCheck(this, UserMessage);\n\n    return _possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  UserMessage.prototype.render = function render(_ref) {\n    var chat = _ref.chat,\n        props = _ref.props;\n\n    console.log(chat);\n    if (chat.isbot) {\n      return Object(preact_min[\"h\"])(\n        \"div\",\n        { \"class\": style_default.a.message + \" \" + style_default.a.new },\n        Object(preact_min[\"h\"])(\n          \"figure\",\n          { \"class\": style_default.a.avatar },\n          Object(preact_min[\"h\"])(\"img\", { src: props.avatar })\n        ),\n        chat.message\n      );\n    } else {\n      return Object(preact_min[\"h\"])(\n        \"div\",\n        { \"class\": style_default.a.message + \" \" + style_default.a.message_personal + \" \" + style_default.a.new },\n        chat.message\n      );\n    }\n  };\n\n  return UserMessage;\n}(preact_min[\"Component\"]);\n\nvar chatbox_App = function (_Component2) {\n  _inherits(App, _Component2);\n\n  function App() {\n    var _temp, _this2, _ret;\n\n    _classCallCheck(this, App);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.agent_id = 0, _this2.state = {\n      account: 'me',\n      showChatBox: false,\n      session: 100,\n      started: false,\n      message: '',\n      messages: []\n    }, _this2.onEnter = function (e) {\n      if (e.which === ENTER_KEY) {\n        var message = e.target.value.trim();\n        if (!message.length) {\n          alert('Ingrese un Mensaje!');\n          return;\n        }\n        _this2.setState({\n          message: message\n        });\n        _this2.sendChat(message);\n        e.target.value = null;\n      }\n    }, _this2.sendChat = function (message) {\n\n      var chat = {\n        from: _this2.state.account,\n        message: message,\n        image: false,\n        session: _this2.state.session,\n        agent_id: _this2.agent_id\n      };\n\n      _this2.renderChat(chat);\n\n      _this2.setState({\n        message: ''\n      });\n\n      // ADD BOT RESPONSE\n      var that = _this2;\n      _this2.apiDoChat(chat).then(function (responses) {\n        console.log(responses);\n        responses.map(function (r) {\n          that.renderChat(r);\n        });\n      });\n    }, _this2.apiDoChat = function (chat) {\n      return new Promise(function (resolve, reject) {\n\n        chatbox_model.doChat(chat).then(function (data) {\n          var r = data.json.chat;\n          var id = Object.keys(r)[1];\n          var response = r[id];\n          var responses = [];\n\n          delete response.messages['$__path'];\n          var messages = response.messages;\n\n          Object.keys(messages).map(function (item) {\n            var message = messages[item];\n            responses.push({\n              from: 'LBot',\n              message: message.text,\n              image: !message.image ? false : message.image\n            });\n          });\n          resolve(responses);\n          document.getElementById(\"lg_compose_chat\").focus();\n        });\n      });\n    }, _this2.handleChange = function (e) {\n      _this2.setState({\n        message: e.target.value\n      });\n    }, _this2.renderChat = function (data) {\n      var messages = _this2.state.messages;\n      var isbot = data.from == 'LBot' ? true : false;\n      var image = data.image ? data.image : false;\n\n      var chat = {\n        from: data.from,\n        message: data.message,\n        image: image,\n        isbot: isbot\n      };\n\n      messages.push(chat);\n\n      _this2.setState({\n        messages: messages\n      }, function (e) {\n        var bodychat = document.getElementById('lg_body_messages');\n        bodychat.scrollTop = bodychat.scrollHeight;\n      });\n    }, _temp), _possibleConstructorReturn(_this2, _ret);\n  }\n\n  App.prototype.render = function render(props) {\n    this.agent_id = props.agent_id;\n    return Object(preact_min[\"h\"])(\n      \"div\",\n      { \"class\": style_default.a.chat },\n      Object(preact_min[\"h\"])(\n        \"div\",\n        { \"class\": style_default.a.chat_title },\n        Object(preact_min[\"h\"])(\n          \"h1\",\n          null,\n          props.name\n        ),\n        Object(preact_min[\"h\"])(\n          \"h2\",\n          null,\n          props.title\n        ),\n        Object(preact_min[\"h\"])(\n          \"figure\",\n          { \"class\": style_default.a.avatar },\n          Object(preact_min[\"h\"])(\"img\", { src: props.avatar })\n        )\n      ),\n      Object(preact_min[\"h\"])(\n        \"div\",\n        { \"class\": style_default.a.messages },\n        Object(preact_min[\"h\"])(\n          \"div\",\n          { id: \"lg_body_messages\", \"class\": style_default.a.messages_content },\n          this.state.messages.map(function (chat) {\n            return Object(preact_min[\"h\"])(chatbox_UserMessage, { chat: chat, props: props });\n          })\n        )\n      ),\n      Object(preact_min[\"h\"])(\n        \"div\",\n        { \"class\": style_default.a.message_box },\n        Object(preact_min[\"h\"])(\"textarea\", {\n          id: \"lg_compose_chat\",\n          type: \"text\",\n          onKeyUp: this.onEnter,\n          \"class\": style_default.a.message_input,\n          placeholder: \"Escriba su consulta aqu\\xED ...\"\n        }),\n        Object(preact_min[\"h\"])(\n          \"button\",\n          { type: \"submit\", \"class\": style_default.a.message_submit },\n          \"Enviar\"\n        )\n      )\n    );\n  };\n\n  return App;\n}(preact_min[\"Component\"]);\n\n\n// CONCATENATED MODULE: ./index.js\nvar poly = __webpack_require__(\"m+Gh\");\n\n\n\n\n\n\nvar _habitat = preact_habitat_es(chatbox_App);\n\n_habitat.render({\n  selector: '[data-widget-host=\"habitat\"]',\n  clean: true\n});\n\n/***/ }),\n\n/***/ \"KM04\":\n/***/ (function(module, exports, __webpack_require__) {\n\n!function () {\n  \"use strict\";\n  function e(e, t) {\n    var n,\n        o,\n        r,\n        i,\n        l = M;for (i = arguments.length; i-- > 2;) {\n      T.push(arguments[i]);\n    }t && null != t.children && (T.length || T.push(t.children), delete t.children);while (T.length) {\n      if ((o = T.pop()) && void 0 !== o.pop) for (i = o.length; i--;) {\n        T.push(o[i]);\n      } else \"boolean\" == typeof o && (o = null), (r = \"function\" != typeof e) && (null == o ? o = \"\" : \"number\" == typeof o ? o += \"\" : \"string\" != typeof o && (r = !1)), r && n ? l[l.length - 1] += o : l === M ? l = [o] : l.push(o), n = r;\n    }var a = new S();return a.nodeName = e, a.children = l, a.attributes = null == t ? void 0 : t, a.key = null == t ? void 0 : t.key, void 0 !== L.vnode && L.vnode(a), a;\n  }function t(e, t) {\n    for (var n in t) {\n      e[n] = t[n];\n    }return e;\n  }function n(n, o) {\n    return e(n.nodeName, t(t({}, n.attributes), o), arguments.length > 2 ? [].slice.call(arguments, 2) : n.children);\n  }function o(e) {\n    !e.__d && (e.__d = !0) && 1 == D.push(e) && (L.debounceRendering || P)(r);\n  }function r() {\n    var e,\n        t = D;D = [];while (e = t.pop()) {\n      e.__d && C(e);\n    }\n  }function i(e, t, n) {\n    return \"string\" == typeof t || \"number\" == typeof t ? void 0 !== e.splitText : \"string\" == typeof t.nodeName ? !e._componentConstructor && l(e, t.nodeName) : n || e._componentConstructor === t.nodeName;\n  }function l(e, t) {\n    return e.__n === t || e.nodeName.toLowerCase() === t.toLowerCase();\n  }function a(e) {\n    var n = t({}, e.attributes);n.children = e.children;var o = e.nodeName.defaultProps;if (void 0 !== o) for (var r in o) {\n      void 0 === n[r] && (n[r] = o[r]);\n    }return n;\n  }function p(e, t) {\n    var n = t ? document.createElementNS(\"http://www.w3.org/2000/svg\", e) : document.createElement(e);return n.__n = e, n;\n  }function s(e) {\n    var t = e.parentNode;t && t.removeChild(e);\n  }function u(e, t, n, o, r) {\n    if (\"className\" === t && (t = \"class\"), \"key\" === t) ;else if (\"ref\" === t) n && n(null), o && o(e);else if (\"class\" !== t || r) {\n      if (\"style\" === t) {\n        if (o && \"string\" != typeof o && \"string\" != typeof n || (e.style.cssText = o || \"\"), o && \"object\" == typeof o) {\n          if (\"string\" != typeof n) for (var i in n) {\n            i in o || (e.style[i] = \"\");\n          }for (var i in o) {\n            e.style[i] = \"number\" == typeof o[i] && !1 === W.test(i) ? o[i] + \"px\" : o[i];\n          }\n        }\n      } else if (\"dangerouslySetInnerHTML\" === t) o && (e.innerHTML = o.__html || \"\");else if (\"o\" == t[0] && \"n\" == t[1]) {\n        var l = t !== (t = t.replace(/Capture$/, \"\"));t = t.toLowerCase().substring(2), o ? n || e.addEventListener(t, c, l) : e.removeEventListener(t, c, l), (e.__l || (e.__l = {}))[t] = o;\n      } else if (\"list\" !== t && \"type\" !== t && !r && t in e) {\n        try {\n          e[t] = null == o ? \"\" : o;\n        } catch (e) {}null != o && !1 !== o || \"spellcheck\" == t || e.removeAttribute(t);\n      } else {\n        var a = r && t !== (t = t.replace(/^xlink:?/, \"\"));null == o || !1 === o ? a ? e.removeAttributeNS(\"http://www.w3.org/1999/xlink\", t.toLowerCase()) : e.removeAttribute(t) : \"function\" != typeof o && (a ? e.setAttributeNS(\"http://www.w3.org/1999/xlink\", t.toLowerCase(), o) : e.setAttribute(t, o));\n      }\n    } else e.className = o || \"\";\n  }function c(e) {\n    return this.__l[e.type](L.event && L.event(e) || e);\n  }function _() {\n    var e;while (e = E.pop()) {\n      L.afterMount && L.afterMount(e), e.componentDidMount && e.componentDidMount();\n    }\n  }function d(e, t, n, o, r, i) {\n    V++ || (A = null != r && void 0 !== r.ownerSVGElement, H = null != e && !(\"__preactattr_\" in e));var l = f(e, t, n, o, i);return r && l.parentNode !== r && r.appendChild(l), --V || (H = !1, i || _()), l;\n  }function f(e, t, n, o, r) {\n    var i = e,\n        a = A;if (null != t && \"boolean\" != typeof t || (t = \"\"), \"string\" == typeof t || \"number\" == typeof t) return e && void 0 !== e.splitText && e.parentNode && (!e._component || r) ? e.nodeValue != t && (e.nodeValue = t) : (i = document.createTextNode(t), e && (e.parentNode && e.parentNode.replaceChild(i, e), m(e, !0))), i.__preactattr_ = !0, i;var s = t.nodeName;if (\"function\" == typeof s) return x(e, t, n, o);if (A = \"svg\" === s || \"foreignObject\" !== s && A, s += \"\", (!e || !l(e, s)) && (i = p(s, A), e)) {\n      while (e.firstChild) {\n        i.appendChild(e.firstChild);\n      }e.parentNode && e.parentNode.replaceChild(i, e), m(e, !0);\n    }var u = i.firstChild,\n        c = i.__preactattr_,\n        _ = t.children;if (null == c) {\n      c = i.__preactattr_ = {};for (var d = i.attributes, f = d.length; f--;) {\n        c[d[f].name] = d[f].value;\n      }\n    }return !H && _ && 1 === _.length && \"string\" == typeof _[0] && null != u && void 0 !== u.splitText && null == u.nextSibling ? u.nodeValue != _[0] && (u.nodeValue = _[0]) : (_ && _.length || null != u) && h(i, _, n, o, H || null != c.dangerouslySetInnerHTML), b(i, t.attributes, c), A = a, i;\n  }function h(e, t, n, o, r) {\n    var l,\n        a,\n        p,\n        u,\n        c,\n        _ = e.childNodes,\n        d = [],\n        h = {},\n        v = 0,\n        b = 0,\n        y = _.length,\n        g = 0,\n        w = t ? t.length : 0;if (0 !== y) for (var C = 0; C < y; C++) {\n      var x = _[C],\n          N = x.__preactattr_,\n          k = w && N ? x._component ? x._component.__k : N.key : null;null != k ? (v++, h[k] = x) : (N || (void 0 !== x.splitText ? !r || x.nodeValue.trim() : r)) && (d[g++] = x);\n    }if (0 !== w) for (var C = 0; C < w; C++) {\n      u = t[C], c = null;var k = u.key;if (null != k) v && void 0 !== h[k] && (c = h[k], h[k] = void 0, v--);else if (b < g) for (l = b; l < g; l++) {\n        if (void 0 !== d[l] && i(a = d[l], u, r)) {\n          c = a, d[l] = void 0, l === g - 1 && g--, l === b && b++;break;\n        }\n      }c = f(c, u, n, o), p = _[C], c && c !== e && c !== p && (null == p ? e.appendChild(c) : c === p.nextSibling ? s(p) : e.insertBefore(c, p));\n    }if (v) for (var C in h) {\n      void 0 !== h[C] && m(h[C], !1);\n    }while (b <= g) {\n      void 0 !== (c = d[g--]) && m(c, !1);\n    }\n  }function m(e, t) {\n    var n = e._component;n ? N(n) : (null != e.__preactattr_ && e.__preactattr_.ref && e.__preactattr_.ref(null), !1 !== t && null != e.__preactattr_ || s(e), v(e));\n  }function v(e) {\n    e = e.lastChild;while (e) {\n      var t = e.previousSibling;m(e, !0), e = t;\n    }\n  }function b(e, t, n) {\n    var o;for (o in n) {\n      t && null != t[o] || null == n[o] || u(e, o, n[o], n[o] = void 0, A);\n    }for (o in t) {\n      \"children\" === o || \"innerHTML\" === o || o in n && t[o] === (\"value\" === o || \"checked\" === o ? e[o] : n[o]) || u(e, o, n[o], n[o] = t[o], A);\n    }\n  }function y(e, t, n) {\n    var o,\n        r = B.length;e.prototype && e.prototype.render ? (o = new e(t, n), k.call(o, t, n)) : (o = new k(t, n), o.constructor = e, o.render = g);while (r--) {\n      if (B[r].constructor === e) return o.__b = B[r].__b, B.splice(r, 1), o;\n    }return o;\n  }function g(e, t, n) {\n    return this.constructor(e, n);\n  }function w(e, t, n, r, i) {\n    e.__x || (e.__x = !0, e.__r = t.ref, e.__k = t.key, delete t.ref, delete t.key, void 0 === e.constructor.getDerivedStateFromProps && (!e.base || i ? e.componentWillMount && e.componentWillMount() : e.componentWillReceiveProps && e.componentWillReceiveProps(t, r)), r && r !== e.context && (e.__c || (e.__c = e.context), e.context = r), e.__p || (e.__p = e.props), e.props = t, e.__x = !1, 0 !== n && (1 !== n && !1 === L.syncComponentUpdates && e.base ? o(e) : C(e, 1, i)), e.__r && e.__r(e));\n  }function C(e, n, o, r) {\n    if (!e.__x) {\n      var i,\n          l,\n          p,\n          s = e.props,\n          u = e.state,\n          c = e.context,\n          f = e.__p || s,\n          h = e.__s || u,\n          v = e.__c || c,\n          b = e.base,\n          g = e.__b,\n          x = b || g,\n          k = e._component,\n          U = !1,\n          S = v;if (e.constructor.getDerivedStateFromProps && (u = t(t({}, u), e.constructor.getDerivedStateFromProps(s, u)), e.state = u), b && (e.props = f, e.state = h, e.context = v, 2 !== n && e.shouldComponentUpdate && !1 === e.shouldComponentUpdate(s, u, c) ? U = !0 : e.componentWillUpdate && e.componentWillUpdate(s, u, c), e.props = s, e.state = u, e.context = c), e.__p = e.__s = e.__c = e.__b = null, e.__d = !1, !U) {\n        i = e.render(s, u, c), e.getChildContext && (c = t(t({}, c), e.getChildContext())), b && e.getSnapshotBeforeUpdate && (S = e.getSnapshotBeforeUpdate(f, h));var T,\n            M,\n            P = i && i.nodeName;if (\"function\" == typeof P) {\n          var W = a(i);l = k, l && l.constructor === P && W.key == l.__k ? w(l, W, 1, c, !1) : (T = l, e._component = l = y(P, W, c), l.__b = l.__b || g, l.__u = e, w(l, W, 0, c, !1), C(l, 1, o, !0)), M = l.base;\n        } else p = x, T = k, T && (p = e._component = null), (x || 1 === n) && (p && (p._component = null), M = d(p, i, c, o || !b, x && x.parentNode, !0));if (x && M !== x && l !== k) {\n          var D = x.parentNode;D && M !== D && (D.replaceChild(M, x), T || (x._component = null, m(x, !1)));\n        }if (T && N(T), e.base = M, M && !r) {\n          var A = e,\n              H = e;while (H = H.__u) {\n            (A = H).base = M;\n          }M._component = A, M._componentConstructor = A.constructor;\n        }\n      }!b || o ? E.unshift(e) : U || (e.componentDidUpdate && e.componentDidUpdate(f, h, S), L.afterUpdate && L.afterUpdate(e));while (e.__h.length) {\n        e.__h.pop().call(e);\n      }V || r || _();\n    }\n  }function x(e, t, n, o) {\n    var r = e && e._component,\n        i = r,\n        l = e,\n        p = r && e._componentConstructor === t.nodeName,\n        s = p,\n        u = a(t);while (r && !s && (r = r.__u)) {\n      s = r.constructor === t.nodeName;\n    }return r && s && (!o || r._component) ? (w(r, u, 3, n, o), e = r.base) : (i && !p && (N(i), e = l = null), r = y(t.nodeName, u, n), e && !r.__b && (r.__b = e, l = null), w(r, u, 1, n, o), e = r.base, l && e !== l && (l._component = null, m(l, !1))), e;\n  }function N(e) {\n    L.beforeUnmount && L.beforeUnmount(e);var t = e.base;e.__x = !0, e.componentWillUnmount && e.componentWillUnmount(), e.base = null;var n = e._component;n ? N(n) : t && (t.__preactattr_ && t.__preactattr_.ref && t.__preactattr_.ref(null), e.__b = t, s(t), B.push(e), v(t)), e.__r && e.__r(null);\n  }function k(e, t) {\n    this.__d = !0, this.context = t, this.props = e, this.state = this.state || {}, this.__h = [];\n  }function U(e, t, n) {\n    return d(n, e, {}, !1, t, !1);\n  }var S = function S() {},\n      L = {},\n      T = [],\n      M = [],\n      P = \"function\" == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout,\n      W = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,\n      D = [],\n      E = [],\n      V = 0,\n      A = !1,\n      H = !1,\n      B = [];t(k.prototype, { setState: function setState(e, n) {\n      this.__s || (this.__s = this.state), this.state = t(t({}, this.state), \"function\" == typeof e ? e(this.state, this.props) : e), n && this.__h.push(n), o(this);\n    }, forceUpdate: function forceUpdate(e) {\n      e && this.__h.push(e), C(this, 2);\n    }, render: function render() {} });var F = { h: e, createElement: e, cloneElement: n, Component: k, render: U, rerender: r, options: L }; true ? module.exports = F : self.preact = F;\n}();\n//# sourceMappingURL=preact.min.js.map\n\n/***/ }),\n\n/***/ \"LFiD\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(\"lcwS\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \"body,html{font:14px/1.21 Helvetica Neue,arial,sans-serif;font-weight:400}*,:after,:before{-webkit-box-sizing:border-box;box-sizing:border-box}body,html{height:100%}body{background:linear-gradient(135deg,#044f48,#2a7561);background-size:cover;font-family:Open Sans,sans-serif;font-size:12px;line-height:1.3;overflow:hidden}.bg__Lbpa2{width:100%;height:100%;top:0;left:0;z-index:1;background:url(\\\"https://images.unsplash.com/photo-1451186859696-371d9477be93?crop=entropy&fit=crop&fm=jpg&h=975&ixjsv=2.1.0&ixlib=rb-0.3.5&q=80&w=1925\\\") no-repeat 0 0;-webkit-filter:blur(80px);filter:blur(80px);-webkit-transform:scale(1.2);-ms-transform:scale(1.2);transform:scale(1.2)}.chat__2jjNN{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);width:300px;height:80vh;max-height:500px;z-index:2;overflow:hidden;-webkit-box-shadow:0 5px 30px rgba(0,0,0,.2);box-shadow:0 5px 30px rgba(0,0,0,.2);background:rgba(0,0,0,.5);border-radius:20px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.chat_title__2Two8{-webkit-box-flex:0;-ms-flex:0 1 45px;flex:0 1 45px;position:relative;z-index:2;background:rgba(0,0,0,.2);color:#fff;text-transform:uppercase;text-align:left;padding:10px 10px 10px 50px}.chat_title__2Two8 h1,.chat_title__2Two8 h2{font-weight:400;font-size:10px;margin:0;padding:0}.chat_title__2Two8 h2{color:hsla(0,0%,100%,.5);font-size:8px;letter-spacing:1px}.chat_title__2Two8 .avatar__1kVZr{position:absolute;z-index:1;top:8px;left:9px;border-radius:30px;width:30px;height:30px;overflow:hidden;margin:0;padding:0;border:2px solid hsla(0,0%,100%,.24)}.chat_title__2Two8 .avatar__1kVZr img{width:100%;height:auto}.messages__1Smla{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;color:hsla(0,0%,100%,.5);overflow:hidden;position:relative;width:100%}.messages__1Smla .messages_content__3WVlQ{position:absolute;top:0;left:0;padding:1em;height:101%;width:100%;overflow-x:hidden;overflow-y:auto}.messages__1Smla .messages_content__3WVlQ::-webkit-scrollbar-thumb{background-color:#08221d;background-image:none}.messages__1Smla .messages_content__3WVlQ::-webkit-scrollbar{width:5px;height:1px;z-index:10;-webkit-transition:all .5s;transition:all .5s}.messages__1Smla .messages_content__3WVlQ::-webkit-scrollbar-track{background:transparent}.messages__1Smla .message__2LwDs{clear:both;float:left;padding:6px 10px 7px;border-radius:10px 10px 10px 0;background:rgba(0,0,0,.3);margin:8px 0;font-size:11px;line-height:1.4;margin-left:35px;position:relative;text-shadow:0 1px 1px rgba(0,0,0,.2)}.messages__1Smla .message__2LwDs .timestamp__1qXhv{position:absolute;bottom:-15px;font-size:9px;color:hsla(0,0%,100%,.3)}.messages__1Smla .message__2LwDs:before{content:\\\"\\\";position:absolute;bottom:-6px;border-top:6px solid rgba(0,0,0,.3);left:0;border-right:7px solid transparent}.messages__1Smla .message__2LwDs .avatar__1kVZr{position:absolute;z-index:1;bottom:-15px;left:-35px;border-radius:30px;width:30px;height:30px;overflow:hidden;margin:0;padding:0;border:2px solid hsla(0,0%,100%,.24)}.messages__1Smla .message__2LwDs .avatar__1kVZr img{width:100%;height:auto}.messages__1Smla .message__2LwDs.message_personal__1oyIu{float:right;color:#fff;text-align:right;background:linear-gradient(120deg,#248a52,#257287);border-radius:10px 10px 0 10px}.messages__1Smla .message__2LwDs.message_personal__1oyIu:before{left:auto;right:0;border-right:none;border-left:5px solid transparent;border-top:4px solid #257287;bottom:-4px}.messages__1Smla .message__2LwDs:last-child{margin-bottom:30px}.messages__1Smla .message__2LwDs.new__3ShF9{-webkit-transform:scale(0);-ms-transform:scale(0);transform:scale(0);-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0;-webkit-animation:bounce__JRajZ .5s linear both;animation:bounce__JRajZ .5s linear both}.messages__1Smla .message__2LwDs.loading__YMEmP:before{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);content:\\\"\\\";display:block;width:3px;height:3px;border-radius:50%;background:hsla(0,0%,100%,.5);z-index:2;margin-top:4px;-webkit-animation:ball__1AQxl .45s cubic-bezier(0,0,.15,1) alternate infinite;animation:ball__1AQxl .45s cubic-bezier(0,0,.15,1) alternate infinite;border:none;-webkit-animation-delay:.15s;animation-delay:.15s}.messages__1Smla .message__2LwDs.loading__YMEmP span{display:block;font-size:0;width:20px;height:10px;position:relative}.messages__1Smla .message__2LwDs.loading__YMEmP span:before{margin-left:-7px}.messages__1Smla .message__2LwDs.loading__YMEmP span:after,.messages__1Smla .message__2LwDs.loading__YMEmP span:before{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);content:\\\"\\\";display:block;width:3px;height:3px;border-radius:50%;background:hsla(0,0%,100%,.5);z-index:2;margin-top:4px;-webkit-animation:ball__1AQxl .45s cubic-bezier(0,0,.15,1) alternate infinite;animation:ball__1AQxl .45s cubic-bezier(0,0,.15,1) alternate infinite}.messages__1Smla .message__2LwDs.loading__YMEmP span:after{margin-left:7px;-webkit-animation-delay:.3s;animation-delay:.3s}.message_box__u0ndM{-webkit-box-flex:0;-ms-flex:0 1 40px;flex:0 1 40px;width:100%;background:rgba(0,0,0,.3);padding:10px;position:relative}.message_box__u0ndM .message_input__2Jrco{background:none;border:none;outline:none!important;resize:none;color:hsla(0,0%,100%,.7);font-size:11px;height:40px;margin:0;padding-right:20px;width:265px}.message_box__u0ndM textarea:focus:-webkit-placeholder{color:transparent}.message_box__u0ndM .message_submit__1ZiW2{position:absolute;z-index:1;top:9px;right:10px;color:#fff;border:none;background:#248a52;font-size:10px;text-transform:uppercase;line-height:1;padding:6px 10px;border-radius:10px;outline:none!important;-webkit-transition:background .2s ease;transition:background .2s ease}.message_box__u0ndM .message_submit__1ZiW2:hover{background:#1d7745}.mCSB_scrollTools__35sBe{margin:1px -3px 1px 0;opacity:0}.mCSB_inside__2EgcE>.mCSB_container__tzOAO{margin-right:0;padding:0 10px}.mCSB_scrollTools__35sBe .mCSB_dragger__3za9I .mCSB_dragger_bar__4GZu9{background-color:rgba(0,0,0,.5)!important}@-webkit-keyframes bounce__JRajZ{0%{-webkit-transform:matrix(0,0,0,0,0,0);transform:matrix(0,0,0,0,0,0)}4.7%{-webkit-transform:matrix(.45,0,0,.45,0,0);transform:matrix(.45,0,0,.45,0,0)}9.41%{-webkit-transform:matrix(.883,0,0,.883,0,0);transform:matrix(.883,0,0,.883,0,0)}14.11%{-webkit-transform:matrix(1.141,0,0,1.141,0,0);transform:matrix(1.141,0,0,1.141,0,0)}18.72%{-webkit-transform:matrix(1.212,0,0,1.212,0,0);transform:matrix(1.212,0,0,1.212,0,0)}24.32%{-webkit-transform:matrix(1.151,0,0,1.151,0,0);transform:matrix(1.151,0,0,1.151,0,0)}29.93%{-webkit-transform:matrix(1.048,0,0,1.048,0,0);transform:matrix(1.048,0,0,1.048,0,0)}35.54%{-webkit-transform:matrix(.979,0,0,.979,0,0);transform:matrix(.979,0,0,.979,0,0)}41.04%{-webkit-transform:matrix(.961,0,0,.961,0,0);transform:matrix(.961,0,0,.961,0,0)}52.15%{-webkit-transform:matrix(.991,0,0,.991,0,0);transform:matrix(.991,0,0,.991,0,0)}63.26%{-webkit-transform:matrix(1.007,0,0,1.007,0,0);transform:matrix(1.007,0,0,1.007,0,0)}85.49%{-webkit-transform:matrix(.999,0,0,.999,0,0);transform:matrix(.999,0,0,.999,0,0)}to{-webkit-transform:matrix(1,0,0,1,0,0);transform:matrix(1,0,0,1,0,0)}}@keyframes bounce__JRajZ{0%{-webkit-transform:matrix(0,0,0,0,0,0);transform:matrix(0,0,0,0,0,0)}4.7%{-webkit-transform:matrix(.45,0,0,.45,0,0);transform:matrix(.45,0,0,.45,0,0)}9.41%{-webkit-transform:matrix(.883,0,0,.883,0,0);transform:matrix(.883,0,0,.883,0,0)}14.11%{-webkit-transform:matrix(1.141,0,0,1.141,0,0);transform:matrix(1.141,0,0,1.141,0,0)}18.72%{-webkit-transform:matrix(1.212,0,0,1.212,0,0);transform:matrix(1.212,0,0,1.212,0,0)}24.32%{-webkit-transform:matrix(1.151,0,0,1.151,0,0);transform:matrix(1.151,0,0,1.151,0,0)}29.93%{-webkit-transform:matrix(1.048,0,0,1.048,0,0);transform:matrix(1.048,0,0,1.048,0,0)}35.54%{-webkit-transform:matrix(.979,0,0,.979,0,0);transform:matrix(.979,0,0,.979,0,0)}41.04%{-webkit-transform:matrix(.961,0,0,.961,0,0);transform:matrix(.961,0,0,.961,0,0)}52.15%{-webkit-transform:matrix(.991,0,0,.991,0,0);transform:matrix(.991,0,0,.991,0,0)}63.26%{-webkit-transform:matrix(1.007,0,0,1.007,0,0);transform:matrix(1.007,0,0,1.007,0,0)}85.49%{-webkit-transform:matrix(.999,0,0,.999,0,0);transform:matrix(.999,0,0,.999,0,0)}to{-webkit-transform:matrix(1,0,0,1,0,0);transform:matrix(1,0,0,1,0,0)}}@-webkit-keyframes ball__1AQxl{0%{-webkit-transform:translateY(0) scaleY(.8);transform:translateY(0) scaleY(.8)}to{-webkit-transform:translateY(-10px);transform:translateY(-10px)}}@keyframes ball__1AQxl{0%{-webkit-transform:translateY(0) scaleY(.8);transform:translateY(0) scaleY(.8)}to{-webkit-transform:translateY(-10px);transform:translateY(-10px)}}\", \"\", {\"version\":3,\"sources\":[\"/app/src/components/chatbox/style.scss\"],\"names\":[],\"mappings\":\"AAAA,UACC,+CACA,eAAgB,CAChB,iBAgCC,8BAAA,qBAAsB,CACvB,UAIC,WAAY,CACb,KAGC,mDACA,sBACA,iCACA,eACA,gBACA,eAAgB,CACjB,WAGC,WACA,YACA,MACA,OACA,UACA,uKACA,0BAAA,kBACA,6BAAA,yBAAA,oBAAqB,CACtB,aApDC,kBACA,QACA,SACA,uCAAA,mCAAA,+BAyDA,YACA,YACA,iBACA,UACA,gBACA,6CAAA,qCACA,0BACA,mBACA,oBAAA,oBAAA,aACA,yBAAA,sBAAA,8BACA,4BAAA,6BAAA,0BAAA,qBAAsB,CACvB,mBAOC,mBAAA,kBAAA,cACA,kBACA,UACA,0BACA,WACA,yBACA,gBACA,2BAA4B,CAR9B,4CAWI,gBACA,eACA,SACA,SAAU,CAdd,sBAkBI,yBACA,cACA,kBAAmB,CApBvB,kCAwBI,kBACA,UACA,QACA,SACA,mBACA,WACA,YACA,gBACA,SACA,UACA,oCAA2C,CAlC/C,sCAqCM,WACA,WAAY,CACb,iBASH,mBAAA,kBAAA,cACA,yBACA,gBACA,kBACA,UAAW,CALb,0CAQI,kBACA,MACA,OACF,YACE,YACA,WACF,kBACE,eAAgB,CAfpB,mEAiBK,yBACA,qBAAsB,CAlB3B,6DAqBM,UACA,WACA,WACA,2BAAA,kBAAmB,CAxBzB,mEA2BM,sBAAuB,CA3B7B,iCAiCI,WACA,WACA,qBACA,+BACA,0BACA,aACA,eACA,gBACA,iBACA,kBACA,oCAAwC,CA3C5C,mDA8CM,kBACA,aACA,cACA,wBAA8B,CAjDpC,wCAqDM,WACA,kBACA,YACA,oCACA,OACA,kCAAmC,CA1DzC,gDA8DM,kBACA,UACA,aACA,WACA,mBACA,WACA,YACA,gBACA,SACA,UACA,oCAA2C,CAxEjD,oDA2EQ,WACA,WAAY,CA5EpB,yDAiFM,YACA,WACA,iBACA,mDACA,8BAA+B,CArFrC,gEAwFQ,UACA,QACA,kBACA,kCACA,6BACA,WAAY,CA7FpB,4CAkGM,kBAAmB,CAlGzB,4CAsGM,2BAAA,uBAAA,mBACA,6BAAA,yBAAA,qBACA,gDAAA,uCAAmC,CAxGzC,uDA5HE,kBACA,QACA,SACA,uCAAA,mCAAA,+BAKA,WACA,cACA,UACA,WACA,kBACA,8BACA,UACA,eACA,8EAAA,sEA2NM,YACA,6BAAA,oBAAqB,CAhH7B,qDAoHQ,cACA,YACA,WACA,YACA,iBAAkB,CAxH1B,4DA4HU,gBAAiB,CA5H3B,uHA5HE,kBACA,QACA,SACA,uCAAA,mCAAA,+BAKA,WACA,cACA,UACA,WACA,kBACA,8BACA,UACA,eACA,8EAAA,qEAwOQ,CAOD,AAnIT,2DAiIU,gBACA,4BAAA,mBAAoB,CACrB,oBAYP,mBAAA,kBAAA,cACA,WACA,0BACA,aACA,iBAAkB,CALpB,0CAQI,gBACA,YACA,uBACA,YACA,yBACA,eACA,YACA,SACA,mBACA,WAAY,CAjBhB,uDAqBM,iBAAkB,CArBxB,2CAyBI,kBACA,UACA,QACA,WACA,WACA,YACA,mBACA,eACA,yBACA,cACA,iBACA,mBACA,uBACA,uCAAA,8BAA+B,CAtCnC,iDAyCM,kBAAmB,CACpB,yBASH,sBACA,SAAU,CACX,2CAGC,eACA,cAAe,CAChB,uEAGC,yCAA8C,CAC/C,iCAOC,GAAK,sCAAA,6BAAmE,CACxE,KAAO,0CAAA,iCAAyE,CAChF,MAAQ,4CAAA,mCAA2E,CACnF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,GAAO,sCAAA,6BAAmE,CAAA,CAnB3E,yBAOC,GAAK,sCAAA,6BAAmE,CACxE,KAAO,0CAAA,iCAAyE,CAChF,MAAQ,4CAAA,mCAA2E,CACnF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,GAAO,sCAAA,6BAAmE,CAAA,CAI5E,+BACE,GACE,2CAAA,kCAAmC,CAErC,GACE,oCAAA,2BAA4B,CAAA,CALhC,uBACE,GACE,2CAAA,kCAAmC,CAErC,GACE,oCAAA,2BAA4B,CAAA,CAAA\",\"file\":\"style.scss\",\"sourcesContent\":[\"html, body {\\n\\tfont: 14px/1.21 'Helvetica Neue', arial, sans-serif;\\n\\tfont-weight: 400;\\n}\\n\\n/*--------------------\\nMixins\\n--------------------*/\\n@mixin center {\\n  position: absolute;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n}\\n\\n@mixin ball {\\n  @include center;\\n  content: '';\\n  display: block;\\n  width: 3px;\\n  height: 3px;\\n  border-radius: 50%;\\n  background: rgba(255, 255, 255, .5);\\n  z-index: 2;\\n  margin-top: 4px;\\n  animation: ball .45s cubic-bezier(0, 0, 0.15, 1) alternate infinite;\\n}\\n\\n\\n/*--------------------\\nBody\\n--------------------*/\\n*,\\n*::before,\\n*::after {\\n  box-sizing: border-box;\\n}\\n\\nhtml,\\nbody {\\n  height: 100%;\\n}\\n\\nbody {\\n  background: linear-gradient(135deg, #044f48, #2a7561);\\n  background-size: cover;\\n  font-family: 'Open Sans', sans-serif;\\n  font-size: 12px;\\n  line-height: 1.3;\\n  overflow: hidden;\\n}\\n\\n.bg {\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  z-index: 1;\\n  background: url('https://images.unsplash.com/photo-1451186859696-371d9477be93?crop=entropy&fit=crop&fm=jpg&h=975&ixjsv=2.1.0&ixlib=rb-0.3.5&q=80&w=1925') no-repeat 0 0;\\n  filter: blur(80px);\\n  transform: scale(1.2);\\n}\\n\\n\\n/*--------------------\\nChat\\n--------------------*/\\n.chat {\\n  @include center;\\n  width: 300px;\\n  height: 80vh;\\n  max-height: 500px;\\n  z-index: 2;\\n  overflow: hidden;\\n  box-shadow: 0 5px 30px rgba(0, 0, 0, .2);\\n  background: rgba(0, 0, 0, .5);\\n  border-radius: 20px;\\n  display: flex;\\n  justify-content: space-between;\\n  flex-direction: column;\\n}\\n\\n\\n/*--------------------\\nChat Title\\n--------------------*/\\n.chat_title {\\n  flex: 0 1 45px;\\n  position: relative;\\n  z-index: 2;\\n  background: rgba(0, 0, 0, 0.2);\\n  color: #fff;\\n  text-transform: uppercase;\\n  text-align: left;\\n  padding: 10px 10px 10px 50px;\\n\\n  h1, h2 {\\n    font-weight: normal;\\n    font-size: 10px;\\n    margin: 0;\\n    padding: 0;\\n  }\\n\\n  h2 {\\n    color: rgba(255, 255, 255, .5);\\n    font-size: 8px;\\n    letter-spacing: 1px;\\n  }\\n\\n  .avatar {\\n    position: absolute;\\n    z-index: 1;\\n    top: 8px;\\n    left: 9px;\\n    border-radius: 30px;\\n    width: 30px;\\n    height: 30px;\\n    overflow: hidden;\\n    margin: 0;\\n    padding: 0;\\n    border: 2px solid rgba(255, 255, 255, 0.24);\\n\\n    img {\\n      width: 100%;\\n      height: auto;\\n    }\\n  }\\n}\\n\\n\\n/*--------------------\\nMessages\\n--------------------*/\\n.messages {\\n  flex: 1 1 auto;\\n  color: rgba(255, 255, 255, .5);\\n  overflow: hidden;\\n  position: relative;\\n  width: 100%;\\n\\n  & .messages_content {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n\\t\\tpadding: 1em;\\n    height: 101%;\\n    width: 100%;\\n\\t\\toverflow-x: hidden;\\n    overflow-y: auto;\\n\\t\\t&::-webkit-scrollbar-thumb {\\n    \\tbackground-color: #08221D;\\n    \\tbackground-image: none;\\n\\t\\t}\\n    &::-webkit-scrollbar{\\n      width: 5px;\\n      height: 1px;\\n      z-index: 10;\\n      transition: all .5s;\\n\\t\\t}\\n    &::-webkit-scrollbar-track {\\n      background: transparent;\\n\\t\\t}\\n  }\\n\\n\\n  .message {\\n    clear: both;\\n    float: left;\\n    padding: 6px 10px 7px;\\n    border-radius: 10px 10px 10px 0;\\n    background: rgba(0, 0, 0, .3);\\n    margin: 8px 0;\\n    font-size: 11px;\\n    line-height: 1.4;\\n    margin-left: 35px;\\n    position: relative;\\n    text-shadow: 0 1px 1px rgba(0, 0, 0, .2);\\n\\n    .timestamp {\\n      position: absolute;\\n      bottom: -15px;\\n      font-size: 9px;\\n      color: rgba(255, 255, 255, .3);\\n    }\\n\\n    &::before {\\n      content: '';\\n      position: absolute;\\n      bottom: -6px;\\n      border-top: 6px solid rgba(0, 0, 0, .3);\\n      left: 0;\\n      border-right: 7px solid transparent;\\n    }\\n\\n    .avatar {\\n      position: absolute;\\n      z-index: 1;\\n      bottom: -15px;\\n      left: -35px;\\n      border-radius: 30px;\\n      width: 30px;\\n      height: 30px;\\n      overflow: hidden;\\n      margin: 0;\\n      padding: 0;\\n      border: 2px solid rgba(255, 255, 255, 0.24);\\n\\n      img {\\n        width: 100%;\\n        height: auto;\\n      }\\n    }\\n\\n    &.message_personal {\\n      float: right;\\n      color: #fff;\\n      text-align: right;\\n      background: linear-gradient(120deg, #248A52, #257287);\\n      border-radius: 10px 10px 0 10px;\\n\\n      &::before {\\n        left: auto;\\n        right: 0;\\n        border-right: none;\\n        border-left: 5px solid transparent;\\n        border-top: 4px solid #257287;\\n        bottom: -4px;\\n      }\\n    }\\n\\n    &:last-child {\\n      margin-bottom: 30px;\\n    }\\n\\n    &.new {\\n      transform: scale(0);\\n      transform-origin: 0 0;\\n      animation: bounce 500ms linear both;\\n    }\\n\\n    &.loading {\\n\\n      &::before {\\n        @include ball;\\n        border: none;\\n        animation-delay: .15s;\\n      }\\n\\n      & span {\\n        display: block;\\n        font-size: 0;\\n        width: 20px;\\n        height: 10px;\\n        position: relative;\\n\\n        &::before {\\n          @include ball;\\n          margin-left: -7px;\\n        }\\n\\n        &::after {\\n          @include ball;\\n          margin-left: 7px;\\n          animation-delay: .3s;\\n        }\\n      }\\n    }\\n\\n  }\\n}\\n\\n\\n/*--------------------\\nMessage Box\\n--------------------*/\\n.message_box {\\n  flex: 0 1 40px;\\n  width: 100%;\\n  background: rgba(0, 0, 0, 0.3);\\n  padding: 10px;\\n  position: relative;\\n\\n  & .message_input {\\n    background: none;\\n    border: none;\\n    outline: none!important;\\n    resize: none;\\n    color: rgba(255, 255, 255, .7);\\n    font-size: 11px;\\n    height: 40px;\\n    margin: 0;\\n    padding-right: 20px;\\n    width: 265px;\\n  }\\n\\n  textarea:focus:-webkit-placeholder{\\n      color: transparent;\\n  }\\n\\n  & .message_submit {\\n    position: absolute;\\n    z-index: 1;\\n    top: 9px;\\n    right: 10px;\\n    color: #fff;\\n    border: none;\\n    background: #248A52;\\n    font-size: 10px;\\n    text-transform: uppercase;\\n    line-height: 1;\\n    padding: 6px 10px;\\n    border-radius: 10px;\\n    outline: none!important;\\n    transition: background .2s ease;\\n\\n    &:hover {\\n      background: #1D7745;\\n    }\\n  }\\n}\\n\\n\\n/*--------------------\\nCustom Srollbar\\n--------------------*/\\n.mCSB_scrollTools {\\n  margin: 1px -3px 1px 0;\\n  opacity: 0;\\n}\\n\\n.mCSB_inside > .mCSB_container {\\n  margin-right: 0px;\\n  padding: 0 10px;\\n}\\n\\n.mCSB_scrollTools .mCSB_dragger .mCSB_dragger_bar {\\n  background-color: rgba(0, 0, 0, 0.5)!important;\\n}\\n\\n\\n/*--------------------\\nBounce\\n--------------------*/\\n@keyframes bounce {\\n  0% { transform: matrix3d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  4.7% { transform: matrix3d(0.45, 0, 0, 0, 0, 0.45, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  9.41% { transform: matrix3d(0.883, 0, 0, 0, 0, 0.883, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  14.11% { transform: matrix3d(1.141, 0, 0, 0, 0, 1.141, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  18.72% { transform: matrix3d(1.212, 0, 0, 0, 0, 1.212, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  24.32% { transform: matrix3d(1.151, 0, 0, 0, 0, 1.151, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  29.93% { transform: matrix3d(1.048, 0, 0, 0, 0, 1.048, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  35.54% { transform: matrix3d(0.979, 0, 0, 0, 0, 0.979, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  41.04% { transform: matrix3d(0.961, 0, 0, 0, 0, 0.961, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  52.15% { transform: matrix3d(0.991, 0, 0, 0, 0, 0.991, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  63.26% { transform: matrix3d(1.007, 0, 0, 0, 0, 1.007, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  85.49% { transform: matrix3d(0.999, 0, 0, 0, 0, 0.999, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  100% { transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n}\\n\\n\\n@keyframes ball {\\n  from {\\n    transform: translateY(0) scaleY(.8);\\n  }\\n  to {\\n    transform: translateY(-10px);\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\nexports.locals = {\n\t\"bg\": \"bg__Lbpa2\",\n\t\"chat\": \"chat__2jjNN\",\n\t\"chat_title\": \"chat_title__2Two8\",\n\t\"avatar\": \"avatar__1kVZr\",\n\t\"messages\": \"messages__1Smla\",\n\t\"messages_content\": \"messages_content__3WVlQ\",\n\t\"message\": \"message__2LwDs\",\n\t\"timestamp\": \"timestamp__1qXhv\",\n\t\"message_personal\": \"message_personal__1oyIu\",\n\t\"new\": \"new__3ShF9\",\n\t\"bounce\": \"bounce__JRajZ\",\n\t\"loading\": \"loading__YMEmP\",\n\t\"ball\": \"ball__1AQxl\",\n\t\"message_box\": \"message_box__u0ndM\",\n\t\"message_input\": \"message_input__2Jrco\",\n\t\"message_submit\": \"message_submit__1ZiW2\",\n\t\"mCSB_scrollTools\": \"mCSB_scrollTools__35sBe\",\n\t\"mCSB_inside\": \"mCSB_inside__2EgcE\",\n\t\"mCSB_container\": \"mCSB_container__tzOAO\",\n\t\"mCSB_dragger\": \"mCSB_dragger__3za9I\",\n\t\"mCSB_dragger_bar\": \"mCSB_dragger_bar__4GZu9\"\n};\n\n/***/ }),\n\n/***/ \"QAmr\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\nvar index = typeof fetch == 'function' ? fetch.bind() : function (url, options) {\n\toptions = options || {};\n\treturn new Promise(function (resolve, reject) {\n\t\tvar request = new XMLHttpRequest();\n\n\t\trequest.open(options.method || 'get', url, true);\n\n\t\tfor (var i in options.headers) {\n\t\t\trequest.setRequestHeader(i, options.headers[i]);\n\t\t}\n\n\t\trequest.withCredentials = options.credentials == 'include';\n\n\t\trequest.onload = function () {\n\t\t\tresolve(response());\n\t\t};\n\n\t\trequest.onerror = reject;\n\n\t\trequest.send(options.body);\n\n\t\tfunction response() {\n\t\t\tvar _keys = [],\n\t\t\t    all = [],\n\t\t\t    headers = {},\n\t\t\t    header;\n\n\t\t\trequest.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, function (m, key, value) {\n\t\t\t\t_keys.push(key = key.toLowerCase());\n\t\t\t\tall.push([key, value]);\n\t\t\t\theader = headers[key];\n\t\t\t\theaders[key] = header ? header + \",\" + value : value;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tok: (request.status / 100 | 0) == 2, // 200-299\n\t\t\t\tstatus: request.status,\n\t\t\t\tstatusText: request.statusText,\n\t\t\t\turl: request.responseURL,\n\t\t\t\tclone: response,\n\t\t\t\ttext: function text() {\n\t\t\t\t\treturn Promise.resolve(request.responseText);\n\t\t\t\t},\n\t\t\t\tjson: function json() {\n\t\t\t\t\treturn Promise.resolve(request.responseText).then(JSON.parse);\n\t\t\t\t},\n\t\t\t\tblob: function blob() {\n\t\t\t\t\treturn Promise.resolve(new Blob([request.response]));\n\t\t\t\t},\n\t\t\t\theaders: {\n\t\t\t\t\tkeys: function keys() {\n\t\t\t\t\t\treturn _keys;\n\t\t\t\t\t},\n\t\t\t\t\tentries: function entries() {\n\t\t\t\t\t\treturn all;\n\t\t\t\t\t},\n\t\t\t\t\tget: function get(n) {\n\t\t\t\t\t\treturn headers[n.toLowerCase()];\n\t\t\t\t\t},\n\t\t\t\t\thas: function has(n) {\n\t\t\t\t\t\treturn n.toLowerCase() in headers;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceMappingURL=unfetch.es.js.map\n\n/***/ }),\n\n/***/ \"VS7n\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = window.fetch || (window.fetch = __webpack_require__(\"QAmr\").default || __webpack_require__(\"QAmr\"));\n\n/***/ }),\n\n/***/ \"XLyV\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n * Copyright 2015 Netflix, Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\n(function (f) {\n    if (true) {\n        module.exports = f();\n    } else if (typeof define === \"function\" && define.amd) {\n        define([], f);\n    } else {\n        var g;if (typeof window !== \"undefined\") {\n            g = window;\n        } else if (typeof global !== \"undefined\") {\n            g = global;\n        } else if (typeof self !== \"undefined\") {\n            g = self;\n        } else {\n            g = this;\n        }g.falcor = f();\n    }\n})(function () {\n    var define, module, exports;return function () {\n        function r(e, n, t) {\n            function o(i, f) {\n                if (!n[i]) {\n                    if (!e[i]) {\n                        var c = \"function\" == typeof require && require;if (!f && c) return require(i, !0);if (u) return u(i, !0);var a = new Error(\"Cannot find module '\" + i + \"'\");throw a.code = \"MODULE_NOT_FOUND\", a;\n                    }var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {\n                        var n = e[i][1][r];return o(n || r);\n                    }, p, p.exports, r, e, n, t);\n                }return n[i].exports;\n            }for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {\n                o(t[i]);\n            }return o;\n        }return r;\n    }()({ 1: [function (require, module, exports) {\n            var falcor = require(34);\n            var jsong = require(130);\n\n            falcor.atom = jsong.atom;\n            falcor.ref = jsong.ref;\n            falcor.error = jsong.error;\n            falcor.pathValue = jsong.pathValue;\n\n            falcor.HttpDataSource = require(125);\n\n            module.exports = falcor;\n        }, { \"125\": 125, \"130\": 130, \"34\": 34 }], 2: [function (require, module, exports) {\n            var ModelRoot = require(4);\n            var ModelDataSourceAdapter = require(3);\n\n            var RequestQueue = require(44);\n            var ModelResponse = require(52);\n            var CallResponse = require(50);\n            var InvalidateResponse = require(51);\n\n            var ASAPScheduler = require(67);\n            var TimeoutScheduler = require(69);\n            var ImmediateScheduler = require(68);\n\n            var arrayClone = require(75);\n            var arraySlice = require(79);\n\n            var collectLru = require(40);\n            var pathSyntax = require(134);\n\n            var getSize = require(85);\n            var isObject = require(97);\n            var isPrimitive = require(99);\n            var isJSONEnvelope = require(95);\n            var isJSONGraphEnvelope = require(96);\n\n            var setCache = require(71);\n            var setJSONGraphs = require(70);\n            var jsong = require(130);\n            var ID = 0;\n            var validateInput = require(113);\n            var noOp = function noOp() {};\n            var getCache = require(18);\n            var get = require(23);\n            var GET_VALID_INPUT = require(59);\n\n            module.exports = Model;\n\n            Model.ref = jsong.ref;\n            Model.atom = jsong.atom;\n            Model.error = jsong.error;\n            Model.pathValue = jsong.pathValue;\n            /**\n             * This callback is invoked when the Model's cache is changed.\n             * @callback Model~onChange\n             */\n\n            /**\n            * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n            * @callback Model~errorSelector\n            * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n            * @returns {Object} the JSONGraph Error object to store in the Model cache.\n            */\n\n            /**\n            * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n            * @callback Model~comparator\n            * @param {Object} existingValue - the current value in the Model cache.\n            * @param {Object} newValue - the value about to be set into the Model cache.\n            * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n            */\n\n            /**\n             * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n             * @constructor\n             * @param {?Object} options - a set of options to customize behavior\n             * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n             * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n             * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n             * @param {?number} options.maxRetries - the maximum number of times that the Model will attempt to retrieve the value from the server.\n             * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n             * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n             * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n             * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n             */\n            function Model(o) {\n\n                var options = o || {};\n                this._root = options._root || new ModelRoot(options);\n                this._path = options.path || options._path || [];\n                this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n                this._source = options.source || options._source;\n                this._request = options.request || options._request || new RequestQueue(this, this._scheduler);\n                this._ID = ID++;\n\n                if (typeof options.maxSize === \"number\") {\n                    this._maxSize = options.maxSize;\n                } else {\n                    this._maxSize = options._maxSize || Model.prototype._maxSize;\n                }\n\n                if (typeof options.maxRetries === \"number\") {\n                    this._maxRetries = options.maxRetries;\n                } else {\n                    this._maxRetries = options._maxRetries || Model.prototype._maxRetries;\n                }\n\n                if (typeof options.collectRatio === \"number\") {\n                    this._collectRatio = options.collectRatio;\n                } else {\n                    this._collectRatio = options._collectRatio || Model.prototype._collectRatio;\n                }\n\n                if (options.boxed || options.hasOwnProperty(\"_boxed\")) {\n                    this._boxed = options.boxed || options._boxed;\n                }\n\n                if (options.materialized || options.hasOwnProperty(\"_materialized\")) {\n                    this._materialized = options.materialized || options._materialized;\n                }\n\n                if (typeof options.treatErrorsAsValues === \"boolean\") {\n                    this._treatErrorsAsValues = options.treatErrorsAsValues;\n                } else if (options.hasOwnProperty(\"_treatErrorsAsValues\")) {\n                    this._treatErrorsAsValues = options._treatErrorsAsValues;\n                }\n\n                this._useServerPaths = options._useServerPaths || false;\n\n                this._allowFromWhenceYouCame = options.allowFromWhenceYouCame || options._allowFromWhenceYouCame || false;\n\n                this._treatDataSourceErrorsAsJSONGraphErrors = options._treatDataSourceErrorsAsJSONGraphErrors || false;\n\n                if (options.cache) {\n                    this.setCache(options.cache);\n                }\n            }\n\n            Model.prototype.constructor = Model;\n\n            Model.prototype._materialized = false;\n            Model.prototype._boxed = false;\n            Model.prototype._progressive = false;\n            Model.prototype._treatErrorsAsValues = false;\n            Model.prototype._maxSize = Math.pow(2, 53) - 1;\n            Model.prototype._maxRetries = 3;\n            Model.prototype._collectRatio = 0.75;\n\n            /**\n             * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n             * @function\n             * @param {...PathSet} path - the path(s) to retrieve\n             * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n             */\n            Model.prototype.get = require(58);\n\n            /**\n             * _getOptimizedBoundPath is an extension point for internal users to polyfill\n             * legacy soft-bind behavior, as opposed to deref (hardBind). Current falcor\n             * only supports deref, and assumes _path to be a fully optimized path.\n             * @function\n             * @private\n             * @return {Path} - fully optimized bound path for the model\n             */\n            Model.prototype._getOptimizedBoundPath = function _getOptimizedBoundPath() {\n                return arrayClone(this._path);\n            };\n\n            /**\n             * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n             * @function\n             * @private\n             * @param {Array.<PathSet>} paths - the path(s) to retrieve\n             * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n             */\n            Model.prototype._getWithPaths = require(57);\n\n            /**\n             * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n             * @function\n             * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n             */\n            Model.prototype.set = require(63);\n\n            /**\n             * Observes the value at provided paths, notifies for changes made at those paths in the local cache\n             * @function\n             * @return {ObserveResponse} - an {@link Observable} stream containing the paths which got updated\n             */\n            Model.prototype.observe = require(61);\n\n            /**\n             * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n             * @function\n             * @param {...PathSet} path - the path(s) to retrieve\n             * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n             */\n            Model.prototype.preload = function preload() {\n                var out = validateInput(arguments, GET_VALID_INPUT, \"preload\");\n                if (out !== true) {\n                    return new ModelResponse(function (o) {\n                        o.onError(out);\n                    });\n                }\n                var args = Array.prototype.slice.call(arguments);\n                var self = this;\n                return new ModelResponse(function (obs) {\n                    return self.get.apply(self, args).subscribe(function () {}, function (err) {\n                        obs.onError(err);\n                    }, function () {\n                        obs.onCompleted();\n                    });\n                });\n            };\n\n            /**\n             * Invokes a function in the JSON Graph.\n             * @function\n             * @param {Path} functionPath - the path to the function to invoke\n             * @param {Array.<Object>} args - the arguments to pass to the function\n             * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n             * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n             * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n             */\n            Model.prototype.call = function call() {\n                var args;\n                var argsIdx = -1;\n                var argsLen = arguments.length;\n                args = new Array(argsLen);\n                while (++argsIdx < argsLen) {\n                    var arg = arguments[argsIdx];\n                    args[argsIdx] = arg;\n                    var argType = typeof arg;\n                    if (argsIdx > 1 && !Array.isArray(arg) || argsIdx === 0 && !Array.isArray(arg) && argType !== \"string\" || argsIdx === 1 && !Array.isArray(arg) && !isPrimitive(arg)) {\n                        /* eslint-disable no-loop-func */\n                        return new ModelResponse(function (o) {\n                            o.onError(new Error(\"Invalid argument\"));\n                        });\n                        /* eslint-enable no-loop-func */\n                    }\n                }\n\n                return new CallResponse(this, args[0], args[1], args[2], args[3]);\n            };\n\n            /**\n             * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n             * @function\n             * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n             */\n            Model.prototype.invalidate = function invalidate() {\n                var args;\n                var argsIdx = -1;\n                var argsLen = arguments.length;\n                args = [];\n                while (++argsIdx < argsLen) {\n                    args[argsIdx] = pathSyntax.fromPath(arguments[argsIdx]);\n                    if (!Array.isArray(args[argsIdx]) || !args[argsIdx].length) {\n                        throw new Error(\"Invalid argument\");\n                    }\n                }\n\n                // creates the obs, subscribes and will throw the errors if encountered.\n                new InvalidateResponse(this, args).subscribe(noOp, function (e) {\n                    throw e;\n                });\n            };\n\n            /**\n             * Returns a new {@link Model} bound to a location within the {@link\n             * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n             * Reference}s encountered while resolving the bound {@link Path} are always\n             * replaced with the {@link Reference}s target value. For subsequent operations\n             * on the {@link Model}, all paths will be evaluated relative to the bound\n             * path. Deref allows you to:\n             * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n             *   the entire graph\n             * - Hide the location of a {@link JSONGraph} fragment from components\n             * - Optimize for executing multiple operations and path looksup at/below the\n             *   same location in the {@link JSONGraph}\n             * @method\n             * @param {Object} responseObject - an object previously retrieved from the\n             * Model\n             * @return {Model} - the dereferenced {@link Model}\n             * @example\n            var Model = falcor.Model;\n            var model = new Model({\n              cache: {\n                users: [\n                  Model.ref([\"usersById\", 32])\n                ],\n                usersById: {\n                  32: {\n                    name: \"Steve\",\n                    surname: \"McGuire\"\n                  }\n                }\n              }\n            });\n            \n            model.\n                get(['users', 0, 'name']).\n                subscribe(function(jsonEnv) {\n                    var userModel = model.deref(jsonEnv.json.users[0]);\n                    console.log(model.getPath());\n                    console.log(userModel.getPath());\n               });\n            });\n            \n            // prints the following:\n            // []\n            // [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n             */\n            Model.prototype.deref = require(6);\n\n            /**\n             * A dereferenced model can become invalid when the reference from which it was\n             * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n             * the parent request should be made (no parent, then from the root) for a valid\n             * path and re-dereference performed to update what the model is bound too.\n             *\n             * @method\n             * @private\n             * @return {Boolean} - If the currently deref'd model is still considered a\n             * valid deref.\n             */\n            Model.prototype._hasValidParentReference = require(5);\n\n            /**\n             * Get data for a single {@link Path}.\n             * @param {Path} path - the path to retrieve\n             * @return {Observable.<*>} - the value for the path\n             * @example\n             var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n            \n             model.\n                 getValue('user.name').\n                 subscribe(function(name) {\n                     console.log(name);\n                 });\n            \n             // The code above prints \"Jim\" to the console.\n             */\n            Model.prototype.getValue = require(20);\n\n            /**\n             * Set value for a single {@link Path}.\n             * @param {Path} path - the path to set\n             * @param {Object} value - the value to set\n             * @return {Observable.<*>} - the value for the path\n             * @example\n             var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n            \n             model.\n                 setValue('user.name', 'Jim').\n                 subscribe(function(name) {\n                     console.log(name);\n                 });\n            \n             // The code above prints \"Jim\" to the console.\n             */\n            Model.prototype.setValue = require(73);\n\n            // TODO: Does not throw if given a PathSet rather than a Path, not sure if it should or not.\n            // TODO: Doc not accurate? I was able to invoke directly against the Model, perhaps because I don't have a data source?\n            // TODO: Not clear on what it means to \"retrieve objects in addition to JSONGraph values\"\n            /**\n             * Synchronously retrieves a single path from the local {@link Model} only and will not retrieve missing paths from the {@link DataSource}. This method can only be invoked when the {@link Model} does not have a {@link DataSource} or from within a selector function. See {@link Model.prototype.get}. The getValueSync method differs from the asynchronous get methods (ex. get, getValues) in that it can be used to retrieve objects in addition to JSONGraph values.\n             * @method\n             * @private\n             * @arg {Path} path - the path to retrieve\n             * @return {*} - the value for the specified path\n             */\n            Model.prototype._getValueSync = require(28);\n\n            /**\n             * @private\n             */\n            Model.prototype._setValueSync = require(74);\n\n            /**\n             * @private\n             */\n            Model.prototype._derefSync = require(7);\n\n            /**\n             * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n             * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n             */\n            Model.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n                var cache = this._root.cache;\n                if (cacheOrJSONGraphEnvelope !== cache) {\n                    var modelRoot = this._root;\n                    var boundPath = this._path;\n                    this._path = [];\n                    this._root.cache = {};\n                    if (typeof cache !== \"undefined\") {\n                        collectLru(modelRoot, modelRoot.expired, getSize(cache), 0);\n                    }\n                    var out;\n                    if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n                        out = setJSONGraphs(this, [cacheOrJSONGraphEnvelope])[0];\n                    } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n                        out = setCache(this, [cacheOrJSONGraphEnvelope])[0];\n                    } else if (isObject(cacheOrJSONGraphEnvelope)) {\n                        out = setCache(this, [{ json: cacheOrJSONGraphEnvelope }])[0];\n                    }\n\n                    // performs promotion without producing output.\n                    if (out) {\n                        get.getWithPathsAsPathMap(this, out, []);\n                    }\n                    this._path = boundPath;\n                } else if (typeof cache === \"undefined\") {\n                    this._root.cache = {};\n                }\n                return this;\n            };\n\n            /**\n             * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n             * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n             * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n             * @example\n             // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n             localStorage.setItem('cache', JSON.stringify(model.getCache(\"genreLists[0...10][0...10].boxshot\")));\n             */\n            Model.prototype.getCache = function _getCache() {\n                var paths = arraySlice(arguments);\n                if (paths.length === 0) {\n                    return getCache(this._root.cache);\n                }\n\n                var result = [{}];\n                var path = this._path;\n                get.getWithPathsAsJSONGraph(this, paths, result);\n                this._path = path;\n                return result[0].jsonGraph;\n            };\n\n            /**\n             * Reset cache maxSize. When the new maxSize is smaller than the old force a collect.\n             * @param {Number} maxSize - the new maximum cache size\n             */\n            Model.prototype._setMaxSize = function setMaxSize(maxSize) {\n                var oldMaxSize = this._maxSize;\n                this._maxSize = maxSize;\n                if (maxSize < oldMaxSize) {\n                    var modelRoot = this._root;\n                    var modelCache = modelRoot.cache;\n                    // eslint-disable-next-line no-cond-assign\n                    var currentVersion = modelCache.$_version;\n                    collectLru(modelRoot, modelRoot.expired, getSize(modelCache), this._maxSize, this._collectRatio, currentVersion);\n                }\n            };\n\n            /**\n             * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n             * @param {Path?} path - a path at which to retrieve the version number\n             * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n             */\n            Model.prototype.getVersion = function getVersion(pathArg) {\n                var path = pathArg && pathSyntax.fromPath(pathArg) || [];\n                if (Array.isArray(path) === false) {\n                    throw new Error(\"Model#getVersion must be called with an Array path.\");\n                }\n                if (this._path.length) {\n                    path = this._path.concat(path);\n                }\n                return this._getVersion(this, path);\n            };\n\n            Model.prototype._syncCheck = function syncCheck(name) {\n                if (Boolean(this._source) && this._root.syncRefCount <= 0 && this._root.unsafeMode === false) {\n                    throw new Error(\"Model#\" + name + \" may only be called within the context of a request selector.\");\n                }\n                return true;\n            };\n\n            /* eslint-disable guard-for-in */\n            Model.prototype._clone = function cloneModel(opts) {\n                var clone = new this.constructor(this);\n                for (var key in opts) {\n                    var value = opts[key];\n                    if (value === \"delete\") {\n                        delete clone[key];\n                    } else {\n                        clone[key] = value;\n                    }\n                }\n                clone.setCache = void 0;\n                return clone;\n            };\n            /* eslint-enable */\n\n            /**\n             * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n             * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n             * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n             */\n            Model.prototype.batch = function batch(schedulerOrDelayArg) {\n                var schedulerOrDelay = schedulerOrDelayArg;\n                if (typeof schedulerOrDelay === \"number\") {\n                    schedulerOrDelay = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n                } else if (!schedulerOrDelay || !schedulerOrDelay.schedule) {\n                    schedulerOrDelay = new ASAPScheduler();\n                }\n                var clone = this._clone();\n                clone._request = new RequestQueue(clone, schedulerOrDelay);\n\n                return clone;\n            };\n\n            /**\n             * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n             * @name unbatch\n             * @memberof Model.prototype\n             * @function\n             * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n             */\n            Model.prototype.unbatch = function unbatch() {\n                var clone = this._clone();\n                clone._request = new RequestQueue(clone, new ImmediateScheduler());\n                return clone;\n            };\n\n            /**\n             * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n             * @return {Model}\n             */\n            Model.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n                return this._clone({\n                    _treatErrorsAsValues: true\n                });\n            };\n\n            /**\n             * Adapts a Model to the {@link DataSource} interface.\n             * @return {DataSource}\n             * @example\n            var model =\n                new falcor.Model({\n                    cache: {\n                        user: {\n                            name: \"Steve\",\n                            surname: \"McGuire\"\n                        }\n                    }\n                }),\n                proxyModel = new falcor.Model({ source: model.asDataSource() });\n            \n            // Prints \"Steve\"\n            proxyModel.getValue(\"user.name\").\n                then(function(name) {\n                    console.log(name);\n                });\n             */\n            Model.prototype.asDataSource = function asDataSource() {\n                return new ModelDataSourceAdapter(this);\n            };\n\n            Model.prototype._materialize = function materialize() {\n                return this._clone({\n                    _materialized: true\n                });\n            };\n\n            Model.prototype._dematerialize = function dematerialize() {\n                return this._clone({\n                    _materialized: \"delete\"\n                });\n            };\n\n            /**\n             * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n             * @return {Model}\n             */\n            Model.prototype.boxValues = function boxValues() {\n                return this._clone({\n                    _boxed: true\n                });\n            };\n\n            /**\n             * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n             * @return {Model}\n             */\n            Model.prototype.unboxValues = function unboxValues() {\n                return this._clone({\n                    _boxed: \"delete\"\n                });\n            };\n\n            /**\n             * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n             * @return {Model}\n             */\n            Model.prototype.withoutDataSource = function withoutDataSource() {\n                return this._clone({\n                    _source: \"delete\"\n                });\n            };\n\n            Model.prototype.toJSON = function toJSON() {\n                return {\n                    $type: \"ref\",\n                    value: this._path\n                };\n            };\n\n            /**\n             * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n             * @return {Path}\n             * @example\n            var Model = falcor.Model;\n            var model = new Model({\n              cache: {\n                users: [\n                  Model.ref([\"usersById\", 32])\n                ],\n                usersById: {\n                  32: {\n                    name: \"Steve\",\n                    surname: \"McGuire\"\n                  }\n                }\n              }\n            });\n            \n            model.\n                get(['users', 0, 'name']).\n                subscribe(function(jsonEnv) {\n                    var userModel = model.deref(jsonEnv.json.users[0]);\n                    console.log(model.getPath());\n                    console.log(userModel.getPath());\n               });\n            });\n            \n            // prints the following:\n            // []\n            // [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n             */\n            Model.prototype.getPath = function getPath() {\n                return arrayClone(this._path);\n            };\n\n            /**\n             * This one is actually private.  I would not use this without talking to\n             * jhusain, sdesai, or michaelbpaulson (github).\n             * @private\n             */\n            Model.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n                return this._clone({\n                    _allowFromWhenceYouCame: allow === undefined ? true : allow\n                });\n            };\n\n            Model.prototype._getBoundValue = require(17);\n            Model.prototype._getVersion = require(22);\n\n            Model.prototype._getPathValuesAsPathMap = get.getWithPathsAsPathMap;\n            Model.prototype._getPathValuesAsJSONG = get.getWithPathsAsJSONGraph;\n\n            Model.prototype._setPathValues = require(72);\n            Model.prototype._setPathMaps = require(71);\n            Model.prototype._setJSONGs = require(70);\n            Model.prototype._setCache = require(71);\n\n            Model.prototype._invalidatePathValues = require(39);\n            Model.prototype._invalidatePathMaps = require(38);\n        }, { \"113\": 113, \"130\": 130, \"134\": 134, \"17\": 17, \"18\": 18, \"20\": 20, \"22\": 22, \"23\": 23, \"28\": 28, \"3\": 3, \"38\": 38, \"39\": 39, \"4\": 4, \"40\": 40, \"44\": 44, \"5\": 5, \"50\": 50, \"51\": 51, \"52\": 52, \"57\": 57, \"58\": 58, \"59\": 59, \"6\": 6, \"61\": 61, \"63\": 63, \"67\": 67, \"68\": 68, \"69\": 69, \"7\": 7, \"70\": 70, \"71\": 71, \"72\": 72, \"73\": 73, \"74\": 74, \"75\": 75, \"79\": 79, \"85\": 85, \"95\": 95, \"96\": 96, \"97\": 97, \"99\": 99 }], 3: [function (require, module, exports) {\n            function ModelDataSourceAdapter(model) {\n                this._model = model._materialize().treatErrorsAsValues();\n            }\n\n            ModelDataSourceAdapter.prototype.get = function get(pathSets) {\n                return this._model.get.apply(this._model, pathSets)._toJSONG();\n            };\n\n            ModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n                return this._model.set(jsongResponse)._toJSONG();\n            };\n\n            ModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n                var params = [path, args, suffixes].concat(paths);\n                return this._model.call.apply(this._model, params)._toJSONG();\n            };\n\n            module.exports = ModelDataSourceAdapter;\n        }, {}], 4: [function (require, module, exports) {\n            var isFunction = require(93);\n            var hasOwn = require(88);\n            var ImmediateScheduler = require(68);\n\n            function ModelRoot(o) {\n\n                var options = o || {};\n\n                this.syncRefCount = 0;\n                this.expired = options.expired || [];\n                this.unsafeMode = options.unsafeMode || false;\n                this.collectionScheduler = options.collectionScheduler || new ImmediateScheduler();\n                this.cache = {};\n                this._pathObservers = [];\n\n                if (isFunction(options.comparator)) {\n                    this.comparator = options.comparator;\n                }\n\n                if (isFunction(options.errorSelector)) {\n                    this.errorSelector = options.errorSelector;\n                }\n\n                if (isFunction(options.onChange)) {\n                    this.onChange = options.onChange;\n                }\n            }\n\n            ModelRoot.prototype.errorSelector = function errorSelector(x, y) {\n                return y;\n            };\n            ModelRoot.prototype.comparator = function comparator(cacheNode, messageNode) {\n                if (hasOwn(cacheNode, \"value\") && hasOwn(messageNode, \"value\")) {\n                    // They are the same only if the following fields are the same.\n                    return cacheNode.value === messageNode.value && cacheNode.$type === messageNode.$type && cacheNode.$expires === messageNode.$expires;\n                }\n                return cacheNode === messageNode;\n            };\n\n            ModelRoot.prototype.onObserve = function (affectedPaths, affectedPathMap) {\n                this._pathObservers.forEach(function (pathObserver) {\n                    if (pathMapsIntersect(pathObserver.pathMap, affectedPathMap)) {\n                        pathObserver.observer.onNext(affectedPaths);\n                    }\n                });\n            };\n\n            ModelRoot.prototype.hasObservers = function () {\n                return this._pathObservers.length > 0;\n            };\n\n            function pathMapsIntersect(left, right) {\n                if (left === null && right === null) {\n                    return true;\n                }\n                if (typeof left !== \"object\" || typeof right !== \"object\") {\n                    return false;\n                }\n                var leftKeys = Object.keys(left);\n                var key;\n                for (var i = 0; i < leftKeys.length; i++) {\n                    key = leftKeys[i];\n                    if (pathMapsIntersect(left[key], right[key])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            module.exports = ModelRoot;\n        }, { \"68\": 68, \"88\": 88, \"93\": 93 }], 5: [function (require, module, exports) {\n            module.exports = function fromWhenceYeCame() {\n                var reference = this._referenceContainer;\n\n                // Always true when this mode is false.\n                if (!this._allowFromWhenceYouCame) {\n                    return true;\n                }\n\n                // If fromWhenceYouCame is true and the first set of keys did not have\n                // a reference, this case can happen.  They are always valid.\n                if (reference === true) {\n                    return true;\n                }\n\n                // was invalid before even derefing.\n                if (reference === false) {\n                    return false;\n                }\n\n                // Its been disconnected (set over or collected) from the graph.\n                // eslint-disable-next-line camelcase\n                if (reference && reference.$_parent === undefined) {\n                    return false;\n                }\n\n                // The reference has expired but has not been collected from the graph.\n                // eslint-disable-next-line camelcase\n                if (reference && reference.$_invalidated) {\n                    return false;\n                }\n\n                return true;\n            };\n        }, {}], 6: [function (require, module, exports) {\n            var InvalidDerefInputError = require(9);\n            var getCachePosition = require(19);\n            var CONTAINER_DOES_NOT_EXIST = \"e\";\n            var $ref = require(118);\n\n            module.exports = function deref(boundJSONArg) {\n\n                var absolutePath = boundJSONArg && boundJSONArg.$__path;\n                var refPath = boundJSONArg && boundJSONArg.$__refPath;\n                var toReference = boundJSONArg && boundJSONArg.$__toReference;\n                var referenceContainer;\n\n                // We deref and then ensure that the reference container is attached to\n                // the model.\n                if (absolutePath) {\n                    var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n                    if (toReference) {\n                        validContainer = false;\n                        referenceContainer = getCachePosition(this, toReference);\n\n                        // If the reference container is still a sentinel value then compare\n                        // the reference value with refPath.  If they are the same, then the\n                        // model is still valid.\n                        if (refPath && referenceContainer && referenceContainer.$type === $ref) {\n\n                            var containerPath = referenceContainer.value;\n                            var i = 0;\n                            var len = refPath.length;\n\n                            validContainer = true;\n                            for (; validContainer && i < len; ++i) {\n                                if (containerPath[i] !== refPath[i]) {\n                                    validContainer = false;\n                                }\n                            }\n                        }\n                    }\n\n                    // Signal to the deref'd model that it has been disconnected from the\n                    // graph or there is no _fromWhenceYouCame\n                    if (!validContainer) {\n                        referenceContainer = false;\n                    }\n\n                    // The container did not exist, therefore there is no reference\n                    // container and fromWhenceYouCame should always return true.\n                    else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n                            referenceContainer = true;\n                        }\n\n                    return this._clone({\n                        _path: absolutePath,\n                        _referenceContainer: referenceContainer\n                    });\n                }\n\n                throw new InvalidDerefInputError();\n            };\n        }, { \"118\": 118, \"19\": 19, \"9\": 9 }], 7: [function (require, module, exports) {\n            var pathSyntax = require(134);\n            var getBoundValue = require(17);\n            var InvalidModelError = require(10);\n\n            module.exports = function derefSync(boundPathArg) {\n\n                var boundPath = pathSyntax.fromPath(boundPathArg);\n\n                if (!Array.isArray(boundPath)) {\n                    throw new Error(\"Model#derefSync must be called with an Array path.\");\n                }\n\n                var boundValue = getBoundValue(this, this._path.concat(boundPath), false);\n\n                var path = boundValue.path;\n                var node = boundValue.value;\n                var found = boundValue.found;\n\n                // If the node is not found or the node is found but undefined is returned,\n                // this happens when a reference is expired.\n                if (!found || node === undefined) {\n                    return undefined;\n                }\n\n                if (node.$type) {\n                    throw new InvalidModelError(path, path);\n                }\n\n                return this._clone({ _path: path });\n            };\n        }, { \"10\": 10, \"134\": 134, \"17\": 17 }], 8: [function (require, module, exports) {\n            var applyErrorPrototype = require(14);\n\n            /**\n             * When a bound model attempts to retrieve JSONGraph it should throw an\n             * error.\n             *\n             * @private\n             */\n            function BoundJSONGraphModelError() {\n                var instance = new Error(\"It is not legal to use the JSON Graph \" + \"format from a bound Model. JSON Graph format\" + \" can only be used from a root model.\");\n\n                instance.name = \"BoundJSONGraphModelError\";\n\n                if (Object.setPrototypeOf) {\n                    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n                }\n\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(instance, BoundJSONGraphModelError);\n                }\n\n                return instance;\n            }\n\n            applyErrorPrototype(BoundJSONGraphModelError);\n\n            module.exports = BoundJSONGraphModelError;\n        }, { \"14\": 14 }], 9: [function (require, module, exports) {\n            var applyErrorPrototype = require(14);\n\n            /**\n             * An invalid deref input is when deref is used with input that is not generated\n             * from a get, set, or a call.\n             *\n             * @private\n             */\n            function InvalidDerefInputError() {\n                var instance = new Error(\"Deref can only be used with a non-primitive object from get, set, or call.\");\n\n                instance.name = \"InvalidDerefInputError\";\n\n                if (Object.setPrototypeOf) {\n                    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n                }\n\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(instance, InvalidDerefInputError);\n                }\n\n                return instance;\n            }\n\n            applyErrorPrototype(InvalidDerefInputError);\n\n            module.exports = InvalidDerefInputError;\n        }, { \"14\": 14 }], 10: [function (require, module, exports) {\n            var applyErrorPrototype = require(14);\n\n            /**\n             * An InvalidModelError can only happen when a user binds, whether sync\n             * or async to shorted value.  See the unit tests for examples.\n             *\n             * @param {*} boundPath\n             * @param {*} shortedPath\n             *\n             * @private\n             */\n            function InvalidModelError(boundPath, shortedPath) {\n                var instance = new Error(\"The boundPath of the model is not valid since a value or error was found before the path end.\");\n\n                instance.name = \"InvalidModelError\";\n                instance.boundPath = boundPath;\n                instance.shortedPath = shortedPath;\n\n                if (Object.setPrototypeOf) {\n                    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n                }\n\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(instance, InvalidModelError);\n                }\n\n                return instance;\n            }\n\n            applyErrorPrototype(InvalidModelError);\n\n            module.exports = InvalidModelError;\n        }, { \"14\": 14 }], 11: [function (require, module, exports) {\n            var applyErrorPrototype = require(14);\n\n            /**\n             * InvalidSourceError happens when a dataSource syncronously throws\n             * an exception during a get/set/call operation.\n             *\n             * @param {Error} error - The error that was thrown.\n             *\n             * @private\n             */\n            function InvalidSourceError(error) {\n                var instance = new Error(\"An exception was thrown when making a request.\");\n\n                instance.name = \"InvalidSourceError\";\n                instance.innerError = error;\n\n                if (Object.setPrototypeOf) {\n                    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n                }\n\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(instance, InvalidSourceError);\n                }\n\n                return instance;\n            }\n\n            applyErrorPrototype(InvalidSourceError);\n\n            module.exports = InvalidSourceError;\n        }, { \"14\": 14 }], 12: [function (require, module, exports) {\n            var applyErrorPrototype = require(14);\n\n            /**\n             * A request can only be retried up to a specified limit.  Once that\n             * limit is exceeded, then an error will be thrown.\n             *\n             * @param {*} missingOptimizedPaths\n             *\n             * @private\n             */\n            function MaxRetryExceededError(missingOptimizedPaths) {\n                var instance = new Error(\"The allowed number of retries have been exceeded.\");\n\n                instance.name = \"MaxRetryExceededError\";\n                instance.missingOptimizedPaths = missingOptimizedPaths || [];\n\n                if (Object.setPrototypeOf) {\n                    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n                }\n\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(instance, MaxRetryExceededError);\n                }\n\n                return instance;\n            }\n\n            applyErrorPrototype(MaxRetryExceededError);\n\n            MaxRetryExceededError.is = function (e) {\n                return e && e.name === \"MaxRetryExceededError\";\n            };\n\n            module.exports = MaxRetryExceededError;\n        }, { \"14\": 14 }], 13: [function (require, module, exports) {\n            var applyErrorPrototype = require(14);\n\n            /**\n             * Does not allow null in path\n             *\n             * @private\n             */\n            function NullInPathError() {\n                var instance = new Error(\"`null` is not allowed in branch key positions.\");\n\n                instance.name = \"NullInPathError\";\n\n                if (Object.setPrototypeOf) {\n                    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n                }\n\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(instance, NullInPathError);\n                }\n\n                return instance;\n            }\n\n            applyErrorPrototype(NullInPathError);\n\n            module.exports = NullInPathError;\n        }, { \"14\": 14 }], 14: [function (require, module, exports) {\n            function applyErrorPrototype(errorType) {\n                errorType.prototype = Object.create(Error.prototype, {\n                    constructor: {\n                        value: Error,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n\n                if (Object.setPrototypeOf) {\n                    Object.setPrototypeOf(errorType, Error);\n                } else {\n                    // eslint-disable-next-line\n                    errorType.__proto__ = Error;\n                }\n            }\n\n            module.exports = applyErrorPrototype;\n        }, {}], 15: [function (require, module, exports) {\n            var createHardlink = require(81);\n            var onValue = require(26);\n            var isExpired = require(30);\n            var $ref = require(118);\n            var promote = require(41);\n\n            /* eslint-disable no-constant-condition */\n            function followReference(model, root, nodeArg, referenceContainerArg, referenceArg, seed, isJSONG) {\n\n                var node = nodeArg;\n                var reference = referenceArg;\n                var referenceContainer = referenceContainerArg;\n                var depth = 0;\n                var k, next;\n\n                while (true) {\n                    if (depth === 0 && referenceContainer.$_context) {\n                        depth = reference.length;\n                        next = referenceContainer.$_context;\n                    } else {\n                        k = reference[depth++];\n                        next = node[k];\n                    }\n                    if (next) {\n                        var type = next.$type;\n                        var value = type && next.value || next;\n\n                        if (depth < reference.length) {\n                            if (type) {\n                                node = next;\n                                break;\n                            }\n\n                            node = next;\n                            continue;\n                        }\n\n                        // We need to report a value or follow another reference.\n                        else {\n\n                                node = next;\n\n                                if (type && isExpired(next)) {\n                                    break;\n                                }\n\n                                if (!referenceContainer.$_context) {\n                                    createHardlink(referenceContainer, next);\n                                }\n\n                                // Restart the reference follower.\n                                if (type === $ref) {\n\n                                    // Nulls out the depth, outerResults,\n                                    if (isJSONG) {\n                                        onValue(model, next, seed, null, null, null, null, reference, reference.length, isJSONG);\n                                    } else {\n                                        promote(model._root, next);\n                                    }\n\n                                    depth = 0;\n                                    reference = value;\n                                    referenceContainer = next;\n                                    node = root;\n                                    continue;\n                                }\n\n                                break;\n                            }\n                    } else {\n                        node = void 0;\n                    }\n                    break;\n                }\n\n                if (depth < reference.length && node !== void 0) {\n                    var ref = [];\n                    for (var i = 0; i < depth; i++) {\n                        ref[i] = reference[i];\n                    }\n                    reference = ref;\n                }\n\n                return [node, reference, referenceContainer];\n            }\n            /* eslint-enable */\n\n            module.exports = followReference;\n        }, { \"118\": 118, \"26\": 26, \"30\": 30, \"41\": 41, \"81\": 81 }], 16: [function (require, module, exports) {\n            var getCachePosition = require(19);\n            var InvalidModelError = require(10);\n            var BoundJSONGraphModelError = require(8);\n\n            function mergeInto(target, obj) {\n                /* eslint guard-for-in: 0 */\n                if (target === obj) {\n                    return;\n                }\n                if (target === null || typeof target !== \"object\" || target.$type) {\n                    return;\n                }\n                if (obj === null || typeof obj !== \"object\" || obj.$type) {\n                    return;\n                }\n\n                for (var key in obj) {\n                    // When merging over a temporary branch structure (for example, as produced by an error selector)\n                    // with references, we don't want to mutate the path, particularly because it's also $_absolutePath\n                    // on cache nodes\n                    if (key === \"$__path\") {\n                        continue;\n                    }\n\n                    var targetValue = target[key];\n                    if (targetValue === undefined) {\n                        target[key] = obj[key];\n                    } else {\n                        mergeInto(targetValue, obj[key]);\n                    }\n                }\n            }\n\n            function defaultEnvelope(isJSONG) {\n                return isJSONG ? { jsonGraph: {}, paths: [] } : { json: {} };\n            }\n\n            module.exports = function get(walk, isJSONG) {\n                return function innerGet(model, paths, seed) {\n                    // Result valueNode not immutable for isJSONG.\n                    var nextSeed = isJSONG ? seed : [{}];\n                    var valueNode = nextSeed[0];\n                    var results = {\n                        values: nextSeed,\n                        optimizedPaths: []\n                    };\n                    var cache = model._root.cache;\n                    var boundPath = model._path;\n                    var currentCachePosition = cache;\n                    var optimizedPath, optimizedLength;\n                    var i, len;\n                    var requestedPath = [];\n                    var derefInfo = [];\n                    var referenceContainer;\n\n                    // If the model is bound, then get that cache position.\n                    if (boundPath.length) {\n\n                        // JSONGraph output cannot ever be bound or else it will\n                        // throw an error.\n                        if (isJSONG) {\n                            return {\n                                criticalError: new BoundJSONGraphModelError()\n                            };\n                        }\n\n                        // using _getOptimizedPath because that's a point of extension\n                        // for polyfilling legacy falcor\n                        optimizedPath = model._getOptimizedBoundPath();\n                        optimizedLength = optimizedPath.length;\n\n                        // We need to get the new cache position path.\n                        currentCachePosition = getCachePosition(model, optimizedPath);\n\n                        // If there was a short, then we 'throw an error' to the outside\n                        // calling function which will onError the observer.\n                        if (currentCachePosition && currentCachePosition.$type) {\n                            return {\n                                criticalError: new InvalidModelError(boundPath, optimizedPath)\n                            };\n                        }\n\n                        referenceContainer = model._referenceContainer;\n                    }\n\n                    // Update the optimized path if we\n                    else {\n                            optimizedPath = [];\n                            optimizedLength = 0;\n                        }\n\n                    for (i = 0, len = paths.length; i < len; i++) {\n                        walk(model, cache, currentCachePosition, paths[i], 0, valueNode, results, derefInfo, requestedPath, optimizedPath, optimizedLength, isJSONG, false, referenceContainer);\n                    }\n\n                    // Merge in existing results.\n                    // Default to empty envelope if no results were emitted\n                    mergeInto(valueNode, paths.length ? seed[0] : defaultEnvelope(isJSONG));\n\n                    return results;\n                };\n            };\n        }, { \"10\": 10, \"19\": 19, \"8\": 8 }], 17: [function (require, module, exports) {\n            var getValueSync = require(21);\n            var InvalidModelError = require(10);\n\n            module.exports = function getBoundValue(model, pathArg, materialized) {\n\n                var path = pathArg;\n                var boundPath = pathArg;\n                var boxed, treatErrorsAsValues, value, shorted, found;\n\n                boxed = model._boxed;\n                materialized = model._materialized;\n                treatErrorsAsValues = model._treatErrorsAsValues;\n\n                model._boxed = true;\n                model._materialized = materialized === undefined || materialized;\n                model._treatErrorsAsValues = true;\n\n                value = getValueSync(model, path.concat(null), true);\n\n                model._boxed = boxed;\n                model._materialized = materialized;\n                model._treatErrorsAsValues = treatErrorsAsValues;\n\n                path = value.optimizedPath;\n                shorted = value.shorted;\n                found = value.found;\n                value = value.value;\n\n                while (path.length && path[path.length - 1] === null) {\n                    path.pop();\n                }\n\n                if (found && shorted) {\n                    throw new InvalidModelError(boundPath, path);\n                }\n\n                return {\n                    path: path,\n                    value: value,\n                    shorted: shorted,\n                    found: found\n                };\n            };\n        }, { \"10\": 10, \"21\": 21 }], 18: [function (require, module, exports) {\n            var isInternalKey = require(94);\n\n            /**\n             * decends and copies the cache.\n             */\n            module.exports = function getCache(cache) {\n                var out = {};\n                _copyCache(cache, out);\n\n                return out;\n            };\n\n            function cloneBoxedValue(boxedValue) {\n                var clonedValue = {};\n\n                var keys = Object.keys(boxedValue);\n                var key;\n                var i;\n                var l;\n\n                for (i = 0, l = keys.length; i < l; i++) {\n                    key = keys[i];\n\n                    if (!isInternalKey(key)) {\n                        clonedValue[key] = boxedValue[key];\n                    }\n                }\n\n                return clonedValue;\n            }\n\n            function _copyCache(node, out, fromKey) {\n                // copy and return\n\n                Object.keys(node).filter(function (k) {\n                    // Its not an internal key and the node has a value.  In the cache\n                    // there are 3 possibilities for values.\n                    // 1: A branch node.\n                    // 2: A $type-value node.\n                    // 3: undefined\n                    // We will strip out 3\n                    return !isInternalKey(k) && node[k] !== undefined;\n                }).forEach(function (key) {\n                    var cacheNext = node[key];\n                    var outNext = out[key];\n\n                    if (!outNext) {\n                        outNext = out[key] = {};\n                    }\n\n                    // Paste the node into the out cache.\n                    if (cacheNext.$type) {\n                        var isObject = cacheNext.value && typeof cacheNext.value === \"object\";\n                        var isUserCreatedcacheNext = !cacheNext.$_modelCreated;\n                        var value;\n                        if (isObject || isUserCreatedcacheNext) {\n                            value = cloneBoxedValue(cacheNext);\n                        } else {\n                            value = cacheNext.value;\n                        }\n\n                        out[key] = value;\n                        return;\n                    }\n\n                    _copyCache(cacheNext, outNext, key);\n                });\n            }\n        }, { \"94\": 94 }], 19: [function (require, module, exports) {\n            /**\n             * getCachePosition makes a fast walk to the bound value since all bound\n             * paths are the most possible optimized path.\n             *\n             * @param {Model} model -\n             * @param {Array} path -\n             * @returns {Mixed} - undefined if there is nothing in this position.\n             * @private\n             */\n            module.exports = function getCachePosition(model, path) {\n                var currentCachePosition = model._root.cache;\n                var depth = -1;\n                var maxDepth = path.length;\n\n                // The loop is simple now, we follow the current cache position until\n                //\n                while (++depth < maxDepth && currentCachePosition && !currentCachePosition.$type) {\n\n                    currentCachePosition = currentCachePosition[path[depth]];\n                }\n\n                return currentCachePosition;\n            };\n        }, {}], 20: [function (require, module, exports) {\n            var ModelResponse = require(52);\n            var pathSyntax = require(134);\n\n            module.exports = function getValue(path) {\n                var parsedPath = pathSyntax.fromPath(path);\n                var pathIdx = 0;\n                var pathLen = parsedPath.length;\n                while (++pathIdx < pathLen) {\n                    if (typeof parsedPath[pathIdx] === \"object\") {\n                        /* eslint-disable no-loop-func */\n                        return new ModelResponse(function (o) {\n                            o.onError(new Error(\"Paths must be simple paths\"));\n                        });\n                        /* eslint-enable no-loop-func */\n                    }\n                }\n\n                var self = this;\n                return new ModelResponse(function (obs) {\n                    return self.get(parsedPath).subscribe(function (data) {\n                        var curr = data.json;\n                        var depth = -1;\n                        var length = parsedPath.length;\n\n                        while (curr && ++depth < length) {\n                            curr = curr[parsedPath[depth]];\n                        }\n                        obs.onNext(curr);\n                    }, function (err) {\n                        obs.onError(err);\n                    }, function () {\n                        obs.onCompleted();\n                    });\n                });\n            };\n        }, { \"134\": 134, \"52\": 52 }], 21: [function (require, module, exports) {\n            var followReference = require(15);\n            var clone = require(29);\n            var isExpired = require(30);\n            var promote = require(41);\n            var $ref = require(118);\n            var $atom = require(116);\n            var $error = require(117);\n\n            module.exports = function getValueSync(model, simplePath, noClone) {\n                var root = model._root.cache;\n                var len = simplePath.length;\n                var optimizedPath = [];\n                var shorted = false,\n                    shouldShort = false;\n                var depth = 0;\n                var key,\n                    i,\n                    next = root,\n                    curr = root,\n                    out = root,\n                    type,\n                    ref,\n                    refNode;\n                var found = true;\n                var expired = false;\n\n                while (next && depth < len) {\n                    key = simplePath[depth++];\n                    if (key !== null) {\n                        next = curr[key];\n                        optimizedPath[optimizedPath.length] = key;\n                    }\n\n                    if (!next) {\n                        out = undefined;\n                        shorted = true;\n                        found = false;\n                        break;\n                    }\n\n                    type = next.$type;\n\n                    // A materialized item.  There is nothing to deref to.\n                    if (type === $atom && next.value === undefined) {\n                        out = undefined;\n                        found = false;\n                        shorted = depth < len;\n                        break;\n                    }\n\n                    // Up to the last key we follow references, ensure that they are not\n                    // expired either.\n                    if (depth < len) {\n                        if (type === $ref) {\n\n                            // If the reference is expired then we need to set expired to\n                            // true.\n                            if (isExpired(next)) {\n                                expired = true;\n                                out = undefined;\n                                break;\n                            }\n\n                            ref = followReference(model, root, root, next, next.value);\n                            refNode = ref[0];\n\n                            // The next node is also set to undefined because nothing\n                            // could be found, this reference points to nothing, so\n                            // nothing must be returned.\n                            if (!refNode) {\n                                out = void 0;\n                                next = void 0;\n                                found = false;\n                                break;\n                            }\n                            type = refNode.$type;\n                            next = refNode;\n                            optimizedPath = ref[1].slice(0);\n                        }\n\n                        if (type) {\n                            break;\n                        }\n                    }\n                    // If there is a value, then we have great success, else, report an undefined.\n                    else {\n                            out = next;\n                        }\n                    curr = next;\n                }\n\n                if (depth < len && !expired) {\n                    // Unfortunately, if all that follows are nulls, then we have not shorted.\n                    for (i = depth; i < len; ++i) {\n                        if (simplePath[depth] !== null) {\n                            shouldShort = true;\n                            break;\n                        }\n                    }\n                    // if we should short or report value.  Values are reported on nulls.\n                    if (shouldShort) {\n                        shorted = true;\n                        out = void 0;\n                    } else {\n                        out = next;\n                    }\n\n                    for (i = depth; i < len; ++i) {\n                        if (simplePath[i] !== null) {\n                            optimizedPath[optimizedPath.length] = simplePath[i];\n                        }\n                    }\n                }\n\n                // promotes if not expired\n                if (out && type) {\n                    if (isExpired(out)) {\n                        out = void 0;\n                    } else {\n                        promote(model._root, out);\n                    }\n                }\n\n                // if (out && out.$type === $error && !model._treatErrorsAsValues) {\n                if (out && type === $error && !model._treatErrorsAsValues) {\n                    /* eslint-disable no-throw-literal */\n                    throw {\n                        path: depth === len ? simplePath : simplePath.slice(0, depth),\n                        value: out.value\n                    };\n                    /* eslint-enable no-throw-literal */\n                } else if (out && model._boxed) {\n                    out = Boolean(type) && !noClone ? clone(out) : out;\n                } else if (!out && model._materialized) {\n                    out = { $type: $atom };\n                } else if (out) {\n                    out = out.value;\n                }\n\n                return {\n                    value: out,\n                    shorted: shorted,\n                    optimizedPath: optimizedPath,\n                    found: found\n                };\n            };\n        }, { \"116\": 116, \"117\": 117, \"118\": 118, \"15\": 15, \"29\": 29, \"30\": 30, \"41\": 41 }], 22: [function (require, module, exports) {\n            var getValueSync = require(21);\n\n            module.exports = function _getVersion(model, path) {\n                // ultra fast clone for boxed values.\n                var gen = getValueSync({\n                    _boxed: true,\n                    _root: model._root,\n                    _treatErrorsAsValues: model._treatErrorsAsValues\n                }, path, true).value;\n                var version = gen && gen.$_version;\n                return version == null ? -1 : version;\n            };\n        }, { \"21\": 21 }], 23: [function (require, module, exports) {\n            var get = require(16);\n            var walkPath = require(33);\n\n            var getWithPathsAsPathMap = get(walkPath, false);\n            var getWithPathsAsJSONGraph = get(walkPath, true);\n\n            module.exports = {\n                getValueSync: require(21),\n                getBoundValue: require(17),\n                getWithPathsAsPathMap: getWithPathsAsPathMap,\n                getWithPathsAsJSONGraph: getWithPathsAsJSONGraph\n            };\n        }, { \"16\": 16, \"17\": 17, \"21\": 21, \"33\": 33 }], 24: [function (require, module, exports) {\n            var promote = require(41);\n            var clone = require(29);\n\n            module.exports = function onError(model, node, depth, requestedPath, outerResults) {\n                var value = node.value;\n                if (!outerResults.errors) {\n                    outerResults.errors = [];\n                }\n\n                if (model._boxed) {\n                    value = clone(node);\n                }\n                outerResults.errors.push({\n                    path: requestedPath.slice(0, depth),\n                    value: value\n                });\n                promote(model._root, node);\n            };\n        }, { \"29\": 29, \"41\": 41 }], 25: [function (require, module, exports) {\n            var support = require(32);\n            var fastCopy = support.fastCopy;\n            var fastCat = support.fastCat;\n            var arraySlice = require(79);\n\n            module.exports = function onMissing(model, path, depth, outerResults, requestedPath, optimizedPath, optimizedLength) {\n                var pathSlice;\n                if (!outerResults.requestedMissingPaths) {\n                    outerResults.requestedMissingPaths = [];\n                    outerResults.optimizedMissingPaths = [];\n                    outerResults.depthDifferences = [];\n                }\n\n                if (depth < path.length) {\n                    // If part of path has not been traversed, we need to ensure that there\n                    // are no empty paths (range(1, 0) or empyt array)\n                    var isEmpty = false;\n                    for (var i = depth; i < path.length && !isEmpty; ++i) {\n                        if (isEmptyAtom(path[i])) {\n                            return;\n                        }\n                    }\n\n                    pathSlice = fastCopy(path, depth);\n                } else {\n                    pathSlice = [];\n                }\n\n                concatAndInsertMissing(model, pathSlice, depth, requestedPath, optimizedPath, optimizedLength, outerResults);\n            };\n\n            function concatAndInsertMissing(model, remainingPath, depth, requestedPath, optimizedPath, optimizedLength, results) {\n                results.requestedMissingPaths[results.requestedMissingPaths.length] = fastCat(arraySlice(requestedPath, 0, depth), remainingPath);\n\n                results.optimizedMissingPaths[results.optimizedMissingPaths.length] = fastCat(arraySlice(optimizedPath, 0, optimizedLength), remainingPath);\n\n                results.depthDifferences[results.depthDifferences.length] = depth - optimizedLength;\n            }\n\n            function isEmptyAtom(atom) {\n                if (atom === null || typeof atom !== \"object\") {\n                    return false;\n                }\n\n                var isArray = Array.isArray(atom);\n                if (isArray && atom.length) {\n                    return false;\n                }\n\n                // Empty array\n                else if (isArray) {\n                        return true;\n                    }\n\n                var from = atom.from;\n                var to = atom.to;\n                if (from === undefined || from <= to) {\n                    return false;\n                }\n\n                return true;\n            }\n        }, { \"32\": 32, \"79\": 79 }], 26: [function (require, module, exports) {\n            var promote = require(41);\n            var clone = require(29);\n            var $ref = require(118);\n            var $atom = require(116);\n            var $error = require(117);\n\n            module.exports = function onValue(model, node, seed, depth, outerResults, branchInfo, requestedPath, optimizedPath, optimizedLength, isJSONG) {\n                // Promote first.  Even if no output is produced we should still promote.\n                if (node) {\n                    promote(model._root, node);\n                }\n\n                // Preload\n                if (!seed) {\n                    return;\n                }\n\n                var i,\n                    len,\n                    k,\n                    key,\n                    curr,\n                    prev = null,\n                    prevK;\n                var materialized = false,\n                    valueNode,\n                    nodeType = node && node.$type,\n                    nodeValue = node && node.value;\n\n                if (!node || node.value === undefined) {\n                    materialized = model._materialized;\n                }\n\n                // materialized\n                if (materialized) {\n                    valueNode = { $type: $atom };\n                }\n\n                // Boxed Mode will clone the node.\n                else if (model._boxed) {\n                        valueNode = clone(node);\n                    }\n\n                    // We don't want to emit references in json output\n                    else if (!isJSONG && nodeType === $ref) {\n                            valueNode = undefined;\n                        }\n\n                        // JSONG always clones the node.\n                        else if (nodeType === $ref || nodeType === $error) {\n                                if (isJSONG) {\n                                    valueNode = clone(node);\n                                } else {\n                                    valueNode = nodeValue;\n                                }\n                            } else if (isJSONG) {\n                                var isObject = nodeValue && typeof nodeValue === \"object\";\n                                var isUserCreatedNode = !node || !node.$_modelCreated;\n                                if (isObject || isUserCreatedNode) {\n                                    valueNode = clone(node);\n                                } else {\n                                    valueNode = nodeValue;\n                                }\n                            } else {\n                                valueNode = nodeValue;\n                            }\n\n                var hasValues = false;\n\n                if (isJSONG) {\n                    curr = seed.jsonGraph;\n                    if (!curr) {\n                        hasValues = true;\n                        curr = seed.jsonGraph = {};\n                        seed.paths = [];\n                    }\n                    for (i = 0, len = optimizedLength - 1; i < len; i++) {\n                        key = optimizedPath[i];\n\n                        if (!curr[key]) {\n                            hasValues = true;\n                            curr[key] = {};\n                        }\n                        curr = curr[key];\n                    }\n\n                    // assign the last\n                    key = optimizedPath[i];\n\n                    // TODO: Special case? do string comparisons make big difference?\n                    curr[key] = materialized ? { $type: $atom } : valueNode;\n                    if (requestedPath) {\n                        seed.paths.push(requestedPath.slice(0, depth));\n                    }\n                }\n\n                // The output is pathMap and the depth is 0.  It is just a\n                // value report it as the found JSON\n                else if (depth === 0) {\n                        hasValues = true;\n                        seed.json = valueNode;\n                    }\n\n                    // The output is pathMap but we need to build the pathMap before\n                    // reporting the value.\n                    else {\n                            curr = seed.json;\n                            if (!curr) {\n                                hasValues = true;\n                                curr = seed.json = {};\n                            }\n                            for (i = 0; i < depth - 1; i++) {\n                                k = requestedPath[i];\n\n                                // The branch info is already generated output from the walk algo\n                                // with the required __path information on it.\n                                if (!curr[k]) {\n                                    hasValues = true;\n                                    curr[k] = branchInfo[i];\n                                }\n\n                                prev = curr;\n                                prevK = k;\n                                curr = curr[k];\n                            }\n                            k = requestedPath[i];\n                            if (valueNode !== undefined) {\n                                if (k !== null) {\n                                    hasValues = true;\n                                    curr[k] = valueNode;\n                                } else {\n                                    // We are protected from reaching here when depth is 1 and prev is\n                                    // undefined by the InvalidModelError and NullInPathError checks.\n                                    prev[prevK] = valueNode;\n                                }\n                            }\n                        }\n\n                outerResults.hasValues = hasValues;\n            };\n        }, { \"116\": 116, \"117\": 117, \"118\": 118, \"29\": 29, \"41\": 41 }], 27: [function (require, module, exports) {\n            var isExpired = require(30);\n            var $error = require(117);\n            var onError = require(24);\n            var onValue = require(26);\n            var onMissing = require(25);\n            var isMaterialized = require(31);\n            var expireNode = require(83);\n            var currentCacheVersion = require(82);\n\n            /**\n             * When we land on a valueType (or nothing) then we need to report it out to\n             * the outerResults through errors, missing, or values.\n             *\n             * @private\n             */\n            module.exports = function onValueType(model, node, path, depth, seed, outerResults, branchInfo, requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference) {\n\n                var currType = node && node.$type;\n\n                // There are is nothing here, ether report value, or report the value\n                // that is missing.  If there is no type then report the missing value.\n                if (!node || !currType) {\n                    var materialized = isMaterialized(model);\n                    if (materialized || !isJSONG) {\n                        onValue(model, node, seed, depth, outerResults, branchInfo, requestedPath, optimizedPath, optimizedLength, isJSONG);\n                    }\n\n                    if (!materialized) {\n                        onMissing(model, path, depth, outerResults, requestedPath, optimizedPath, optimizedLength);\n                    }\n                    return;\n                }\n\n                // If there are expired value, then report it as missing\n                else if (isExpired(node) && !(node.$_version === currentCacheVersion.getVersion() && node.$expires === 0)) {\n                        if (!node.$_invalidated) {\n                            expireNode(node, model._root.expired, model._root);\n                        }\n                        onMissing(model, path, depth, outerResults, requestedPath, optimizedPath, optimizedLength);\n                    }\n\n                    // If there is an error, then report it as a value if\n                    else if (currType === $error) {\n                            if (fromReference) {\n                                requestedPath[depth] = null;\n                                depth += 1;\n                            }\n                            if (isJSONG || model._treatErrorsAsValues) {\n                                onValue(model, node, seed, depth, outerResults, branchInfo, requestedPath, optimizedPath, optimizedLength, isJSONG);\n                            } else {\n                                onValue(model, undefined, seed, depth, outerResults, branchInfo, requestedPath, optimizedPath, optimizedLength, isJSONG);\n                                onError(model, node, depth, requestedPath, outerResults);\n                            }\n                        }\n\n                        // Report the value\n                        else {\n                                if (fromReference) {\n                                    requestedPath[depth] = null;\n                                    depth += 1;\n                                }\n                                onValue(model, node, seed, depth, outerResults, branchInfo, requestedPath, optimizedPath, optimizedLength, isJSONG);\n                            }\n            };\n        }, { \"117\": 117, \"24\": 24, \"25\": 25, \"26\": 26, \"30\": 30, \"31\": 31, \"82\": 82, \"83\": 83 }], 28: [function (require, module, exports) {\n            var pathSyntax = require(134);\n            var getValueSync = require(21);\n\n            module.exports = function _getValueSync(pathArg) {\n                var path = pathSyntax.fromPath(pathArg);\n                if (Array.isArray(path) === false) {\n                    throw new Error(\"Model#_getValueSync must be called with an Array path.\");\n                }\n                if (this._path.length) {\n                    path = this._path.concat(path);\n                }\n                this._syncCheck(\"getValueSync\");\n                return getValueSync(this, path).value;\n            };\n        }, { \"134\": 134, \"21\": 21 }], 29: [function (require, module, exports) {\n            // Copies the node\n            var privatePrefix = require(35);\n\n            module.exports = function clone(node) {\n                if (node === undefined) {\n                    return node;\n                }\n\n                var outValue, i, len;\n                var keys = Object.keys(node);\n                outValue = {};\n                for (i = 0, len = keys.length; i < len; i++) {\n                    var k = keys[i];\n                    var k0 = k.substr(0, 2);\n                    if (k0 === privatePrefix) {\n                        continue;\n                    }\n                    outValue[k] = node[k];\n                }\n                return outValue;\n            };\n        }, { \"35\": 35 }], 30: [function (require, module, exports) {\n            module.exports = require(92);\n        }, { \"92\": 92 }], 31: [function (require, module, exports) {\n            module.exports = function isMaterialized(model) {\n                return model._materialized && !model._source;\n            };\n        }, {}], 32: [function (require, module, exports) {\n            function fastCopy(arr, iArg) {\n                var a = [],\n                    len,\n                    j,\n                    i;\n                for (j = 0, i = iArg || 0, len = arr.length; i < len; j++, i++) {\n                    a[j] = arr[i];\n                }\n                return a;\n            }\n\n            function fastCat(arr1, arr2) {\n                var a = [],\n                    i,\n                    len,\n                    j;\n                for (i = 0, len = arr1.length; i < len; i++) {\n                    a[i] = arr1[i];\n                }\n                for (j = 0, len = arr2.length; j < len; j++) {\n                    a[i++] = arr2[j];\n                }\n                return a;\n            }\n\n            module.exports = {\n                fastCat: fastCat,\n                fastCopy: fastCopy\n            };\n        }, {}], 33: [function (require, module, exports) {\n            var followReference = require(15);\n            var onValueType = require(27);\n            var onValue = require(26);\n            var isExpired = require(30);\n            var iterateKeySet = require(145).iterateKeySet;\n            var $ref = require(118);\n            var NullInPathError = require(13);\n            var promote = require(41);\n\n            module.exports = function walkPath(model, root, curr, path, depth, seed, outerResults, branchInfo, requestedPath, optimizedPathArg, optimizedLength, isJSONG, fromReferenceArg, referenceContainerArg) {\n\n                var fromReference = fromReferenceArg;\n                var optimizedPath = optimizedPathArg;\n                var referenceContainer = referenceContainerArg;\n\n                // If there is not a value in the current cache position or its a\n                // value type, then we are at the end of the getWalk.\n                if (!curr || curr && curr.$type || depth === path.length) {\n                    onValueType(model, curr, path, depth, seed, outerResults, branchInfo, requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference);\n                    return;\n                }\n\n                var i;\n                var keySet = path[depth];\n                var isKeySet = typeof keySet === \"object\";\n                var nextDepth = depth + 1;\n                var iteratorNote = false;\n                var key = keySet;\n                var allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n\n                if (isKeySet) {\n                    iteratorNote = {};\n                    key = iterateKeySet(keySet, iteratorNote);\n                }\n\n                // loop over every key over the keySet\n                var optimizedLengthPlus1 = optimizedLength + 1;\n                var refPath;\n                do {\n                    fromReference = false;\n\n                    var next;\n\n                    // There are two cases when it comes to a null key.  In path vs at the\n                    // end of a path.\n                    if (key === null) {\n                        // If the key is null and we are not at the end of a path, then\n                        // throw an error.\n                        if (depth < path.length) {\n                            throw new NullInPathError();\n                        }\n\n                        // Else, we are at the end of a path, then just say next is current.\n                        else {\n                                next = curr;\n                            }\n                    }\n\n                    // The standard case, do the depth search into the cache.\n                    else {\n                            next = curr[key];\n                            optimizedPath[optimizedLength] = key;\n                            requestedPath[depth] = key;\n                        }\n\n                    var nextOptimizedPath = optimizedPath;\n                    var nextOptimizedLength = optimizedLengthPlus1;\n\n                    // If there is the next position we need to consider references.\n                    if (next) {\n                        var nType = next.$type;\n                        var value = nType && next.value || next;\n\n                        // If next is a reference follow it.  If we are in JSONG mode,\n                        // report that value into the seed without passing the requested\n                        // path.  If a requested path is passed to onValueType then it\n                        // will add that path to the JSONGraph envelope under `paths`\n                        if (nextDepth < path.length && nType && nType === $ref && !isExpired(next)) {\n\n                            // promote the node so that the references don't get cleaned up.\n                            promote(model._root, next);\n\n                            if (isJSONG) {\n                                onValue(model, next, seed, nextDepth, outerResults, null, null, optimizedPath, nextOptimizedLength, isJSONG);\n                            }\n\n                            var ref = followReference(model, root, root, next, value, seed, isJSONG);\n                            fromReference = true;\n                            next = ref[0];\n                            refPath = ref[1];\n                            referenceContainer = ref[2];\n                            nextOptimizedPath = [];\n                            nextOptimizedLength = refPath.length;\n                            for (i = 0; i < nextOptimizedLength; ++i) {\n                                nextOptimizedPath[i] = refPath[i];\n                            }\n                        }\n\n                        // The next can be set to undefined by following a reference that\n                        // does not exist.\n                        if (next) {\n                            var obj;\n\n                            // There was a reference container.\n                            if (referenceContainer && allowFromWhenceYouCame) {\n                                obj = {\n                                    // eslint-disable-next-line camelcase\n                                    $__path: next.$_absolutePath,\n                                    // eslint-disable-next-line camelcase\n                                    $__refPath: referenceContainer.value,\n                                    // eslint-disable-next-line camelcase\n                                    $__toReference: referenceContainer.$_absolutePath\n                                };\n                            }\n\n                            // There is no reference container meaning this request was\n                            // neither from a model and/or the first n (depth) keys do not\n                            // contain references.\n                            else {\n                                    obj = {\n                                        // eslint-disable-next-line camelcase\n                                        $__path: next.$_absolutePath\n                                    };\n                                }\n\n                            branchInfo[depth] = obj;\n                        }\n                    }\n\n                    // Recurse to the next level.\n                    walkPath(model, root, next, path, nextDepth, seed, outerResults, branchInfo, requestedPath, nextOptimizedPath, nextOptimizedLength, isJSONG, fromReference, referenceContainer);\n\n                    // If the iteratorNote is not done, get the next key.\n                    if (iteratorNote && !iteratorNote.done) {\n                        key = iterateKeySet(keySet, iteratorNote);\n                    }\n                } while (iteratorNote && !iteratorNote.done);\n            };\n        }, { \"118\": 118, \"13\": 13, \"145\": 145, \"15\": 15, \"26\": 26, \"27\": 27, \"30\": 30, \"41\": 41 }], 34: [function (require, module, exports) {\n            \"use strict\";\n\n            function falcor(opts) {\n                return new falcor.Model(opts);\n            }\n\n            /**\n             * A filtering method for keys from a falcor json response.  The only gotcha\n             * to this method is when the incoming json is undefined, then undefined will\n             * be returned.\n             *\n             * @public\n             * @param {Object} json - The json response from a falcor model.\n             * @returns {Array} - the keys that are in the model response minus the deref\n             * _private_ meta data.\n             */\n            falcor.keys = function getJSONKeys(json) {\n                if (!json) {\n                    return undefined;\n                }\n\n                return Object.keys(json).filter(function (key) {\n                    return key !== \"$__path\";\n                });\n            };\n\n            module.exports = falcor;\n\n            falcor.Model = require(2);\n        }, { \"2\": 2 }], 35: [function (require, module, exports) {\n            var reservedPrefix = require(37);\n\n            module.exports = reservedPrefix + \"_\";\n        }, { \"37\": 37 }], 36: [function (require, module, exports) {\n            module.exports = require(35) + \"ref\";\n        }, { \"35\": 35 }], 37: [function (require, module, exports) {\n            module.exports = \"$\";\n        }, {}], 38: [function (require, module, exports) {\n            var pathUtils = require(145);\n            var toTree = pathUtils.toTree;\n            var toPaths = pathUtils.toPaths;\n\n            var createHardlink = require(81);\n            var __prefix = require(37);\n\n            var $ref = require(118);\n\n            var getBoundValue = require(17);\n\n            var promote = require(41);\n            var getSize = require(85);\n            var hasOwn = require(88);\n            var isObject = require(97);\n            var isExpired = require(92);\n            var isFunction = require(93);\n            var isPrimitive = require(99);\n            var expireNode = require(83);\n            var incrementVersion = require(89);\n            var updateNodeAncestors = require(112);\n            var removeNodeAndDescendants = require(106);\n\n            /**\n             * Sets a list of PathMaps into a JSON Graph.\n             * @function\n             * @param {Object} model - the Model for which to insert the PathMaps.\n             * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n             */\n\n            module.exports = function invalidatePathMaps(model, pathMapEnvelopes) {\n\n                var modelRoot = model._root;\n                var lru = modelRoot;\n                var expired = modelRoot.expired;\n                var version = incrementVersion();\n                var comparator = modelRoot._comparator;\n                var errorSelector = modelRoot._errorSelector;\n                var bound = model._path;\n                var cache = modelRoot.cache;\n                var node = bound.length ? getBoundValue(model, bound).value : cache;\n                var parent = node.$_parent || cache;\n                var initialVersion = cache.$_version;\n\n                var pathMapIndex = -1;\n                var pathMapCount = pathMapEnvelopes.length;\n\n                while (++pathMapIndex < pathMapCount) {\n\n                    var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n                    invalidatePathMap(pathMapEnvelope.json, 0, cache, parent, node, version, expired, lru, comparator, errorSelector);\n                }\n\n                if (modelRoot.hasObservers()) {\n                    var affectedPaths = pathMapEnvelopes.reduce(function (allPaths, envelope) {\n                        return allPaths.concat(toPaths(envelope.json));\n                    }, []);\n                    var affectedPathMap = toTree(affectedPaths);\n                    modelRoot.onObserve(affectedPaths, affectedPathMap);\n                }\n\n                var newVersion = cache.$_version;\n                var rootChangeHandler = modelRoot.onChange;\n\n                if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n                    rootChangeHandler();\n                }\n            };\n\n            function invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, errorSelector) {\n\n                if (isPrimitive(pathMap) || pathMap.$type) {\n                    return;\n                }\n\n                for (var key in pathMap) {\n                    if (key[0] !== __prefix && hasOwn(pathMap, key)) {\n                        var child = pathMap[key];\n                        var branch = isObject(child) && !child.$type;\n                        var results = invalidateNode(root, parent, node, key, child, branch, false, version, expired, lru, comparator, errorSelector);\n                        var nextNode = results[0];\n                        var nextParent = results[1];\n                        if (nextNode) {\n                            if (branch) {\n                                invalidatePathMap(child, depth + 1, root, nextParent, nextNode, version, expired, lru, comparator, errorSelector);\n                            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                            }\n                        }\n                    }\n                }\n            }\n\n            function invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector) {\n\n                if (isExpired(node)) {\n                    expireNode(node, expired, lru);\n                    return [undefined, root];\n                }\n\n                promote(lru, node);\n\n                var container = node;\n                var reference = node.value;\n                var parent = root;\n\n                node = node.$_context;\n\n                if (node != null) {\n                    parent = node.$_parent || root;\n                } else {\n\n                    var index = 0;\n                    var count = reference.length - 1;\n\n                    parent = node = root;\n\n                    do {\n                        var key = reference[index];\n                        var branch = index < count;\n                        var results = invalidateNode(root, parent, node, key, value, branch, true, version, expired, lru, comparator, errorSelector);\n                        node = results[0];\n                        if (isPrimitive(node)) {\n                            return results;\n                        }\n                        parent = results[1];\n                    } while (index++ < count);\n\n                    if (container.$_context !== node) {\n                        createHardlink(container, node);\n                    }\n                }\n\n                return [node, parent];\n            }\n\n            function invalidateNode(root, parent, node, key, value, branch, reference, version, expired, lru, comparator, errorSelector) {\n\n                var type = node.$type;\n\n                while (type === $ref) {\n\n                    var results = invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector);\n\n                    node = results[0];\n\n                    if (isPrimitive(node)) {\n                        return results;\n                    }\n\n                    parent = results[1];\n                    type = node && node.$type;\n                }\n\n                if (type !== void 0) {\n                    return [node, parent];\n                }\n\n                if (key == null) {\n                    if (branch) {\n                        throw new Error(\"`null` is not allowed in branch key positions.\");\n                    } else if (node) {\n                        key = node.$_key;\n                    }\n                } else {\n                    parent = node;\n                    node = parent[key];\n                }\n\n                return [node, parent];\n            }\n        }, { \"106\": 106, \"112\": 112, \"118\": 118, \"145\": 145, \"17\": 17, \"37\": 37, \"41\": 41, \"81\": 81, \"83\": 83, \"85\": 85, \"88\": 88, \"89\": 89, \"92\": 92, \"93\": 93, \"97\": 97, \"99\": 99 }], 39: [function (require, module, exports) {\n            var toTree = require(145).toTree;\n\n            var __ref = require(36);\n            var $ref = require(118);\n\n            var getBoundValue = require(17);\n            var promote = require(41);\n            var getSize = require(85);\n            var isExpired = require(92);\n            var isFunction = require(93);\n            var isPrimitive = require(99);\n            var expireNode = require(83);\n            var iterateKeySet = require(145).iterateKeySet;\n            var incrementVersion = require(89);\n            var updateNodeAncestors = require(112);\n            var removeNodeAndDescendants = require(106);\n\n            /**\n             * Invalidates a list of Paths in a JSON Graph.\n             * @function\n             * @param {Object} model - the Model for which to insert the PathValues.\n             * @param {Array.<PathValue>} paths - the PathValues to set.\n             */\n\n            module.exports = function invalidatePathSets(model, paths) {\n\n                var modelRoot = model._root;\n                var lru = modelRoot;\n                var expired = modelRoot.expired;\n                var version = incrementVersion();\n                var bound = model._path;\n                var cache = modelRoot.cache;\n                var node = bound.length ? getBoundValue(model, bound).value : cache;\n                // eslint-disable-next-line camelcase\n                var parent = node.$_parent || cache;\n                // eslint-disable-next-line camelcase\n                var initialVersion = cache.$_version;\n\n                var pathIndex = -1;\n                var pathCount = paths.length;\n\n                while (++pathIndex < pathCount) {\n\n                    var path = paths[pathIndex];\n\n                    invalidatePathSet(path, 0, cache, parent, node, version, expired, lru);\n                }\n\n                if (modelRoot.hasObservers()) {\n                    modelRoot.onObserve(paths, toTree(paths));\n                }\n\n                // eslint-disable-next-line camelcase\n                var newVersion = cache.$_version;\n                var rootChangeHandler = modelRoot.onChange;\n\n                if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n                    rootChangeHandler();\n                }\n            };\n\n            function invalidatePathSet(path, depth, root, parent, node, version, expired, lru) {\n\n                var note = {};\n                var branch = depth < path.length - 1;\n                var keySet = path[depth];\n                var key = iterateKeySet(keySet, note);\n\n                do {\n                    var results = invalidateNode(root, parent, node, key, branch, false, version, expired, lru);\n                    var nextNode = results[0];\n                    var nextParent = results[1];\n                    if (nextNode) {\n                        if (branch) {\n                            invalidatePathSet(path, depth + 1, root, nextParent, nextNode, version, expired, lru);\n                        } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru, undefined)) {\n                            updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                        }\n                    }\n                    key = iterateKeySet(keySet, note);\n                } while (!note.done);\n            }\n\n            function invalidateReference(root, node, version, expired, lru) {\n\n                if (isExpired(node)) {\n                    expireNode(node, expired, lru);\n                    return [undefined, root];\n                }\n\n                promote(lru, node);\n\n                var container = node;\n                var reference = node.value;\n                var parent = root;\n\n                // eslint-disable-next-line camelcase\n                node = node.$_context;\n\n                if (node != null) {\n                    // eslint-disable-next-line camelcase\n                    parent = node.$_parent || root;\n                } else {\n\n                    var index = 0;\n                    var count = reference.length - 1;\n\n                    parent = node = root;\n\n                    do {\n                        var key = reference[index];\n                        var branch = index < count;\n                        var results = invalidateNode(root, parent, node, key, branch, true, version, expired, lru);\n                        node = results[0];\n                        if (isPrimitive(node)) {\n                            return results;\n                        }\n                        parent = results[1];\n                    } while (index++ < count);\n\n                    // eslint-disable-next-line camelcase\n                    if (container.$_context !== node) {\n                        // eslint-disable-next-line camelcase\n                        var backRefs = node.$_refsLength || 0;\n                        // eslint-disable-next-line camelcase\n                        node.$_refsLength = backRefs + 1;\n                        node[__ref + backRefs] = container;\n                        // eslint-disable-next-line camelcase\n                        container.$_context = node;\n                        // eslint-disable-next-line camelcase\n                        container.$_refIndex = backRefs;\n                    }\n                }\n\n                return [node, parent];\n            }\n\n            function invalidateNode(root, parent, node, key, branch, reference, version, expired, lru) {\n\n                var type = node.$type;\n\n                while (type === $ref) {\n\n                    var results = invalidateReference(root, node, version, expired, lru);\n\n                    node = results[0];\n\n                    if (isPrimitive(node)) {\n                        return results;\n                    }\n\n                    parent = results[1];\n                    type = node.$type;\n                }\n\n                if (type !== void 0) {\n                    return [node, parent];\n                }\n\n                if (key == null) {\n                    if (branch) {\n                        throw new Error(\"`null` is not allowed in branch key positions.\");\n                    } else if (node) {\n                        key = node.$_key;\n                    }\n                } else {\n                    parent = node;\n                    node = parent[key];\n                }\n\n                return [node, parent];\n            }\n        }, { \"106\": 106, \"112\": 112, \"118\": 118, \"145\": 145, \"17\": 17, \"36\": 36, \"41\": 41, \"83\": 83, \"85\": 85, \"89\": 89, \"92\": 92, \"93\": 93, \"99\": 99 }], 40: [function (require, module, exports) {\n            var removeNode = require(105);\n            var updateNodeAncestors = require(112);\n\n            module.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n                var total = totalArg;\n                var ratio = ratioArg;\n\n                if (typeof ratio !== \"number\") {\n                    ratio = 0.75;\n                }\n\n                var shouldUpdate = typeof version === \"number\";\n                var targetSize = max * ratio;\n                var parent, node, size;\n\n                node = expired.pop();\n\n                while (node) {\n                    size = node.$size || 0;\n                    total -= size;\n                    if (shouldUpdate === true) {\n                        updateNodeAncestors(node, size, lru, version);\n                        // eslint-disable-next-line camelcase\n                    } else if (parent = node.$_parent) {\n                        // eslint-disable-line no-cond-assign\n                        // eslint-disable-next-line camelcase\n                        removeNode(node, parent, node.$_key, lru);\n                    }\n                    node = expired.pop();\n                }\n\n                if (total >= max) {\n                    // eslint-disable-next-line camelcase\n                    var prev = lru.$_tail;\n                    node = prev;\n                    while (total >= targetSize && node) {\n                        // eslint-disable-next-line camelcase\n                        prev = prev.$_prev;\n                        size = node.$size || 0;\n                        total -= size;\n                        if (shouldUpdate === true) {\n                            updateNodeAncestors(node, size, lru, version);\n                        }\n                        node = prev;\n                    }\n\n                    // eslint-disable-next-line camelcase\n                    lru.$_tail = lru.$_prev = node;\n                    if (node == null) {\n                        // eslint-disable-next-line camelcase\n                        lru.$_head = lru.$_next = undefined;\n                    } else {\n                        // eslint-disable-next-line camelcase\n                        node.$_next = undefined;\n                    }\n                }\n            };\n        }, { \"105\": 105, \"112\": 112 }], 41: [function (require, module, exports) {\n            var EXPIRES_NEVER = require(119);\n\n            // [H] -> Next -> ... -> [T]\n            // [T] -> Prev -> ... -> [H]\n            module.exports = function lruPromote(root, object) {\n                // Never promote node.$expires === 1.  They cannot expire.\n                if (object.$expires === EXPIRES_NEVER) {\n                    return;\n                }\n\n                // eslint-disable-next-line camelcase\n                var head = root.$_head;\n\n                // Nothing is in the cache.\n                if (!head) {\n                    // eslint-disable-next-line camelcase\n                    root.$_head = root.$_tail = object;\n                    return;\n                }\n\n                if (head === object) {\n                    return;\n                }\n\n                // The item always exist in the cache since to get anything in the\n                // cache it first must go through set.\n                // eslint-disable-next-line camelcase\n                var prev = object.$_prev;\n                // eslint-disable-next-line camelcase\n                var next = object.$_next;\n                if (next) {\n                    // eslint-disable-next-line camelcase\n                    next.$_prev = prev;\n                }\n                if (prev) {\n                    // eslint-disable-next-line camelcase\n                    prev.$_next = next;\n                }\n                // eslint-disable-next-line camelcase\n                object.$_prev = undefined;\n\n                // Insert into head position\n                // eslint-disable-next-line camelcase\n                root.$_head = object;\n                // eslint-disable-next-line camelcase\n                object.$_next = head;\n                // eslint-disable-next-line camelcase\n                head.$_prev = object;\n\n                // If the item we promoted was the tail, then set prev to tail.\n                // eslint-disable-next-line camelcase\n                if (object === root.$_tail) {\n                    // eslint-disable-next-line camelcase\n                    root.$_tail = prev;\n                }\n            };\n        }, { \"119\": 119 }], 42: [function (require, module, exports) {\n            module.exports = function lruSplice(root, object) {\n\n                // Its in the cache.  Splice out.\n                // eslint-disable-next-line camelcase\n                var prev = object.$_prev;\n                // eslint-disable-next-line camelcase\n                var next = object.$_next;\n                if (next) {\n                    // eslint-disable-next-line camelcase\n                    next.$_prev = prev;\n                }\n                if (prev) {\n                    // eslint-disable-next-line camelcase\n                    prev.$_next = next;\n                }\n                // eslint-disable-next-line camelcase\n                object.$_prev = object.$_next = undefined;\n\n                // eslint-disable-next-line camelcase\n                if (object === root.$_head) {\n                    // eslint-disable-next-line camelcase\n                    root.$_head = next;\n                }\n                // eslint-disable-next-line camelcase\n                if (object === root.$_tail) {\n                    // eslint-disable-next-line camelcase\n                    root.$_tail = prev;\n                }\n            };\n        }, {}], 43: [function (require, module, exports) {\n            var complement = require(46);\n            var flushGetRequest = require(47);\n            var incrementVersion = require(89);\n            var currentCacheVersion = require(82);\n\n            var REQUEST_ID = 0;\n            var GetRequestType = require(45).GetRequest;\n            var setJSONGraphs = require(70);\n            var setPathValues = require(72);\n            var $error = require(117);\n            var emptyArray = [];\n            var InvalidSourceError = require(11);\n\n            /**\n             * Creates a new GetRequest.  This GetRequest takes a scheduler and\n             * the request queue.  Once the scheduler fires, all batched requests\n             * will be sent to the server.  Upon request completion, the data is\n             * merged back into the cache and all callbacks are notified.\n             *\n             * @param {Scheduler} scheduler -\n             * @param {RequestQueueV2} requestQueue -\n             */\n            var GetRequestV2 = function GetRequestV2(scheduler, requestQueue) {\n                this.sent = false;\n                this.scheduled = false;\n                this.requestQueue = requestQueue;\n                this.id = ++REQUEST_ID;\n                this.type = GetRequestType;\n\n                this._scheduler = scheduler;\n                this._pathMap = {};\n                this._optimizedPaths = [];\n                this._requestedPaths = [];\n                this._callbacks = [];\n                this._count = 0;\n                this._disposable = null;\n                this._collapsed = null;\n                this._disposed = false;\n            };\n\n            GetRequestV2.prototype = {\n                /**\n                 * batches the paths that are passed in.  Once the request is complete,\n                 * all callbacks will be called and the request will be removed from\n                 * parent queue.\n                 * @param {Array} requestedPaths -\n                 * @param {Array} optimizedPaths -\n                 * @param {Function} callback -\n                 */\n                batch: function batch(requestedPaths, optimizedPaths, callback) {\n                    var self = this;\n                    var oPaths = self._optimizedPaths;\n                    var rPaths = self._requestedPaths;\n                    var callbacks = self._callbacks;\n                    var idx = oPaths.length;\n\n                    // If its not sent, simply add it to the requested paths\n                    // and callbacks.\n                    oPaths[idx] = optimizedPaths;\n                    rPaths[idx] = requestedPaths;\n                    callbacks[idx] = callback;\n                    ++self._count;\n\n                    // If it has not been scheduled, then schedule the action\n                    if (!self.scheduled) {\n                        self.scheduled = true;\n\n                        var flushedDisposable;\n                        var scheduleDisposable = self._scheduler.schedule(function () {\n                            flushedDisposable = flushGetRequest(self, oPaths, function (err, data) {\n                                var i, fn, len;\n                                var model = self.requestQueue.model;\n                                self.requestQueue.removeRequest(self);\n                                self._disposed = true;\n\n                                if (model._treatDataSourceErrorsAsJSONGraphErrors ? err instanceof InvalidSourceError : !!err) {\n                                    for (i = 0, len = callbacks.length; i < len; ++i) {\n                                        fn = callbacks[i];\n                                        if (fn) {\n                                            fn(err);\n                                        }\n                                    }\n                                    return;\n                                }\n\n                                // If there is at least one callback remaining, then\n                                // callback the callbacks.\n                                if (self._count) {\n                                    // currentVersion will get added to each inserted\n                                    // node as node.$_version inside of self._merge.\n                                    //\n                                    // atom values just downloaded with $expires: 0\n                                    // (now-expired) will get assigned $_version equal\n                                    // to currentVersion, and checkCacheAndReport will\n                                    // later consider those nodes to not have expired\n                                    // for the duration of current event loop tick\n                                    //\n                                    // we unset currentCacheVersion after all callbacks\n                                    // have been called, to ensure that only these\n                                    // particular callbacks and any synchronous model.get\n                                    // callbacks inside of these, get the now-expired\n                                    // values\n                                    var currentVersion = incrementVersion.getCurrentVersion();\n                                    currentCacheVersion.setVersion(currentVersion);\n                                    var mergeContext = { hasInvalidatedResult: false };\n\n                                    var pathsErr = model._useServerPaths && data && data.paths === undefined ? new Error(\"Server responses must include a 'paths' field when Model._useServerPaths === true\") : undefined;\n\n                                    if (!pathsErr) {\n                                        self._merge(rPaths, err, data, mergeContext);\n                                    }\n\n                                    // Call the callbacks.  The first one inserts all\n                                    // the data so that the rest do not have consider\n                                    // if their data is present or not.\n                                    for (i = 0, len = callbacks.length; i < len; ++i) {\n                                        fn = callbacks[i];\n                                        if (fn) {\n                                            fn(pathsErr || err, data, mergeContext.hasInvalidatedResult);\n                                        }\n                                    }\n                                    currentCacheVersion.setVersion(null);\n                                }\n                            });\n                            self._disposable = flushedDisposable;\n                        });\n\n                        // If the scheduler is sync then `flushedDisposable` will be\n                        // defined, and we want to use it, because that's what aborts an\n                        // in-flight XHR request, for example.\n                        // But if the scheduler is async, then `flushedDisposable` won't be\n                        // defined yet, and so we must use the scheduler's disposable until\n                        // `flushedDisposable` is defined. Since we want to still use\n                        // `flushedDisposable` once it is defined (to be able to abort in-\n                        // flight XHR requests), hence the reassignment of `_disposable`\n                        // above.\n                        self._disposable = flushedDisposable || scheduleDisposable;\n                    }\n\n                    // Disposes this batched request.  This does not mean that the\n                    // entire request has been disposed, but just the local one, if all\n                    // requests are disposed, then the outer disposable will be removed.\n                    return createDisposable(self, idx);\n                },\n\n                /**\n                 * Attempts to add paths to the outgoing request.  If there are added\n                 * paths then the request callback will be added to the callback list.\n                 * Handles adding partial paths as well\n                 *\n                 * @returns {Array} - whether new requested paths were inserted in this\n                 *                    request, the remaining paths that could not be added,\n                 *                    and disposable for the inserted requested paths.\n                 */\n                add: function add(requested, optimized, depthDifferences, callback) {\n                    // uses the length tree complement calculator.\n                    var self = this;\n                    var complementTuple = complement(requested, optimized, depthDifferences, self._pathMap);\n                    var optimizedComplement;\n                    var requestedComplement;\n\n                    if (complementTuple) {\n                        requestedComplement = complementTuple[2];\n                        optimizedComplement = complementTuple[1];\n                    } else {\n                        requestedComplement = requested;\n                        optimizedComplement = optimized;\n                    }\n\n                    var inserted = false;\n                    var disposable = false;\n\n                    // If we found an intersection, then just add new callback\n                    // as one of the dependents of that request\n                    if (complementTuple && complementTuple[0].length) {\n                        inserted = true;\n                        var idx = self._callbacks.length;\n                        self._callbacks[idx] = callback;\n                        self._requestedPaths[idx] = complementTuple[0];\n                        self._optimizedPaths[idx] = [];\n                        ++self._count;\n\n                        disposable = createDisposable(self, idx);\n                    }\n\n                    return [inserted, requestedComplement, optimizedComplement, disposable];\n                },\n\n                /**\n                 * merges the response into the model\"s cache.\n                 */\n                _merge: function _merge(requested, err, data, mergeContext) {\n                    var self = this;\n                    var model = self.requestQueue.model;\n                    var modelRoot = model._root;\n                    var errorSelector = modelRoot.errorSelector;\n                    var comparator = modelRoot.comparator;\n                    var boundPath = model._path;\n\n                    model._path = emptyArray;\n\n                    // flatten all the requested paths, adds them to the\n                    var nextPaths = model._useServerPaths ? data.paths : flattenRequestedPaths(requested);\n\n                    // Insert errors in every requested position.\n                    if (err && model._treatDataSourceErrorsAsJSONGraphErrors) {\n                        var error = err;\n\n                        // Converts errors to objects, a more friendly storage\n                        // of errors.\n                        if (error instanceof Error) {\n                            error = {\n                                message: error.message\n                            };\n                        }\n\n                        // Not all errors are value $types.\n                        if (!error.$type) {\n                            error = {\n                                $type: $error,\n                                value: error\n                            };\n                        }\n\n                        var pathValues = nextPaths.map(function (x) {\n                            return {\n                                path: x,\n                                value: error\n                            };\n                        });\n                        setPathValues(model, pathValues, null, errorSelector, comparator, mergeContext);\n                    }\n\n                    // Insert the jsonGraph from the dataSource.\n                    else {\n                            setJSONGraphs(model, [{\n                                paths: nextPaths,\n                                jsonGraph: data.jsonGraph\n                            }], null, errorSelector, comparator, mergeContext);\n                        }\n\n                    // return the model\"s boundPath\n                    model._path = boundPath;\n                }\n            };\n\n            // Creates a more efficient closure of the things that are\n            // needed.  So the request and the idx.  Also prevents code\n            // duplication.\n            function createDisposable(request, idx) {\n                var disposed = false;\n                return function () {\n                    if (disposed || request._disposed) {\n                        return;\n                    }\n\n                    disposed = true;\n                    request._callbacks[idx] = null;\n                    request._optimizedPaths[idx] = [];\n                    request._requestedPaths[idx] = [];\n\n                    // If there are no more requests, then dispose all of the request.\n                    var count = --request._count;\n                    var disposable = request._disposable;\n                    if (count === 0) {\n                        // looking for unsubscribe here to support more data sources (Rx)\n                        if (disposable.unsubscribe) {\n                            disposable.unsubscribe();\n                        } else {\n                            disposable.dispose();\n                        }\n                        request.requestQueue.removeRequest(request);\n                    }\n                };\n            }\n\n            function flattenRequestedPaths(requested) {\n                var out = [];\n                var outLen = -1;\n                for (var i = 0, len = requested.length; i < len; ++i) {\n                    var paths = requested[i];\n                    for (var j = 0, innerLen = paths.length; j < innerLen; ++j) {\n                        out[++outLen] = paths[j];\n                    }\n                }\n                return out;\n            }\n\n            module.exports = GetRequestV2;\n        }, { \"11\": 11, \"117\": 117, \"45\": 45, \"46\": 46, \"47\": 47, \"70\": 70, \"72\": 72, \"82\": 82, \"89\": 89 }], 44: [function (require, module, exports) {\n            var RequestTypes = require(45);\n            var sendSetRequest = require(48);\n            var GetRequest = require(43);\n            var falcorPathUtils = require(145);\n\n            /**\n             * The request queue is responsible for queuing the operations to\n             * the model\"s dataSource.\n             *\n             * @param {Model} model -\n             * @param {Scheduler} scheduler -\n             */\n            function RequestQueueV2(model, scheduler) {\n                this.model = model;\n                this.scheduler = scheduler;\n                this.requests = this._requests = [];\n            }\n\n            RequestQueueV2.prototype = {\n                /**\n                 * Sets the scheduler, but will not affect any current requests.\n                 */\n                setScheduler: function setScheduler(scheduler) {\n                    this.scheduler = scheduler;\n                },\n\n                /**\n                 * performs a set against the dataSource.  Sets, though are not batched\n                 * currently could be batched potentially in the future.  Since no batching\n                 * is required the setRequest action is simplified significantly.\n                 *\n                 * @param {JSONGraphEnvelope) jsonGraph -\n                 */\n                set: function set(jsonGraph, cb) {\n                    jsonGraph.paths = falcorPathUtils.collapse(jsonGraph.paths);\n                    return sendSetRequest(jsonGraph, this.model, cb);\n                },\n\n                /**\n                 * Creates a get request to the dataSource.  Depending on the current\n                 * scheduler is how the getRequest will be flushed.\n                 * @param {Array} requestedPaths -\n                 * @param {Array} optimizedPaths -\n                 * @param {Function} cb -\n                 */\n                get: function get(requestedPaths, optimizedPaths, depthDifferences, cb) {\n                    var self = this;\n                    var disposables = [];\n                    var count = 0;\n                    var requests = self._requests;\n                    var i, len;\n                    var oRemainingPaths = optimizedPaths;\n                    var rRemainingPaths = requestedPaths;\n                    var disposed = false;\n                    var request;\n\n                    for (i = 0, len = requests.length; i < len; ++i) {\n                        request = requests[i];\n                        if (request.type !== RequestTypes.GetRequest) {\n                            continue;\n                        }\n\n                        // The request has been sent, attempt to jump on the request\n                        // if possible.\n                        if (request.sent) {\n                            var results = request.add(rRemainingPaths, oRemainingPaths, depthDifferences, refCountCallback);\n\n                            // Checks to see if the results were successfully inserted\n                            // into the outgoing results.  Then our paths will be reduced\n                            // to the complement.\n                            if (results[0]) {\n                                rRemainingPaths = results[1];\n                                oRemainingPaths = results[2];\n                                disposables[disposables.length] = results[3];\n                                ++count;\n                            }\n                        }\n\n                        // If there is a non sent request, then we can batch and leave.\n                        else {\n                                request.batch(rRemainingPaths, oRemainingPaths, refCountCallback);\n                                oRemainingPaths = [];\n                                rRemainingPaths = [];\n                                ++count;\n                            }\n\n                        // If there are no more remaining paths then exit the loop.\n                        if (!oRemainingPaths.length) {\n                            break;\n                        }\n                    }\n\n                    // After going through all the available requests if there are more\n                    // paths to process then a new request must be made.\n                    if (oRemainingPaths.length) {\n                        request = new GetRequest(self.scheduler, self);\n                        requests[requests.length] = request;\n                        ++count;\n                        var disposable = request.batch(rRemainingPaths, oRemainingPaths, refCountCallback);\n                        disposables[disposables.length] = disposable;\n                    }\n\n                    // This is a simple refCount callback.\n                    function refCountCallback(err, data, hasInvalidatedResult) {\n                        if (disposed) {\n                            return;\n                        }\n\n                        --count;\n\n                        // If the count becomes 0, then its time to notify the\n                        // listener that the request is done.\n                        if (count === 0) {\n                            cb(err, data, hasInvalidatedResult);\n                        }\n                    }\n\n                    // When disposing the request all of the outbound requests will be\n                    // disposed of.\n                    return function () {\n                        if (disposed || count === 0) {\n                            return;\n                        }\n\n                        disposed = true;\n                        var length = disposables.length;\n                        for (var idx = 0; idx < length; ++idx) {\n                            disposables[idx]();\n                        }\n                    };\n                },\n\n                /**\n                 * Removes the request from the request\n                 */\n                removeRequest: function removeRequest(request) {\n                    var requests = this._requests;\n                    var i = requests.length;\n                    while (--i >= 0) {\n                        if (requests[i].id === request.id) {\n                            requests.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            };\n\n            module.exports = RequestQueueV2;\n        }, { \"145\": 145, \"43\": 43, \"45\": 45, \"48\": 48 }], 45: [function (require, module, exports) {\n            module.exports = {\n                GetRequest: \"GET\"\n            };\n        }, {}], 46: [function (require, module, exports) {\n            var hasIntersection = require(145).hasIntersection;\n            var arraySlice = require(79);\n            var arrayConcat = require(76);\n            var iterateKeySet = require(145).iterateKeySet;\n\n            /**\n             * Figures out what paths in requested pathsets can be\n             * deduped based on existing optimized path tree provided.\n             *\n             * ## no deduping possible:\n             *\n             * if no existing requested sub tree at all for path,\n             * just add the entire path to complement.\n             *\n             * ## fully deduped:\n             *\n             * if required path is a complete subset of given sub tree,\n             * just add the entire path to intersection\n             *\n             * ## partial deduping:\n             *\n             * if some part of path, when ranges are expanded, is a subset\n             * of given sub tree, then add only that part to intersection,\n             * and all other parts of this path to complement\n             *\n             * To keep `depth` argument be a valid index for optimized path (`oPath`),\n             * either requested or optimized path is sent in pre-initialized with\n             * some items so that their remaining length matches exactly, keeping\n             * remaining ranges in those pathsets 1:1 in correspondence\n             *\n             * Note that positive `depthDiff` value means that requested path is\n             * longer than optimized path, and we need to pre-initialize current\n             * requested path with that many offset items, so that their remaining\n             * length matches. Similarly, negative `depthDiff` value means that\n             * optimized path is longer, and we pre-initialize optimized path with\n             * those many items. Note that because of the way requested and\n             * optimized paths are accumulated from what user requested in model.get\n             * (see onMissing.js), it is not possible for the pre-initialized paths\n             * to have any ranges in them.\n             *\n             * `intersectionData` is:\n             * [ requestedIntersection, optimizedComplement, requestedComplement ]\n             * where `requestedIntersection` is matched requested paths that can be\n             * deduped, `optimizedComplement` is missing optimized paths, and\n             * `requestedComplement` is requested counterparts of those missing\n             * optimized paths\n             */\n            module.exports = function complement(requested, optimized, depthDifferences, tree) {\n                var optimizedComplement = [];\n                var requestedComplement = [];\n                var requestedIntersection = [];\n                var intersectionLength = -1,\n                    complementLength = -1;\n\n                for (var i = 0, len = optimized.length; i < len; ++i) {\n                    var oPath = optimized[i];\n                    var rPath = requested[i];\n                    var depthDiff = depthDifferences[i];\n                    var subTree = tree[oPath.length];\n\n                    // no deduping possible\n                    if (!subTree) {\n                        optimizedComplement[++complementLength] = oPath;\n                        requestedComplement[complementLength] = rPath;\n                        continue;\n                    }\n                    // fully deduped\n                    if (hasIntersection(subTree, oPath, 0)) {\n                        requestedIntersection[++intersectionLength] = rPath;\n                        continue;\n                    }\n\n                    // partial deduping\n                    var intersectionData = findPartialIntersections(rPath, oPath, subTree, depthDiff < 0 ? -depthDiff : 0, depthDiff > 0 ? arraySlice(rPath, 0, depthDiff) : [], depthDiff < 0 ? arraySlice(oPath, 0, -depthDiff) : [], depthDiff);\n                    for (var j = 0, jLen = intersectionData[0].length; j < jLen; ++j) {\n                        requestedIntersection[++intersectionLength] = intersectionData[0][j];\n                    }\n                    for (var k = 0, kLen = intersectionData[1].length; k < kLen; ++k) {\n                        optimizedComplement[++complementLength] = intersectionData[1][k];\n                        requestedComplement[complementLength] = intersectionData[2][k];\n                    }\n                }\n\n                if (!requestedIntersection.length) {\n                    return null;\n                }\n                return [requestedIntersection, optimizedComplement, requestedComplement];\n            };\n\n            /**\n             * Recursive function to calculate intersection and complement paths in 2 given\n             * pathsets at a given depth\n             * Parameters:\n             *  - `requestedPath`: full requested path (can include ranges)\n             *  - `optimizedPath`: corresponding optimized path (can include ranges)\n             *  - `currentTree`: path map for in-flight request, against which to dedupe\n             *  - `depth`: index of optimized path that we are trying to match with `currentTree`\n             *  - `rCurrentPath`: current accumulated requested path by previous recursive\n             *                    iterations. Could also have been pre-initialized as stated\n             *                    above.\n             *                    This path cannot contain ranges, instead contains a key\n             *                    from the range, representing one of the individual paths\n             *                    in `requestedPath` pathset\n             *  - `oCurrentPath`: corresponding accumulated optimized path, to be matched\n             *                    with `currentTree`. Could have been pre-initialized.\n             *                    Cannot contain ranges, instead contains a key from the\n             *                    range at given `depth` in `optimizedPath`\n             *  - `depthDiff`: difference in length between `requestedPath` and `optimizedPath`\n             *\n             *  Example scenario:\n             *      - requestedPath: ['lolomo', 0, 0, 'tags', { from: 0, to: 2 }]\n             *      - optimizedPath: ['videosById', 11, 'tags', { from: 0, to: 2 }]\n             *      - currentTree: { videosById: 11: { tags: { 0: null, 1: null }}}\n             *      // since requested path is longer, optimized path index starts from depth 0\n             *      // and accumulated requested path starts pre-initialized (rCurrentPath)\n             *      - depth: 0\n             *      - rCurrentPath: ['lolomo']\n             *      - oCurrentPath: []\n             *      - depthDiff: 1\n             */\n            function findPartialIntersections(requestedPath, optimizedPath, currentTree, depth, rCurrentPath, oCurrentPath, depthDiff) {\n                var intersections = [];\n                var rComplementPaths = [];\n                var oComplementPaths = [];\n                // iterate over optimized path, looking for deduping opportunities\n                for (; depth < optimizedPath.length; ++depth) {\n                    var key = optimizedPath[depth];\n                    var keyType = typeof key;\n\n                    // if range key is found, start inner loop to iterate over all keys in range\n                    // and add intersections and complements from each iteration separately.\n                    // range keys branch-out like this, providing individual deduping\n                    // opportunities for each inner key\n                    if (key && keyType === \"object\") {\n                        var note = {};\n                        var innerKey = iterateKeySet(key, note);\n\n                        while (!note.done) {\n                            var nextTree = currentTree[innerKey];\n                            if (nextTree === undefined) {\n                                // if no next sub tree exists for an inner key, it's a dead-end\n                                // and we can add this to complement paths\n                                var oPath = oCurrentPath.concat(innerKey, arraySlice(optimizedPath, depth + 1));\n                                oComplementPaths[oComplementPaths.length] = oPath;\n                                var rPath = rCurrentPath.concat(innerKey, arraySlice(requestedPath, depth + 1 + depthDiff));\n                                rComplementPaths[rComplementPaths.length] = rPath;\n                            } else if (depth === optimizedPath.length - 1) {\n                                // reaching the end of optimized path means that we found a\n                                // corresponding node in the path map tree every time,\n                                // so add current path to successful intersections\n                                intersections[intersections.length] = arrayConcat(rCurrentPath, [innerKey]);\n                            } else {\n                                // otherwise keep trying to find further partial deduping\n                                // opportunities in the remaining path!\n                                var intersectionData = findPartialIntersections(requestedPath, optimizedPath, nextTree, depth + 1, arrayConcat(rCurrentPath, [innerKey]), arrayConcat(oCurrentPath, [innerKey]), depthDiff);\n                                for (var j = 0, jLen = intersectionData[0].length; j < jLen; ++j) {\n                                    intersections[intersections.length] = intersectionData[0][j];\n                                }\n                                for (var k = 0, kLen = intersectionData[1].length; k < kLen; ++k) {\n                                    oComplementPaths[oComplementPaths.length] = intersectionData[1][k];\n                                    rComplementPaths[rComplementPaths.length] = intersectionData[2][k];\n                                }\n                            }\n                            innerKey = iterateKeySet(key, note);\n                        }\n                        break;\n                    }\n\n                    // for simple keys, we don't need to branch out. looping over `depth`\n                    // here instead of recursion, for performance\n                    currentTree = currentTree[key];\n                    oCurrentPath[oCurrentPath.length] = optimizedPath[depth];\n                    rCurrentPath[rCurrentPath.length] = requestedPath[depth + depthDiff];\n\n                    if (currentTree === undefined) {\n                        // if dead-end, add this to complements\n                        oComplementPaths[oComplementPaths.length] = arrayConcat(oCurrentPath, arraySlice(optimizedPath, depth + 1));\n                        rComplementPaths[rComplementPaths.length] = arrayConcat(rCurrentPath, arraySlice(requestedPath, depth + depthDiff + 1));\n                        break;\n                    } else if (depth === optimizedPath.length - 1) {\n                        // if reach end of optimized path successfully, add to intersections\n                        intersections[intersections.length] = rCurrentPath;\n                    }\n                    // otherwise keep going\n                }\n\n                // return accumulated intersection and complement pathsets\n                return [intersections, oComplementPaths, rComplementPaths];\n            }\n        }, { \"145\": 145, \"76\": 76, \"79\": 79 }], 47: [function (require, module, exports) {\n            var pathUtils = require(145);\n            var toTree = pathUtils.toTree;\n            var toPaths = pathUtils.toPaths;\n            var InvalidSourceError = require(11);\n\n            /**\n             * Flushes the current set of requests.  This will send the paths to the\n             * dataSource.  * The results of the dataSource will be sent to callback which\n             * should perform the zip of all callbacks.\n             * @param {GetRequest} request -\n             * @param {Array} listOfPaths -\n             * @param {Function} callback -\n             * @private\n             */\n            module.exports = function flushGetRequest(request, listOfPaths, callback) {\n                if (request._count === 0) {\n                    request.requestQueue.removeRequest(request);\n                    return null;\n                }\n\n                request.sent = true;\n                request.scheduled = false;\n\n                // TODO: Move this to the collapse algorithm,\n                // TODO: we should have a collapse that returns the paths and\n                // TODO: the trees.\n\n                // Take all the paths and add them to the pathMap by length.\n                // Since its a list of paths\n                var pathMap = request._pathMap;\n                var listKeys = Object.keys(listOfPaths);\n                var listIdx = 0,\n                    listLen = listKeys.length;\n                for (; listIdx < listLen; ++listIdx) {\n                    var paths = listOfPaths[listIdx];\n                    for (var j = 0, pathLen = paths.length; j < pathLen; ++j) {\n                        var pathSet = paths[j];\n                        var len = pathSet.length;\n\n                        if (!pathMap[len]) {\n                            pathMap[len] = [pathSet];\n                        } else {\n                            var pathSetsByLength = pathMap[len];\n                            pathSetsByLength[pathSetsByLength.length] = pathSet;\n                        }\n                    }\n                }\n\n                // now that we have them all by length, convert each to a tree.\n                var pathMapKeys = Object.keys(pathMap);\n                var pathMapIdx = 0,\n                    pathMapLen = pathMapKeys.length;\n                for (; pathMapIdx < pathMapLen; ++pathMapIdx) {\n                    var pathMapKey = pathMapKeys[pathMapIdx];\n                    pathMap[pathMapKey] = toTree(pathMap[pathMapKey]);\n                }\n\n                // Take the pathMapTree and create the collapsed paths and send those\n                // off to the server.\n                var collapsedPaths = request._collasped = toPaths(pathMap);\n                var jsonGraphData;\n\n                // Make the request.\n                // You are probably wondering why this is not cancellable.  If a request\n                // goes out, and all the requests are removed, the request should not be\n                // cancelled.  The reasoning is that another request could come in, after\n                // all callbacks have been removed and be deduped.  Might as well keep this\n                // around until it comes back.  If at that point there are no requests then\n                // we cancel at the callback above.\n                var getRequest;\n                try {\n                    getRequest = request.requestQueue.model._source.get(collapsedPaths);\n                } catch (e) {\n                    callback(new InvalidSourceError());\n                    return null;\n                }\n\n                // Ensures that the disposable is available for the outside to cancel.\n                var disposable = getRequest.subscribe(function (data) {\n                    jsonGraphData = data;\n                }, function (err) {\n                    callback(err, jsonGraphData);\n                }, function () {\n                    callback(null, jsonGraphData);\n                });\n\n                return disposable;\n            };\n        }, { \"11\": 11, \"145\": 145 }], 48: [function (require, module, exports) {\n            var arrayMap = require(78);\n            var setJSONGraphs = require(70);\n            var setPathValues = require(72);\n            var InvalidSourceError = require(11);\n\n            var emptyArray = [];\n            var emptyDisposable = { dispose: function dispose() {} };\n\n            /**\n             * A set request is not an object like GetRequest.  It simply only needs to\n             * close over a couple values and its never batched together (at least not now).\n             *\n             * @private\n             * @param {JSONGraphEnvelope} jsonGraph -\n             * @param {Model} model -\n             * @param {Function} callback -\n             */\n            var sendSetRequest = function sendSetRequest(originalJsonGraph, model, callback) {\n                var paths = originalJsonGraph.paths;\n                var modelRoot = model._root;\n                var errorSelector = modelRoot.errorSelector;\n                var comparator = modelRoot.comparator;\n                var boundPath = model._path;\n                var resultingJsonGraphEnvelope;\n\n                // This is analogous to GetRequest _merge / flushGetRequest\n                // SetRequests are just considerably simplier.\n                var setObservable;\n                try {\n                    setObservable = model._source.set(originalJsonGraph);\n                } catch (e) {\n                    callback(new InvalidSourceError());\n                    return emptyDisposable;\n                }\n\n                var disposable = setObservable.subscribe(function onNext(jsonGraphEnvelope) {\n                    // When disposed, no data is inserted into.  This can sync resolve\n                    // and if thats the case then its undefined.\n                    if (disposable && disposable.disposed) {\n                        return;\n                    }\n\n                    // onNext will insert all data into the model then save the json\n                    // envelope from the incoming result.\n                    model._path = emptyArray;\n\n                    var successfulPaths = setJSONGraphs(model, [{\n                        paths: paths,\n                        jsonGraph: jsonGraphEnvelope.jsonGraph\n                    }], null, errorSelector, comparator);\n\n                    jsonGraphEnvelope.paths = successfulPaths[1];\n\n                    model._path = boundPath;\n                    resultingJsonGraphEnvelope = jsonGraphEnvelope;\n                }, function onError(dataSourceError) {\n                    if (disposable && disposable.disposed) {\n                        return;\n                    }\n                    model._path = emptyArray;\n\n                    setPathValues(model, arrayMap(paths, function (path) {\n                        return {\n                            path: path,\n                            value: dataSourceError\n                        };\n                    }), null, errorSelector, comparator);\n\n                    model._path = boundPath;\n\n                    callback(dataSourceError);\n                }, function onCompleted() {\n                    callback(null, resultingJsonGraphEnvelope);\n                });\n\n                return disposable;\n            };\n\n            module.exports = sendSetRequest;\n        }, { \"11\": 11, \"70\": 70, \"72\": 72, \"78\": 78 }], 49: [function (require, module, exports) {\n            /**\n             * Will allow for state tracking of the current disposable.  Also fulfills the\n             * disposable interface.\n             * @private\n             */\n            var AssignableDisposable = function AssignableDisposable(disosableCallback) {\n                this.disposed = false;\n                this.currentDisposable = disosableCallback;\n            };\n\n            AssignableDisposable.prototype = {\n\n                /**\n                 * Disposes of the current disposable.  This would be the getRequestCycle\n                 * disposable.\n                 */\n                dispose: function dispose() {\n                    if (this.disposed || !this.currentDisposable) {\n                        return;\n                    }\n                    this.disposed = true;\n\n                    // If the current disposable fulfills the disposable interface or just\n                    // a disposable function.\n                    var currentDisposable = this.currentDisposable;\n                    if (currentDisposable.dispose) {\n                        currentDisposable.dispose();\n                    } else {\n                        currentDisposable();\n                    }\n                }\n            };\n\n            module.exports = AssignableDisposable;\n        }, {}], 50: [function (require, module, exports) {\n            var ModelResponse = require(52);\n            var InvalidSourceError = require(11);\n\n            var pathSyntax = require(134);\n\n            /**\n             * @private\n             * @augments ModelResponse\n             */\n            function CallResponse(model, callPath, args, suffix, paths) {\n                this.callPath = pathSyntax.fromPath(callPath);\n                this.args = args;\n\n                if (paths) {\n                    this.paths = paths.map(pathSyntax.fromPath);\n                }\n                if (suffix) {\n                    this.suffix = suffix.map(pathSyntax.fromPath);\n                }\n                this.model = model;\n            }\n\n            CallResponse.prototype = Object.create(ModelResponse.prototype);\n            CallResponse.prototype._subscribe = function _subscribe(observer) {\n                var callPath = this.callPath;\n                var callArgs = this.args;\n                var suffixes = this.suffix;\n                var extraPaths = this.paths;\n                var model = this.model;\n                var rootModel = model._clone({\n                    _path: []\n                });\n                var boundPath = model._path;\n                var boundCallPath = boundPath.concat(callPath);\n\n                /* eslint-disable consistent-return */\n                // Precisely the same error as the router when a call function does not\n                // exist.\n                if (!model._source) {\n                    observer.onError(new Error(\"function does not exist\"));\n                    return;\n                }\n\n                var response, obs;\n                try {\n                    obs = model._source.call(boundCallPath, callArgs, suffixes, extraPaths);\n                } catch (e) {\n                    observer.onError(new InvalidSourceError(e));\n                    return;\n                }\n\n                return obs.subscribe(function (res) {\n                    response = res;\n                }, function (err) {\n                    observer.onError(err);\n                }, function () {\n\n                    // Run the invalidations first then the follow up JSONGraph set.\n                    var invalidations = response.invalidated;\n                    if (invalidations && invalidations.length) {\n                        rootModel.invalidate.apply(rootModel, invalidations);\n                    }\n\n                    // The set\n                    rootModel.withoutDataSource().set(response).subscribe(function (x) {\n                        observer.onNext(x);\n                    }, function (err) {\n                        observer.onError(err);\n                    }, function () {\n                        observer.onCompleted();\n                    });\n                });\n                /* eslint-enable consistent-return */\n            };\n\n            module.exports = CallResponse;\n        }, { \"11\": 11, \"134\": 134, \"52\": 52 }], 51: [function (require, module, exports) {\n            var isArray = Array.isArray;\n            var ModelResponse = require(52);\n            var isPathValue = require(98);\n            var isJSONEnvelope = require(95);\n            var empty = { dispose: function dispose() {} };\n\n            function InvalidateResponse(model, args) {\n                // TODO: This should be removed.  There should only be 1 type of arguments\n                // coming in, but we have strayed from documentation.\n                this._model = model;\n\n                var groups = [];\n                var group, groupType;\n                var argIndex = -1;\n                var argCount = args.length;\n\n                // Validation of arguments have been moved out of this function.\n                while (++argIndex < argCount) {\n                    var arg = args[argIndex];\n                    var argType;\n                    if (isArray(arg)) {\n                        argType = \"PathValues\";\n                    } else if (isPathValue(arg)) {\n                        argType = \"PathValues\";\n                    } else if (isJSONEnvelope(arg)) {\n                        argType = \"PathMaps\";\n                    } else {\n                        throw new Error(\"Invalid Input\");\n                    }\n\n                    if (groupType !== argType) {\n                        groupType = argType;\n                        group = {\n                            inputType: argType,\n                            arguments: []\n                        };\n                        groups.push(group);\n                    }\n\n                    group.arguments.push(arg);\n                }\n\n                this._groups = groups;\n            }\n\n            InvalidateResponse.prototype = Object.create(ModelResponse.prototype);\n            InvalidateResponse.prototype.progressively = function progressively() {\n                return this;\n            };\n            InvalidateResponse.prototype._toJSONG = function _toJSONG() {\n                return this;\n            };\n\n            InvalidateResponse.prototype._subscribe = function _subscribe(observer) {\n\n                var model = this._model;\n                this._groups.forEach(function (group) {\n                    var inputType = group.inputType;\n                    var methodArgs = group.arguments;\n                    var operationName = \"_invalidate\" + inputType;\n                    var operationFunc = model[operationName];\n                    operationFunc(model, methodArgs);\n                });\n                observer.onCompleted();\n\n                return empty;\n            };\n\n            module.exports = InvalidateResponse;\n        }, { \"52\": 52, \"95\": 95, \"98\": 98 }], 52: [function (require, module, exports) {\n            (function (Promise) {\n                var ModelResponseObserver = require(53);\n                var $$observable = require(164).default;\n                var toEsObservable = require(115);\n\n                /**\n                 * A ModelResponse is a container for the results of a get, set, or call operation performed on a Model. The ModelResponse provides methods which can be used to specify the output format of the data retrieved from a Model, as well as how that data is delivered.\n                 * @constructor ModelResponse\n                 * @augments Observable\n                */\n                function ModelResponse(subscribe) {\n                    this._subscribe = subscribe;\n                }\n\n                ModelResponse.prototype[$$observable] = function SymbolObservable() {\n                    return toEsObservable(this);\n                };\n\n                ModelResponse.prototype._toJSONG = function toJSONG() {\n                    return this;\n                };\n\n                /**\n                 * The progressively method breaks the response up into two parts: the data immediately available in the Model cache, and the data in the Model cache after the missing data has been retrieved from the DataSource.\n                 * The progressively method creates a ModelResponse that immediately returns the requested data that is available in the Model cache. If any requested paths are not available in the cache, the ModelResponse will send another JSON message with all of the requested data after it has been retrieved from the DataSource.\n                 * @name progressively\n                 * @memberof ModelResponse.prototype\n                 * @function\n                 * @return {ModelResponse.<JSONEnvelope>} the values found at the requested paths.\n                 * @example\n                var dataSource = (new falcor.Model({\n                  cache: {\n                    user: {\n                      name: \"Steve\",\n                      surname: \"McGuire\",\n                      age: 31\n                    }\n                  }\n                })).asDataSource();\n                \n                var model = new falcor.Model({\n                  source: dataSource,\n                  cache: {\n                    user: {\n                      name: \"Steve\",\n                      surname: \"McGuire\"\n                    }\n                  }\n                });\n                \n                model.\n                  get([\"user\",[\"name\", \"surname\", \"age\"]]).\n                  progressively().\n                  // this callback will be invoked twice, once with the data in the\n                  // Model cache, and again with the additional data retrieved from the DataSource.\n                  subscribe(function(json){\n                    console.log(JSON.stringify(json,null,4));\n                  });\n                \n                // prints...\n                // {\n                //     \"json\": {\n                //         \"user\": {\n                //             \"name\": \"Steve\",\n                //             \"surname\": \"McGuire\"\n                //         }\n                //     }\n                // }\n                // ...and then prints...\n                // {\n                //     \"json\": {\n                //         \"user\": {\n                //             \"name\": \"Steve\",\n                //             \"surname\": \"McGuire\",\n                //             \"age\": 31\n                //         }\n                //     }\n                // }\n                */\n                ModelResponse.prototype.progressively = function progressively() {\n                    return this;\n                };\n\n                ModelResponse.prototype.subscribe = ModelResponse.prototype.forEach = function subscribe(a, b, c) {\n                    var observer = new ModelResponseObserver(a, b, c);\n                    var subscription = this._subscribe(observer);\n                    switch (typeof subscription) {\n                        case \"function\":\n                            return {\n                                dispose: function dispose() {\n                                    if (observer._closed) {\n                                        return;\n                                    }\n                                    observer._closed = true;\n                                    subscription();\n                                }\n                            };\n                        case \"object\":\n                            return {\n                                dispose: function dispose() {\n                                    if (observer._closed) {\n                                        return;\n                                    }\n                                    observer._closed = true;\n                                    if (subscription !== null) {\n                                        subscription.dispose();\n                                    }\n                                }\n                            };\n                        default:\n                            return {\n                                dispose: function dispose() {\n                                    observer._closed = true;\n                                }\n                            };\n                    }\n                };\n\n                ModelResponse.prototype.then = function then(onNext, onError) {\n                    /* global Promise */\n                    var self = this;\n                    if (!self._promise) {\n                        self._promise = new Promise(function (resolve, reject) {\n                            var rejected = false;\n                            var values = [];\n                            self.subscribe(function (value) {\n                                values[values.length] = value;\n                            }, function (errors) {\n                                rejected = true;\n                                reject(errors);\n                            }, function () {\n                                var value = values;\n                                if (values.length <= 1) {\n                                    value = values[0];\n                                }\n\n                                if (rejected === false) {\n                                    resolve(value);\n                                }\n                            });\n                        });\n                    }\n                    return self._promise.then(onNext, onError);\n                };\n\n                module.exports = ModelResponse;\n            }).call(this, typeof Promise === \"function\" ? Promise : require(156));\n        }, { \"115\": 115, \"156\": 156, \"164\": 164, \"53\": 53 }], 53: [function (require, module, exports) {\n            var noop = require(102);\n\n            /**\n             * A ModelResponseObserver conform to the Observable's Observer contract. It accepts either an Observer or three optional callbacks which correspond to the Observer methods onNext, onError, and onCompleted.\n             * The ModelResponseObserver wraps an Observer to enforce a variety of different invariants including:\n             * 1. onError callback is only called once.\n             * 2. onCompleted callback is only called once.\n             * @constructor ModelResponseObserver\n            */\n            function ModelResponseObserver(onNextOrObserver, onErrorFn, onCompletedFn) {\n                // if callbacks are passed, construct an Observer from them. Create a NOOP function for any missing callbacks.\n                if (!onNextOrObserver || typeof onNextOrObserver !== \"object\") {\n                    this._observer = {\n                        onNext: typeof onNextOrObserver === \"function\" ? onNextOrObserver : noop,\n                        onError: typeof onErrorFn === \"function\" ? onErrorFn : noop,\n                        onCompleted: typeof onCompletedFn === \"function\" ? onCompletedFn : noop\n                    };\n                }\n                // if an Observer is passed\n                else {\n                        this._observer = {\n                            onNext: typeof onNextOrObserver.onNext === \"function\" ? function (value) {\n                                onNextOrObserver.onNext(value);\n                            } : noop,\n                            onError: typeof onNextOrObserver.onError === \"function\" ? function (error) {\n                                onNextOrObserver.onError(error);\n                            } : noop,\n                            onCompleted: typeof onNextOrObserver.onCompleted === \"function\" ? function () {\n                                onNextOrObserver.onCompleted();\n                            } : noop\n                        };\n                    }\n            }\n\n            ModelResponseObserver.prototype = {\n                onNext: function onNext(v) {\n                    if (!this._closed) {\n                        this._observer.onNext(v);\n                    }\n                },\n                onError: function onError(e) {\n                    if (!this._closed) {\n                        this._closed = true;\n                        this._observer.onError(e);\n                    }\n                },\n                onCompleted: function onCompleted() {\n                    if (!this._closed) {\n                        this._closed = true;\n                        this._observer.onCompleted();\n                    }\n                }\n            };\n\n            module.exports = ModelResponseObserver;\n        }, { \"102\": 102 }], 54: [function (require, module, exports) {\n            var ModelResponse = require(52);\n            var checkCacheAndReport = require(55);\n            var getRequestCycle = require(56);\n            var empty = { dispose: function dispose() {} };\n            var collectLru = require(40);\n            var getSize = require(85);\n\n            /**\n             * The get response.  It takes in a model and paths and starts\n             * the request cycle.  It has been optimized for cache first requests\n             * and closures.\n             * @param {Model} model -\n             * @param {Array} paths -\n             * @augments ModelResponse\n             * @private\n             */\n            var GetResponse = module.exports = function GetResponse(model, paths, isJSONGraph, isProgressive, forceCollect) {\n                this.model = model;\n                this.currentRemainingPaths = paths;\n                this.isJSONGraph = isJSONGraph || false;\n                this.isProgressive = isProgressive || false;\n                this.forceCollect = forceCollect || false;\n            };\n\n            GetResponse.prototype = Object.create(ModelResponse.prototype);\n\n            /**\n             * Makes the output of a get response JSONGraph instead of json.\n             * @private\n             */\n            GetResponse.prototype._toJSONG = function _toJSONGraph() {\n                return new GetResponse(this.model, this.currentRemainingPaths, true, this.isProgressive, this.forceCollect);\n            };\n\n            /**\n             * Progressively responding to data in the cache instead of once the whole\n             * operation is complete.\n             * @public\n             */\n            GetResponse.prototype.progressively = function progressively() {\n                return new GetResponse(this.model, this.currentRemainingPaths, this.isJSONGraph, true, this.forceCollect);\n            };\n\n            /**\n             * purely for the purposes of closure creation other than the initial\n             * prototype created closure.\n             *\n             * @private\n             */\n            GetResponse.prototype._subscribe = function _subscribe(observer) {\n                var seed = [{}];\n                var errors = [];\n                var model = this.model;\n                var isJSONG = observer.isJSONG = this.isJSONGraph;\n                var isProgressive = this.isProgressive;\n                var results = checkCacheAndReport(model, this.currentRemainingPaths, observer, isProgressive, isJSONG, seed, errors);\n\n                // If there are no results, finish.\n                if (!results) {\n                    if (this.forceCollect) {\n                        var modelRoot = model._root;\n                        var modelCache = modelRoot.cache;\n                        var currentVersion = modelCache.$_version;\n\n                        collectLru(modelRoot, modelRoot.expired, getSize(modelCache), model._maxSize, model._collectRatio, currentVersion);\n                    }\n                    return empty;\n                }\n\n                // Starts the async request cycle.\n                return getRequestCycle(this, model, results, observer, errors, 1);\n            };\n        }, { \"40\": 40, \"52\": 52, \"55\": 55, \"56\": 56, \"85\": 85 }], 55: [function (require, module, exports) {\n            var gets = require(23);\n            var getWithPathsAsJSONGraph = gets.getWithPathsAsJSONGraph;\n            var getWithPathsAsPathMap = gets.getWithPathsAsPathMap;\n\n            /**\n             * Checks cache for the paths and reports if in progressive mode.  If\n             * there are missing paths then return the cache hit results.\n             *\n             * Return value (`results`) stores missing path information as 3 index-linked arrays:\n             * `requestedMissingPaths` holds requested paths that were not found in cache\n             * `optimizedMissingPaths` holds optimized versions of requested paths\n             * `depthDifferences` holds the difference in length of requested and optimized paths\n             *\n             * Note that requestedMissingPaths is not necessarily the list of paths requested by\n             * user in model.get. It does not contain those paths that were found in\n             * cache. It also breaks some path sets out into separate paths, those which\n             * resolve to different optimized lengths after walking through any references in\n             * cache.\n             * This helps maintain a 1:1 correspondence between requested and optimized missing,\n             * as well as their depth differences (or, length offsets).\n             *\n             * Example: Given cache: `{ lolomo: { 0: $ref('vid'), 1: $ref('a.b.c.d') }}`,\n             * `model.get('lolomo[0..2].name').subscribe()` will result in the following\n             * corresponding values:\n             *    index   requestedMissingPaths   optimizedMissingPaths         depthDifferences\n             *      0     ['lolomo', 0, 'name']   ['vid', 'name']                   1\n             *      1     ['lolomo', 1, 'name']   ['a', 'b', 'c', 'd', 'name']     -2\n             *      2     ['lolomo', 2, 'name']   ['lolomo', 2, 'name']             0\n             *\n             * @param {Model} model - The model that the request was made with.\n             * @param {Array} requestedMissingPaths -\n             * @param {Boolean} progressive -\n             * @param {Boolean} isJSONG -\n             * @param {Function} onNext -\n             * @param {Function} onError -\n             * @param {Function} onCompleted -\n             * @param {Object} seed - The state of the output\n             * @returns {Object} results -\n             *\n             * @private\n             */\n            module.exports = function checkCacheAndReport(model, requestedPaths, observer, progressive, isJSONG, seed, errors) {\n\n                // checks the cache for the data.\n                var results = isJSONG ? getWithPathsAsJSONGraph(model, requestedPaths, seed) : getWithPathsAsPathMap(model, requestedPaths, seed);\n\n                // We are done when there are no missing paths or the model does not\n                // have a dataSource to continue on fetching from.\n                var valueNode = results.values && results.values[0];\n\n                var completed = !results.requestedMissingPaths || !results.requestedMissingPaths.length || !model._source;\n\n                // Copy the errors into the total errors array.\n                if (results.errors) {\n                    var errs = results.errors;\n                    var errorsLength = errors.length;\n                    for (var i = 0, len = errs.length; i < len; ++i, ++errorsLength) {\n                        errors[errorsLength] = errs[i];\n                    }\n                }\n\n                // If there are values to report, then report.\n                // Which are under two conditions:\n                // 1.  This request is progressive\n                //\n                // 2.  The request if finished and the json key off\n                // the valueNode has a value.\n                if (progressive || (progressive && results.hasValues || !progressive) && completed && valueNode !== undefined) {\n                    try {\n                        observer.onNext(valueNode);\n                    } catch (e) {\n                        throw e;\n                    }\n                }\n\n                // We must communicate critical errors from get that are critical\n                // errors such as bound path is broken or this is a JSONGraph request\n                // with a bound path.\n                if (results.criticalError) {\n                    observer.onError(results.criticalError);\n                    return null;\n                }\n\n                // if there are missing paths, then lets return them.\n                if (completed) {\n                    if (errors.length) {\n                        observer.onError(errors);\n                    } else {\n                        observer.onCompleted();\n                    }\n\n                    return null;\n                }\n\n                // Return the results object.\n                return results;\n            };\n        }, { \"23\": 23 }], 56: [function (require, module, exports) {\n            var checkCacheAndReport = require(55);\n            var MaxRetryExceededError = require(12);\n            var fastCat = require(32).fastCat;\n            var collectLru = require(40);\n            var getSize = require(85);\n            var AssignableDisposable = require(49);\n            var InvalidSourceError = require(11);\n\n            /**\n             * The get request cycle for checking the cache and reporting\n             * values.  If there are missing paths then the async request cycle to\n             * the data source is performed until all paths are resolved or max\n             * requests are made.\n             * @param {GetResponse} getResponse -\n             * @param {Model} model - The model that the request was made with.\n             * @param {Object} results -\n             * @param {Function} onNext -\n             * @param {Function} onError -\n             * @param {Function} onCompleted -\n             * @private\n             */\n            module.exports = function getRequestCycle(getResponse, model, results, observer, errors, count) {\n                // we have exceeded the maximum retry limit.\n                if (count > model._maxRetries) {\n                    observer.onError(new MaxRetryExceededError(results.optimizedMissingPaths));\n                    return {\n                        dispose: function dispose() {}\n                    };\n                }\n\n                var requestQueue = model._request;\n                var requestedMissingPaths = results.requestedMissingPaths;\n                var optimizedMissingPaths = results.optimizedMissingPaths;\n                var depthDifferences = results.depthDifferences;\n                var disposable = new AssignableDisposable();\n\n                // We need to prepend the bound path to all requested missing paths and\n                // pass those into the requestQueue.\n                var boundRequestedMissingPaths = [];\n                var boundPath = model._path;\n                var boundPathLength = boundPath.length;\n                if (boundPath.length) {\n                    for (var i = 0, len = requestedMissingPaths.length; i < len; ++i) {\n                        boundRequestedMissingPaths[i] = fastCat(boundPath, requestedMissingPaths[i]);\n                        depthDifferences[i] += boundPathLength;\n                    }\n                }\n\n                // No bound path, no array copy and concat.\n                else {\n                        boundRequestedMissingPaths = requestedMissingPaths;\n                    }\n\n                var currentRequestDisposable = requestQueue.get(boundRequestedMissingPaths, optimizedMissingPaths, depthDifferences, function (err, data, hasInvalidatedResult) {\n                    if (model._treatDataSourceErrorsAsJSONGraphErrors ? err instanceof InvalidSourceError : !!err) {\n                        if (results.hasValues) {\n                            observer.onNext(results.values && results.values[0]);\n                        }\n                        observer.onError(err);\n                        return;\n                    }\n\n                    var nextRequestedMissingPaths;\n                    var nextSeed;\n\n                    // If merging over an existing branch structure with refs has invalidated our intermediate json,\n                    // we want to start over and re-get all requested paths with a fresh seed\n                    if (hasInvalidatedResult) {\n                        nextRequestedMissingPaths = getResponse.currentRemainingPaths;\n                        nextSeed = [{}];\n                    } else {\n                        nextRequestedMissingPaths = requestedMissingPaths;\n                        nextSeed = results.values;\n                    }\n\n                    // Once the request queue finishes, check the cache and bail if\n                    // we can.\n                    var nextResults = checkCacheAndReport(model, nextRequestedMissingPaths, observer, getResponse.isProgressive, getResponse.isJSONGraph, nextSeed, errors);\n\n                    // If there are missing paths coming back form checkCacheAndReport\n                    // the its reported from the core cache check method.\n                    if (nextResults) {\n\n                        // update the which disposable to use.\n                        disposable.currentDisposable = getRequestCycle(getResponse, model, nextResults, observer, errors, count + 1);\n                    }\n\n                    // We have finished.  Since we went to the dataSource, we must\n                    // collect on the cache.\n                    else {\n\n                            var modelRoot = model._root;\n                            var modelCache = modelRoot.cache;\n                            var currentVersion = modelCache.$_version;\n\n                            collectLru(modelRoot, modelRoot.expired, getSize(modelCache), model._maxSize, model._collectRatio, currentVersion);\n                        }\n                });\n                disposable.currentDisposable = currentRequestDisposable;\n                return disposable;\n            };\n        }, { \"11\": 11, \"12\": 12, \"32\": 32, \"40\": 40, \"49\": 49, \"55\": 55, \"85\": 85 }], 57: [function (require, module, exports) {\n            var GetResponse = require(54);\n\n            /**\n             * Performs a get on the cache and if there are missing paths\n             * then the request will be forwarded to the get request cycle.\n             * @private\n             */\n            module.exports = function getWithPaths(paths) {\n                return new GetResponse(this, paths);\n            };\n        }, { \"54\": 54 }], 58: [function (require, module, exports) {\n            var pathSyntax = require(134);\n            var ModelResponse = require(52);\n            var GET_VALID_INPUT = require(59);\n            var validateInput = require(113);\n            var GetResponse = require(54);\n\n            /**\n             * Performs a get on the cache and if there are missing paths\n             * then the request will be forwarded to the get request cycle.\n             * @private\n             */\n            module.exports = function get() {\n                // Validates the input.  If the input is not pathSets or strings then we\n                // will onError.\n                var out = validateInput(arguments, GET_VALID_INPUT, \"get\");\n                if (out !== true) {\n                    return new ModelResponse(function (o) {\n                        o.onError(out);\n                    });\n                }\n\n                var paths = pathSyntax.fromPathsOrPathValues(arguments);\n                return new GetResponse(this, paths);\n            };\n        }, { \"113\": 113, \"134\": 134, \"52\": 52, \"54\": 54, \"59\": 59 }], 59: [function (require, module, exports) {\n            module.exports = {\n                path: true,\n                pathSyntax: true\n            };\n        }, {}], 60: [function (require, module, exports) {\n            var toTree = require(145).toTree;\n            var ModelResponse = require(52);\n\n            function ObserveResponse(model, paths) {\n                this.model = model;\n                this.paths = paths;\n            }\n\n            ObserveResponse.prototype = Object.create(ModelResponse.prototype);\n\n            ObserveResponse.prototype._subscribe = function _subscribe(observer) {\n                var observerId = uniqueId();\n                var pathObservers = this.model._root._pathObservers;\n                pathObservers.push({\n                    id: observerId,\n                    observer: observer,\n                    paths: this.paths,\n                    pathMap: toTree(this.paths)\n                });\n                return {\n                    dispose: function dispose() {\n                        var pathObs = pathObservers.find(function (po) {\n                            return po.id === observerId;\n                        });\n                        if (!pathObs) {\n                            return;\n                        }\n                        pathObservers.splice(pathObservers.indexOf(pathObs), 1);\n                    }\n                };\n            };\n\n            var autoIncrementingId = 0;\n            function uniqueId() {\n                return autoIncrementingId++;\n            }\n\n            module.exports = ObserveResponse;\n        }, { \"145\": 145, \"52\": 52 }], 61: [function (require, module, exports) {\n            var pathSyntax = require(134);\n\n            var validateInput = require(113);\n            var GET_VALID_INPUT = require(59);\n            var ObserveResponse = require(60);\n            var ModelResponse = require(52);\n\n            module.exports = function observe() {\n                // Validates the input. If the input is not pathSets or strings then we\n                // will onError.\n                var out = validateInput(arguments, GET_VALID_INPUT, \"observe\");\n                if (out !== true) {\n                    return new ModelResponse(function (o) {\n                        o.onError(out);\n                    });\n                }\n\n                var paths = pathSyntax.fromPathsOrPathValues(arguments);\n                return new ObserveResponse(this, paths);\n            };\n        }, { \"113\": 113, \"134\": 134, \"52\": 52, \"59\": 59, \"60\": 60 }], 62: [function (require, module, exports) {\n            var ModelResponse = require(52);\n            var pathSyntax = require(134);\n            var isArray = Array.isArray;\n            var isPathValue = require(98);\n            var isJSONGraphEnvelope = require(96);\n            var isJSONEnvelope = require(95);\n            var setRequestCycle = require(65);\n\n            /**\n             *  The set response is responsible for doing the request loop for the set\n             * operation and subscribing to the follow up get.\n             *\n             * The constructors job is to parse out the arguments and put them in their\n             * groups.  The following subscribe will do the actual cache set and dataSource\n             * operation remoting.\n             *\n             * @param {Model} model -\n             * @param {Array} args - The array of arguments that can be JSONGraph, JSON, or\n             * pathValues.\n             * @param {Boolean} isJSONGraph - if the request is a jsonGraph output format.\n             * @param {Boolean} isProgressive - progressive output.\n             * @augments ModelResponse\n             * @private\n             */\n            var SetResponse = module.exports = function SetResponse(model, args, isJSONGraph, isProgressive) {\n\n                // The response properties.\n                this._model = model;\n                this._isJSONGraph = isJSONGraph || false;\n                this._isProgressive = isProgressive || false;\n                this._initialArgs = args;\n                this._value = [{}];\n\n                var groups = [];\n                var group, groupType;\n                var argIndex = -1;\n                var argCount = args.length;\n\n                // Validation of arguments have been moved out of this function.\n                while (++argIndex < argCount) {\n                    var arg = args[argIndex];\n                    var argType;\n                    if (isArray(arg) || typeof arg === \"string\") {\n                        arg = pathSyntax.fromPath(arg);\n                        argType = \"PathValues\";\n                    } else if (isPathValue(arg)) {\n                        arg.path = pathSyntax.fromPath(arg.path);\n                        argType = \"PathValues\";\n                    } else if (isJSONGraphEnvelope(arg)) {\n                        argType = \"JSONGs\";\n                    } else if (isJSONEnvelope(arg)) {\n                        argType = \"PathMaps\";\n                    }\n\n                    if (groupType !== argType) {\n                        groupType = argType;\n                        group = {\n                            inputType: argType,\n                            arguments: []\n                        };\n                        groups.push(group);\n                    }\n\n                    group.arguments.push(arg);\n                }\n\n                this._groups = groups;\n            };\n\n            SetResponse.prototype = Object.create(ModelResponse.prototype);\n\n            /**\n             * The subscribe function will setup the remoting of the operation and cache\n             * setting.\n             *\n             * @private\n             */\n            SetResponse.prototype._subscribe = function _subscribe(observer) {\n                var groups = this._groups;\n                var model = this._model;\n                var isJSONGraph = this._isJSONGraph;\n                var isProgressive = this._isProgressive;\n\n                // Starts the async request cycle.\n                return setRequestCycle(model, observer, groups, isJSONGraph, isProgressive, 0);\n            };\n\n            /**\n             * Makes the output of a get response JSONGraph instead of json.\n             * @private\n             */\n            SetResponse.prototype._toJSONG = function _toJSONGraph() {\n                return new SetResponse(this._model, this._initialArgs, true, this._isProgressive);\n            };\n\n            /**\n             * Progressively responding to data in the cache instead of once the whole\n             * operation is complete.\n             * @public\n             */\n            SetResponse.prototype.progressively = function progressively() {\n                return new SetResponse(this._model, this._initialArgs, this._isJSONGraph, true);\n            };\n        }, { \"134\": 134, \"52\": 52, \"65\": 65, \"95\": 95, \"96\": 96, \"98\": 98 }], 63: [function (require, module, exports) {\n            var setValidInput = require(66);\n            var validateInput = require(113);\n            var SetResponse = require(62);\n            var ModelResponse = require(52);\n\n            module.exports = function set() {\n                var out = validateInput(arguments, setValidInput, \"set\");\n                if (out !== true) {\n                    return new ModelResponse(function (o) {\n                        o.onError(out);\n                    });\n                }\n\n                var argsIdx = -1;\n                var argsLen = arguments.length;\n                var args = [];\n                while (++argsIdx < argsLen) {\n                    args[argsIdx] = arguments[argsIdx];\n                }\n                return new SetResponse(this, args);\n            };\n        }, { \"113\": 113, \"52\": 52, \"62\": 62, \"66\": 66 }], 64: [function (require, module, exports) {\n            var arrayFlatMap = require(77);\n\n            /**\n             * Takes the groups that are created in the SetResponse constructor and sets\n             * them into the cache.\n             */\n            module.exports = function setGroupsIntoCache(model, groups) {\n                var modelRoot = model._root;\n                var errorSelector = modelRoot.errorSelector;\n                var groupIndex = -1;\n                var groupCount = groups.length;\n                var requestedPaths = [];\n                var optimizedPaths = [];\n                var returnValue = {\n                    requestedPaths: requestedPaths,\n                    optimizedPaths: optimizedPaths\n                };\n\n                // Takes each of the groups and normalizes their input into\n                // requested paths and optimized paths.\n                while (++groupIndex < groupCount) {\n\n                    var group = groups[groupIndex];\n                    var inputType = group.inputType;\n                    var methodArgs = group.arguments;\n\n                    if (methodArgs.length > 0) {\n                        var operationName = \"_set\" + inputType;\n                        var operationFunc = model[operationName];\n                        var successfulPaths = operationFunc(model, methodArgs, null, errorSelector);\n\n                        optimizedPaths.push.apply(optimizedPaths, successfulPaths[1]);\n\n                        if (inputType === \"PathValues\") {\n                            requestedPaths.push.apply(requestedPaths, methodArgs.map(pluckPath));\n                        } else if (inputType === \"JSONGs\") {\n                            requestedPaths.push.apply(requestedPaths, arrayFlatMap(methodArgs, pluckEnvelopePaths));\n                        } else {\n                            requestedPaths.push.apply(requestedPaths, successfulPaths[0]);\n                        }\n                    }\n                }\n\n                return returnValue;\n            };\n\n            function pluckPath(pathValue) {\n                return pathValue.path;\n            }\n\n            function pluckEnvelopePaths(jsonGraphEnvelope) {\n                return jsonGraphEnvelope.paths;\n            }\n        }, { \"77\": 77 }], 65: [function (require, module, exports) {\n            var emptyArray = [];\n            var AssignableDisposable = require(49);\n            var GetResponse = require(54);\n            var setGroupsIntoCache = require(64);\n            var getWithPathsAsPathMap = require(23).getWithPathsAsPathMap;\n            var InvalidSourceError = require(11);\n            var MaxRetryExceededError = require(12);\n\n            /**\n             * The request cycle for set.  This is responsible for requesting to dataSource\n             * and allowing disposing inflight requests.\n             */\n            module.exports = function setRequestCycle(model, observer, groups, isJSONGraph, isProgressive, count) {\n                var requestedAndOptimizedPaths = setGroupsIntoCache(model, groups);\n                var optimizedPaths = requestedAndOptimizedPaths.optimizedPaths;\n                var requestedPaths = requestedAndOptimizedPaths.requestedPaths;\n\n                // we have exceeded the maximum retry limit.\n                if (count === model._maxRetries) {\n                    observer.onError(new MaxRetryExceededError(optimizedPaths));\n                    return {\n                        dispose: function dispose() {}\n                    };\n                }\n\n                var isMaster = model._source === undefined;\n\n                // Local set only.  We perform a follow up get.  If performance is ever\n                // a requirement simply requiring in checkCacheAndReport and use get request\n                // internals.  Figured this is more \"pure\".\n                if (isMaster) {\n                    return subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph, isProgressive);\n                }\n\n                // Progressively output the data from the first set.\n                var prevVersion;\n                if (isProgressive) {\n                    var results = getWithPathsAsPathMap(model, requestedPaths, [{}]);\n                    if (results.criticalError) {\n                        observer.onError(results.criticalError);\n                        return null;\n                    }\n                    observer.onNext(results.values[0]);\n\n                    prevVersion = model._root.cache.$_version;\n                }\n\n                var currentJSONGraph = getJSONGraph(model, optimizedPaths);\n                var disposable = new AssignableDisposable();\n\n                // Sends out the setRequest.  The Queue will call the callback with the\n                // JSONGraph envelope / error.\n                var requestDisposable = model._request.\n                // TODO: There is error handling that has not been addressed yet.\n\n                // If disposed before this point then the sendSetRequest will not\n                // further any callbacks.  Therefore, if we are at this spot, we are\n                // not disposed yet.\n                set(currentJSONGraph, function (error, jsonGraphEnv) {\n                    if (error instanceof InvalidSourceError) {\n                        observer.onError(error);\n                        return;\n                    }\n\n                    // TODO: This seems like there are errors with this approach, but\n                    // for sanity sake I am going to keep this logic in here until a\n                    // rethink can be done.\n                    var isCompleted = false;\n                    if (error || optimizedPaths.length === jsonGraphEnv.paths.length) {\n                        isCompleted = true;\n                    }\n\n                    // If we're in progressive mode and nothing changed in the meantime, we're done\n                    if (isProgressive) {\n                        var nextVersion = model._root.cache.$_version;\n                        var versionChanged = nextVersion !== prevVersion;\n\n                        if (!versionChanged) {\n                            observer.onCompleted();\n                            return;\n                        }\n                    }\n\n                    // Happy case.  One request to the dataSource will fulfill the\n                    // required paths.\n                    if (isCompleted) {\n                        disposable.currentDisposable = subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph, isProgressive);\n                    }\n\n                    // TODO: The unhappy case.  I am unsure how this can even be\n                    // achieved.\n                    else {\n                            // We need to restart the setRequestCycle.\n                            setRequestCycle(model, observer, groups, isJSONGraph, isProgressive, count + 1);\n                        }\n                });\n\n                // Sets the current disposable as the requestDisposable.\n                disposable.currentDisposable = requestDisposable;\n\n                return disposable;\n            };\n\n            function getJSONGraph(model, optimizedPaths) {\n                var boundPath = model._path;\n                var envelope = {};\n                model._path = emptyArray;\n                model._getPathValuesAsJSONG(model._materialize().withoutDataSource(), optimizedPaths, [envelope]);\n                model._path = boundPath;\n\n                return envelope;\n            }\n\n            function subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph, isProgressive) {\n\n                // Creates a new response and subscribes to it with the original observer.\n                // Also sets forceCollect to true, incase the operation is synchronous and\n                // exceeds the cache limit size\n                var response = new GetResponse(model, requestedPaths, isJSONGraph, isProgressive, true);\n                return response.subscribe(observer);\n            }\n        }, { \"11\": 11, \"12\": 12, \"23\": 23, \"49\": 49, \"54\": 54, \"64\": 64 }], 66: [function (require, module, exports) {\n            module.exports = {\n                pathValue: true,\n                pathSyntax: true,\n                json: true,\n                jsonGraph: true\n            };\n        }, {}], 67: [function (require, module, exports) {\n            var asap = require(123);\n            var empty = { dispose: function dispose() {} };\n\n            function ASAPScheduler() {}\n\n            ASAPScheduler.prototype.schedule = function schedule(action) {\n                asap(action);\n                return empty;\n            };\n\n            ASAPScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n                var self = this;\n                asap(function () {\n                    action(self, state);\n                });\n                return empty;\n            };\n\n            module.exports = ASAPScheduler;\n        }, { \"123\": 123 }], 68: [function (require, module, exports) {\n            var empty = { dispose: function dispose() {} };\n\n            function ImmediateScheduler() {}\n\n            ImmediateScheduler.prototype.schedule = function schedule(action) {\n                action();\n                return empty;\n            };\n\n            ImmediateScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n                action(this, state);\n                return empty;\n            };\n\n            module.exports = ImmediateScheduler;\n        }, {}], 69: [function (require, module, exports) {\n            function TimeoutScheduler(delay) {\n                this.delay = delay;\n            }\n\n            var TimerDisposable = function TimerDisposable(id) {\n                this.id = id;\n                this.disposed = false;\n            };\n\n            TimeoutScheduler.prototype.schedule = function schedule(action) {\n                var id = setTimeout(action, this.delay);\n                return new TimerDisposable(id);\n            };\n\n            TimeoutScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n                var self = this;\n                var id = setTimeout(function () {\n                    action(self, state);\n                }, this.delay);\n                return new TimerDisposable(id);\n            };\n\n            TimerDisposable.prototype.dispose = function () {\n                if (this.disposed) {\n                    return;\n                }\n\n                clearTimeout(this.id);\n                this.disposed = true;\n            };\n\n            module.exports = TimeoutScheduler;\n        }, {}], 70: [function (require, module, exports) {\n            var toTree = require(145).toTree;\n\n            var createHardlink = require(81);\n            var $ref = require(118);\n\n            var isExpired = require(91);\n            var isFunction = require(93);\n            var isPrimitive = require(99);\n            var expireNode = require(83);\n            var iterateKeySet = require(145).iterateKeySet;\n            var incrementVersion = require(89);\n            var mergeJSONGraphNode = require(100);\n            var NullInPathError = require(13);\n\n            /**\n             * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n             * @function\n             * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n             * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n             * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n             */\n\n            module.exports = function setJSONGraphs(model, jsonGraphEnvelopes, x, errorSelector, comparator, replacedPaths) {\n\n                var modelRoot = model._root;\n                var lru = modelRoot;\n                var expired = modelRoot.expired;\n                var version = incrementVersion();\n                var cache = modelRoot.cache;\n                var initialVersion = cache.$_version;\n\n                var requestedPath = [];\n                var optimizedPath = [];\n                var requestedPaths = [];\n                var optimizedPaths = [];\n                var jsonGraphEnvelopeIndex = -1;\n                var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n                while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n                    var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n                    var paths = jsonGraphEnvelope.paths;\n                    var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n                    var pathIndex = -1;\n                    var pathCount = paths.length;\n\n                    while (++pathIndex < pathCount) {\n\n                        var path = paths[pathIndex];\n                        optimizedPath.index = 0;\n\n                        setJSONGraphPathSet(path, 0, cache, cache, cache, jsonGraph, jsonGraph, jsonGraph, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n                    }\n                }\n\n                if (modelRoot.hasObservers()) {\n                    var affectedPaths = jsonGraphEnvelopes.reduce(function (allPaths, envelope) {\n                        return allPaths.concat(envelope.paths);\n                    }, []);\n                    var affectedPathMap = toTree(affectedPaths);\n                    modelRoot.onObserve(affectedPaths, affectedPathMap);\n                }\n\n                var newVersion = cache.$_version;\n                var rootChangeHandler = modelRoot.onChange;\n\n                if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n                    rootChangeHandler();\n                }\n\n                return [requestedPaths, optimizedPaths];\n            };\n\n            /* eslint-disable no-constant-condition */\n            function setJSONGraphPathSet(path, depth, root, parent, node, messageRoot, messageParent, message, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n                var note = {};\n                var branch = depth < path.length - 1;\n                var keySet = path[depth];\n                var key = iterateKeySet(keySet, note);\n                var optimizedIndex = optimizedPath.index;\n\n                do {\n\n                    requestedPath.depth = depth;\n\n                    var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n\n                    requestedPath[depth] = key;\n                    requestedPath.index = depth;\n                    optimizedPath[optimizedPath.index++] = key;\n                    var nextNode = results[0];\n                    var nextParent = results[1];\n                    if (nextNode) {\n                        if (branch) {\n                            setJSONGraphPathSet(path, depth + 1, root, nextParent, nextNode, messageRoot, results[3], results[2], requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n                        } else {\n                            requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                            optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n                        }\n                    }\n                    key = iterateKeySet(keySet, note);\n                    if (note.done) {\n                        break;\n                    }\n                    optimizedPath.index = optimizedIndex;\n                } while (true);\n            }\n            /* eslint-enable */\n\n            function setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n                var reference = node.value;\n                optimizedPath.splice(0, optimizedPath.length);\n                optimizedPath.push.apply(optimizedPath, reference);\n\n                if (isExpired(node)) {\n                    optimizedPath.index = reference.length;\n                    expireNode(node, expired, lru);\n                    return [undefined, root, message, messageRoot];\n                }\n\n                var index = 0;\n                var container = node;\n                var count = reference.length - 1;\n                var parent = node = root;\n                var messageParent = message = messageRoot;\n\n                do {\n                    var key = reference[index];\n                    var branch = index < count;\n                    optimizedPath.index = index;\n\n                    var results = setNode(root, parent, node, messageRoot, messageParent, message, key, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n                    node = results[0];\n                    if (isPrimitive(node)) {\n                        optimizedPath.index = index;\n                        return results;\n                    }\n                    parent = results[1];\n                    message = results[2];\n                    messageParent = results[3];\n                } while (index++ < count);\n\n                optimizedPath.index = index;\n\n                if (container.$_context !== node) {\n                    createHardlink(container, node);\n                }\n\n                return [node, parent, message, messageParent];\n            }\n\n            function setNode(root, parent, node, messageRoot, messageParent, message, key, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n                var type = node.$type;\n\n                while (type === $ref) {\n\n                    var results = setReference(root, node, messageRoot, message, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n\n                    node = results[0];\n\n                    if (isPrimitive(node)) {\n                        return results;\n                    }\n\n                    parent = results[1];\n                    message = results[2];\n                    messageParent = results[3];\n                    type = node.$type;\n                }\n\n                if (type !== void 0) {\n                    return [node, parent, message, messageParent];\n                }\n\n                if (key == null) {\n                    if (branch) {\n                        throw new NullInPathError();\n                    } else if (node) {\n                        key = node.$_key;\n                    }\n                } else {\n                    parent = node;\n                    messageParent = message;\n                    node = parent[key];\n                    message = messageParent && messageParent[key];\n                }\n\n                node = mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n\n                return [node, parent, message, messageParent];\n            }\n        }, { \"100\": 100, \"118\": 118, \"13\": 13, \"145\": 145, \"81\": 81, \"83\": 83, \"89\": 89, \"91\": 91, \"93\": 93, \"99\": 99 }], 71: [function (require, module, exports) {\n            var pathUtils = require(145);\n            var toTree = pathUtils.toTree;\n            var toPaths = pathUtils.toPaths;\n\n            var createHardlink = require(81);\n            var __prefix = require(37);\n            var $ref = require(118);\n\n            var getBoundValue = require(17);\n\n            var isArray = Array.isArray;\n            var hasOwn = require(88);\n            var isObject = require(97);\n            var isExpired = require(92);\n            var isFunction = require(93);\n            var isPrimitive = require(99);\n            var expireNode = require(83);\n            var incrementVersion = require(89);\n            var mergeValueOrInsertBranch = require(101);\n            var NullInPathError = require(13);\n\n            /**\n             * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n             * @function\n             * @param {Object} model - the Model for which to insert the PathMaps.\n             * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n             * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n             */\n\n            module.exports = function setPathMaps(model, pathMapEnvelopes, x, errorSelector, comparator) {\n\n                var modelRoot = model._root;\n                var lru = modelRoot;\n                var expired = modelRoot.expired;\n                var version = incrementVersion();\n                var bound = model._path;\n                var cache = modelRoot.cache;\n                var node = bound.length ? getBoundValue(model, bound).value : cache;\n                var parent = node.$_parent || cache;\n                var initialVersion = cache.$_version;\n\n                var requestedPath = [];\n                var requestedPaths = [];\n                var optimizedPaths = [];\n                var optimizedIndex = bound.length;\n                var pathMapIndex = -1;\n                var pathMapCount = pathMapEnvelopes.length;\n\n                while (++pathMapIndex < pathMapCount) {\n\n                    var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n                    var optimizedPath = bound.slice(0);\n                    optimizedPath.index = optimizedIndex;\n\n                    setPathMap(pathMapEnvelope.json, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n                }\n\n                if (modelRoot.hasObservers()) {\n                    var affectedPaths = pathMapEnvelopes.reduce(function (allPaths, envelope) {\n                        return allPaths.concat(toPaths(envelope.json));\n                    }, []);\n                    var affectedPathMap = toTree(affectedPaths);\n                    modelRoot.onObserve(affectedPaths, affectedPathMap);\n                }\n\n                var newVersion = cache.$_version;\n                var rootChangeHandler = modelRoot.onChange;\n\n                if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n                    rootChangeHandler();\n                }\n\n                return [requestedPaths, optimizedPaths];\n            };\n\n            /* eslint-disable no-constant-condition */\n            function setPathMap(pathMap, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n                var keys = getKeys(pathMap);\n\n                if (keys && keys.length) {\n\n                    var keyIndex = 0;\n                    var keyCount = keys.length;\n                    var optimizedIndex = optimizedPath.index;\n\n                    do {\n                        var key = keys[keyIndex];\n                        var child = pathMap[key];\n                        var branch = isObject(child) && !child.$type;\n\n                        requestedPath.depth = depth;\n\n                        var results = setNode(root, parent, node, key, child, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n                        requestedPath[depth] = key;\n                        requestedPath.index = depth;\n\n                        optimizedPath[optimizedPath.index++] = key;\n                        var nextNode = results[0];\n                        var nextParent = results[1];\n                        if (nextNode) {\n                            if (branch) {\n                                setPathMap(child, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n                            } else {\n                                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                                optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n                            }\n                        }\n                        if (++keyIndex >= keyCount) {\n                            break;\n                        }\n                        optimizedPath.index = optimizedIndex;\n                    } while (true);\n                }\n            }\n            /* eslint-enable */\n\n            function setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n                var reference = node.value;\n                optimizedPath.splice(0, optimizedPath.length);\n                optimizedPath.push.apply(optimizedPath, reference);\n\n                if (isExpired(node)) {\n                    optimizedPath.index = reference.length;\n                    expireNode(node, expired, lru);\n                    return [undefined, root];\n                }\n\n                var container = node;\n                var parent = root;\n\n                node = node.$_context;\n\n                if (node != null) {\n                    parent = node.$_parent || root;\n                    optimizedPath.index = reference.length;\n                } else {\n\n                    var index = 0;\n                    var count = reference.length - 1;\n                    optimizedPath.index = index;\n\n                    parent = node = root;\n\n                    do {\n                        var key = reference[index];\n                        var branch = index < count;\n                        var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n                        node = results[0];\n                        if (isPrimitive(node)) {\n                            optimizedPath.index = index;\n                            return results;\n                        }\n                        parent = results[1];\n                    } while (index++ < count);\n\n                    optimizedPath.index = index;\n\n                    if (container.$_context !== node) {\n                        createHardlink(container, node);\n                    }\n                }\n\n                return [node, parent];\n            }\n\n            function setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector) {\n\n                var type = node.$type;\n\n                while (type === $ref) {\n\n                    var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n                    node = results[0];\n\n                    if (isPrimitive(node)) {\n                        return results;\n                    }\n\n                    parent = results[1];\n                    type = node && node.$type;\n                }\n\n                if (type !== void 0) {\n                    return [node, parent];\n                }\n\n                if (key == null) {\n                    if (branch) {\n                        throw new NullInPathError();\n                    } else if (node) {\n                        key = node.$_key;\n                    }\n                } else {\n                    parent = node;\n                    node = parent[key];\n                }\n\n                node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n\n                return [node, parent];\n            }\n\n            function getKeys(pathMap) {\n\n                if (isObject(pathMap) && !pathMap.$type) {\n                    var keys = [];\n                    var itr = 0;\n                    if (isArray(pathMap)) {\n                        keys[itr++] = \"length\";\n                    }\n                    for (var key in pathMap) {\n                        if (key[0] === __prefix || !hasOwn(pathMap, key)) {\n                            continue;\n                        }\n                        keys[itr++] = key;\n                    }\n                    return keys;\n                }\n\n                return void 0;\n            }\n        }, { \"101\": 101, \"118\": 118, \"13\": 13, \"145\": 145, \"17\": 17, \"37\": 37, \"81\": 81, \"83\": 83, \"88\": 88, \"89\": 89, \"92\": 92, \"93\": 93, \"97\": 97, \"99\": 99 }], 72: [function (require, module, exports) {\n            var toTree = require(145).toTree;\n\n            var createHardlink = require(81);\n            var $ref = require(118);\n\n            var getBoundValue = require(17);\n\n            var isExpired = require(92);\n            var isFunction = require(93);\n            var isPrimitive = require(99);\n            var expireNode = require(83);\n            var iterateKeySet = require(145).iterateKeySet;\n            var incrementVersion = require(89);\n            var mergeValueOrInsertBranch = require(101);\n            var NullInPathError = require(13);\n\n            /**\n             * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n             * @function\n             * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n             * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n             * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n             */\n\n            module.exports = function setPathValues(model, pathValues, x, errorSelector, comparator) {\n\n                var modelRoot = model._root;\n                var lru = modelRoot;\n                var expired = modelRoot.expired;\n                var version = incrementVersion();\n                var bound = model._path;\n                var cache = modelRoot.cache;\n                var node = bound.length ? getBoundValue(model, bound).value : cache;\n                var parent = node.$_parent || cache;\n                var initialVersion = cache.$_version;\n\n                var requestedPath = [];\n                var requestedPaths = [];\n                var optimizedPaths = [];\n                var optimizedIndex = bound.length;\n                var pathValueIndex = -1;\n                var pathValueCount = pathValues.length;\n\n                while (++pathValueIndex < pathValueCount) {\n\n                    var pathValue = pathValues[pathValueIndex];\n                    var path = pathValue.path;\n                    var value = pathValue.value;\n                    var optimizedPath = bound.slice(0);\n                    optimizedPath.index = optimizedIndex;\n\n                    setPathSet(value, path, 0, cache, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n                }\n\n                if (modelRoot.hasObservers()) {\n                    var affectedPaths = pathValues.map(function (pv) {\n                        return pv.path;\n                    });\n                    var affectedPathMap = toTree(affectedPaths);\n                    modelRoot.onObserve(affectedPaths, affectedPathMap);\n                }\n\n                var newVersion = cache.$_version;\n                var rootChangeHandler = modelRoot.onChange;\n\n                if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n                    rootChangeHandler();\n                }\n\n                return [requestedPaths, optimizedPaths];\n            };\n\n            /* eslint-disable no-constant-condition */\n            function setPathSet(value, path, depth, root, parent, node, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n                var note = {};\n                var branch = depth < path.length - 1;\n                var keySet = path[depth];\n                var key = iterateKeySet(keySet, note);\n                var optimizedIndex = optimizedPath.index;\n\n                do {\n\n                    requestedPath.depth = depth;\n\n                    var results = setNode(root, parent, node, key, value, branch, false, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n                    requestedPath[depth] = key;\n                    requestedPath.index = depth;\n                    optimizedPath[optimizedPath.index++] = key;\n                    var nextNode = results[0];\n                    var nextParent = results[1];\n                    if (nextNode) {\n                        if (branch) {\n                            setPathSet(value, path, depth + 1, root, nextParent, nextNode, requestedPaths, optimizedPaths, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector);\n                        } else {\n                            requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                            optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n                        }\n                    }\n                    key = iterateKeySet(keySet, note);\n                    if (note.done) {\n                        break;\n                    }\n                    optimizedPath.index = optimizedIndex;\n                } while (true);\n            }\n            /* eslint-enable */\n\n            function setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n                var reference = node.value;\n                optimizedPath.splice(0, optimizedPath.length);\n                optimizedPath.push.apply(optimizedPath, reference);\n\n                if (isExpired(node)) {\n                    optimizedPath.index = reference.length;\n                    expireNode(node, expired, lru);\n                    return [undefined, root];\n                }\n\n                var container = node;\n                var parent = root;\n\n                node = node.$_context;\n\n                if (node != null) {\n                    parent = node.$_parent || root;\n                    optimizedPath.index = reference.length;\n                } else {\n\n                    var index = 0;\n                    var count = reference.length - 1;\n\n                    parent = node = root;\n\n                    do {\n                        var key = reference[index];\n                        var branch = index < count;\n                        optimizedPath.index = index;\n\n                        var results = setNode(root, parent, node, key, value, branch, true, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n                        node = results[0];\n                        if (isPrimitive(node)) {\n                            optimizedPath.index = index;\n                            return results;\n                        }\n                        parent = results[1];\n                    } while (index++ < count);\n\n                    optimizedPath.index = index;\n\n                    if (container.$_context !== node) {\n                        createHardlink(container, node);\n                    }\n                }\n\n                return [node, parent];\n            }\n\n            function setNode(root, parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n                var type = node.$type;\n\n                while (type === $ref) {\n\n                    var results = setReference(value, root, node, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n\n                    node = results[0];\n\n                    if (isPrimitive(node)) {\n                        return results;\n                    }\n\n                    parent = results[1];\n                    type = node.$type;\n                }\n\n                if (branch && type !== void 0) {\n                    return [node, parent];\n                }\n\n                if (key == null) {\n                    if (branch) {\n                        throw new NullInPathError();\n                    } else if (node) {\n                        key = node.$_key;\n                    }\n                } else {\n                    parent = node;\n                    node = parent[key];\n                }\n\n                node = mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths);\n\n                return [node, parent];\n            }\n        }, { \"101\": 101, \"118\": 118, \"13\": 13, \"145\": 145, \"17\": 17, \"81\": 81, \"83\": 83, \"89\": 89, \"92\": 92, \"93\": 93, \"99\": 99 }], 73: [function (require, module, exports) {\n            var jsong = require(130);\n            var ModelResponse = require(52);\n            var isPathValue = require(98);\n\n            module.exports = function setValue(pathArg, valueArg) {\n                var value = isPathValue(pathArg) ? pathArg : jsong.pathValue(pathArg, valueArg);\n                var pathIdx = 0;\n                var path = value.path;\n                var pathLen = path.length;\n                while (++pathIdx < pathLen) {\n                    if (typeof path[pathIdx] === \"object\") {\n                        /* eslint-disable no-loop-func */\n                        return new ModelResponse(function (o) {\n                            o.onError(new Error(\"Paths must be simple paths\"));\n                        });\n                        /* eslint-enable no-loop-func */\n                    }\n                }\n                var self = this;\n                return new ModelResponse(function (obs) {\n                    return self.set(value).subscribe(function (data) {\n                        var curr = data.json;\n                        var depth = -1;\n                        var length = path.length;\n\n                        while (curr && ++depth < length) {\n                            curr = curr[path[depth]];\n                        }\n                        obs.onNext(curr);\n                    }, function (err) {\n                        obs.onError(err);\n                    }, function () {\n                        obs.onCompleted();\n                    });\n                });\n            };\n        }, { \"130\": 130, \"52\": 52, \"98\": 98 }], 74: [function (require, module, exports) {\n            var pathSyntax = require(134);\n            var isPathValue = require(98);\n            var setPathValues = require(72);\n\n            module.exports = function setValueSync(pathArg, valueArg, errorSelectorArg, comparatorArg) {\n\n                var path = pathSyntax.fromPath(pathArg);\n                var value = valueArg;\n                var errorSelector = errorSelectorArg;\n                // XXX comparator is never used.\n                var comparator = comparatorArg;\n\n                if (isPathValue(path)) {\n                    comparator = errorSelector;\n                    errorSelector = value;\n                    value = path;\n                } else {\n                    value = {\n                        path: path,\n                        value: value\n                    };\n                }\n\n                if (isPathValue(value) === false) {\n                    throw new Error(\"Model#setValueSync must be called with an Array path.\");\n                }\n\n                if (typeof errorSelector !== \"function\") {\n                    errorSelector = this._root._errorSelector;\n                }\n\n                if (typeof comparator !== \"function\") {\n                    comparator = this._root._comparator;\n                }\n\n                this._syncCheck(\"setValueSync\");\n                setPathValues(this, [value]);\n                return this._getValueSync(value.path);\n            };\n        }, { \"134\": 134, \"72\": 72, \"98\": 98 }], 75: [function (require, module, exports) {\n            module.exports = function arrayClone(array) {\n                if (!array) {\n                    return array;\n                }\n                var i = -1;\n                var n = array.length;\n                var array2 = [];\n                while (++i < n) {\n                    array2[i] = array[i];\n                }\n                return array2;\n            };\n        }, {}], 76: [function (require, module, exports) {\n            module.exports = function arrayConcat(array, other) {\n                if (!array) {\n                    return other;\n                }\n                var i = -1,\n                    j = -1;\n                var n = array.length;\n                var m = other.length;\n                var array2 = new Array(n + m);\n                while (++i < n) {\n                    array2[i] = array[i];\n                }\n                while (++j < m) {\n                    array2[i++] = other[j];\n                }\n                return array2;\n            };\n        }, {}], 77: [function (require, module, exports) {\n            module.exports = function arrayFlatMap(array, selector) {\n                var index = -1;\n                var i = -1;\n                var n = array.length;\n                var array2 = [];\n                while (++i < n) {\n                    var array3 = selector(array[i], i, array);\n                    var j = -1;\n                    var k = array3.length;\n                    while (++j < k) {\n                        array2[++index] = array3[j];\n                    }\n                }\n                return array2;\n            };\n        }, {}], 78: [function (require, module, exports) {\n            module.exports = function arrayMap(array, selector) {\n                var i = -1;\n                var n = array.length;\n                var array2 = new Array(n);\n                while (++i < n) {\n                    array2[i] = selector(array[i], i, array);\n                }\n                return array2;\n            };\n        }, {}], 79: [function (require, module, exports) {\n            module.exports = function arraySlice(array, indexArg, endArg) {\n                var index = indexArg || 0;\n                var i = -1;\n                var n = array.length - index;\n\n                if (n < 0) {\n                    n = 0;\n                }\n\n                if (endArg > 0 && n > endArg) {\n                    n = endArg;\n                }\n\n                var array2 = new Array(n);\n                while (++i < n) {\n                    array2[i] = array[i + index];\n                }\n                return array2;\n            };\n        }, {}], 80: [function (require, module, exports) {\n            var privatePrefix = require(35);\n            var hasOwn = require(88);\n            var isArray = Array.isArray;\n            var isObject = require(97);\n\n            module.exports = function clone(value) {\n                var dest = value;\n                if (isObject(dest)) {\n                    dest = isArray(value) ? [] : {};\n                    var src = value;\n                    for (var key in src) {\n                        if (key.substr(0, 2) === privatePrefix || !hasOwn(src, key)) {\n                            continue;\n                        }\n                        dest[key] = src[key];\n                    }\n                }\n                return dest;\n            };\n        }, { \"35\": 35, \"88\": 88, \"97\": 97 }], 81: [function (require, module, exports) {\n            var __ref = require(36);\n\n            module.exports = function createHardlink(from, to) {\n\n                // create a back reference\n                // eslint-disable-next-line camelcase\n                var backRefs = to.$_refsLength || 0;\n                to[__ref + backRefs] = from;\n                // eslint-disable-next-line camelcase\n                to.$_refsLength = backRefs + 1;\n\n                // create a hard reference\n                // eslint-disable-next-line camelcase\n                from.$_refIndex = backRefs;\n                // eslint-disable-next-line camelcase\n                from.$_context = to;\n            };\n        }, { \"36\": 36 }], 82: [function (require, module, exports) {\n            var version = null;\n            exports.setVersion = function setCacheVersion(newVersion) {\n                version = newVersion;\n            };\n            exports.getVersion = function getCacheVersion() {\n                return version;\n            };\n        }, {}], 83: [function (require, module, exports) {\n            var splice = require(42);\n\n            module.exports = function expireNode(node, expired, lru) {\n                // eslint-disable-next-line camelcase\n                if (!node.$_invalidated) {\n                    // eslint-disable-next-line camelcase\n                    node.$_invalidated = true;\n                    expired.push(node);\n                    splice(lru, node);\n                }\n                return node;\n            };\n        }, { \"42\": 42 }], 84: [function (require, module, exports) {\n            var isObject = require(97);\n            module.exports = function getSize(node) {\n                return isObject(node) && node.$expires || undefined;\n            };\n        }, { \"97\": 97 }], 85: [function (require, module, exports) {\n            var isObject = require(97);\n            module.exports = function getSize(node) {\n                return isObject(node) && node.$size || 0;\n            };\n        }, { \"97\": 97 }], 86: [function (require, module, exports) {\n            var isObject = require(97);\n            module.exports = function getTimestamp(node) {\n                return isObject(node) && node.$timestamp || undefined;\n            };\n        }, { \"97\": 97 }], 87: [function (require, module, exports) {\n            var isObject = require(97);\n\n            module.exports = function getType(node, anyType) {\n                var type = isObject(node) && node.$type || void 0;\n                if (anyType && type) {\n                    return \"branch\";\n                }\n                return type;\n            };\n        }, { \"97\": 97 }], 88: [function (require, module, exports) {\n            var isObject = require(97);\n            var hasOwn = Object.prototype.hasOwnProperty;\n\n            module.exports = function (obj, prop) {\n                return isObject(obj) && hasOwn.call(obj, prop);\n            };\n        }, { \"97\": 97 }], 89: [function (require, module, exports) {\n            var version = 1;\n            module.exports = function incrementVersion() {\n                return version++;\n            };\n            module.exports.getCurrentVersion = function getCurrentVersion() {\n                return version;\n            };\n        }, {}], 90: [function (require, module, exports) {\n            module.exports = function insertNode(node, parent, key, version, optimizedPath) {\n                // eslint-disable-next-line camelcase\n                node.$_key = key;\n                // eslint-disable-next-line camelcase\n                node.$_parent = parent;\n\n                if (version !== undefined) {\n                    // eslint-disable-next-line camelcase\n                    node.$_version = version;\n                }\n                // eslint-disable-next-line camelcase\n                if (!node.$_absolutePath) {\n                    // eslint-disable-next-line camelcase\n                    node.$_absolutePath = optimizedPath.slice(0, optimizedPath.index).concat(key);\n                }\n\n                parent[key] = node;\n\n                return node;\n            };\n        }, {}], 91: [function (require, module, exports) {\n            var now = require(103);\n            var $now = require(120);\n            var $never = require(119);\n\n            module.exports = function isAlreadyExpired(node) {\n                var exp = node.$expires;\n                return exp != null && exp !== $never && exp !== $now && exp < now();\n            };\n        }, { \"103\": 103, \"119\": 119, \"120\": 120 }], 92: [function (require, module, exports) {\n            var now = require(103);\n            var $now = require(120);\n            var $never = require(119);\n\n            module.exports = function isExpired(node) {\n                var exp = node.$expires;\n                return exp != null && exp !== $never && (exp === $now || exp < now());\n            };\n        }, { \"103\": 103, \"119\": 119, \"120\": 120 }], 93: [function (require, module, exports) {\n            var functionTypeof = \"function\";\n\n            module.exports = function isFunction(func) {\n                return Boolean(func) && typeof func === functionTypeof;\n            };\n        }, {}], 94: [function (require, module, exports) {\n            var privatePrefix = require(35);\n\n            /**\n             * Determined if the key passed in is an internal key.\n             *\n             * @param {String} x The key\n             * @private\n             * @returns {Boolean}\n             */\n            module.exports = function isInternalKey(x) {\n                return x === \"$size\" || x.substr(0, 2) === privatePrefix;\n            };\n        }, { \"35\": 35 }], 95: [function (require, module, exports) {\n            var isObject = require(97);\n\n            module.exports = function isJSONEnvelope(envelope) {\n                return isObject(envelope) && \"json\" in envelope;\n            };\n        }, { \"97\": 97 }], 96: [function (require, module, exports) {\n            var isArray = Array.isArray;\n            var isObject = require(97);\n\n            module.exports = function isJSONGraphEnvelope(envelope) {\n                return isObject(envelope) && isArray(envelope.paths) && (isObject(envelope.jsonGraph) || isObject(envelope.jsong) || isObject(envelope.json) || isObject(envelope.values) || isObject(envelope.value));\n            };\n        }, { \"97\": 97 }], 97: [function (require, module, exports) {\n            var objTypeof = \"object\";\n            module.exports = function isObject(value) {\n                return value !== null && typeof value === objTypeof;\n            };\n        }, {}], 98: [function (require, module, exports) {\n            var isArray = Array.isArray;\n            var isObject = require(97);\n\n            module.exports = function isPathValue(pathValue) {\n                return isObject(pathValue) && (isArray(pathValue.path) || typeof pathValue.path === \"string\");\n            };\n        }, { \"97\": 97 }], 99: [function (require, module, exports) {\n            var objTypeof = \"object\";\n            module.exports = function isPrimitive(value) {\n                return value == null || typeof value !== objTypeof;\n            };\n        }, {}], 100: [function (require, module, exports) {\n            var $ref = require(118);\n            var $error = require(117);\n            var getSize = require(85);\n            var getTimestamp = require(86);\n            var isObject = require(97);\n            var isExpired = require(92);\n            var isFunction = require(93);\n\n            var wrapNode = require(114);\n            var insertNode = require(90);\n            var expireNode = require(83);\n            var replaceNode = require(107);\n            var updateNodeAncestors = require(112);\n            var reconstructPath = require(104);\n\n            module.exports = function mergeJSONGraphNode(parent, node, message, key, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n                var sizeOffset;\n\n                var cType, mType, cIsObject, mIsObject, cTimestamp, mTimestamp;\n\n                var nodeValue = node && node.value !== undefined ? node.value : node;\n\n                // If the cache and message are the same, we can probably return early:\n                // - If they're both nullsy,\n                //   - If null then the node needs to be wrapped in an atom and inserted.\n                //     This happens from whole branch merging when a leaf is just a null value\n                //     instead of being wrapped in an atom.\n                //   - If undefined then return null (previous behavior).\n                // - If they're both branches, return the branch.\n                // - If they're both edges, continue below.\n                if (nodeValue === message) {\n                    // There should not be undefined values.  Those should always be\n                    // wrapped in an $atom\n                    if (message === null) {\n                        node = wrapNode(message, undefined, message);\n                        parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                        node = insertNode(node, parent, key, undefined, optimizedPath);\n                        return node;\n                    }\n\n                    // The messange and cache are both undefined, therefore return null.\n                    else if (message === undefined) {\n                            return message;\n                        } else {\n                            cIsObject = isObject(node);\n                            if (cIsObject) {\n                                // Is the cache node a branch? If so, return the cache branch.\n                                cType = node.$type;\n                                if (cType == null) {\n                                    // Has the branch been introduced to the cache yet? If not,\n                                    // give it a parent, key, and absolute path.\n                                    if (node.$_parent == null) {\n                                        insertNode(node, parent, key, version, optimizedPath);\n                                    }\n                                    return node;\n                                }\n                            }\n                        }\n                } else {\n                    cIsObject = isObject(node);\n                    if (cIsObject) {\n                        cType = node.$type;\n                    }\n                }\n\n                // If the cache isn't a reference, we might be able to return early.\n                if (cType !== $ref) {\n                    mIsObject = isObject(message);\n                    if (mIsObject) {\n                        mType = message.$type;\n                    }\n                    if (cIsObject && !cType) {\n                        // If the cache is a branch and the message is empty or\n                        // also a branch, continue with the cache branch.\n                        if (message == null || mIsObject && !mType) {\n                            return node;\n                        }\n                    }\n                }\n                // If the cache is a reference, we might not need to replace it.\n                else {\n                        // If the cache is a reference, but the message is empty, leave the cache alone...\n                        if (message == null) {\n                            // ...unless the cache is an expired reference. In that case, expire\n                            // the cache node and return undefined.\n                            if (isExpired(node)) {\n                                expireNode(node, expired, lru);\n                                return void 0;\n                            }\n                            return node;\n                        }\n                        mIsObject = isObject(message);\n                        if (mIsObject) {\n                            mType = message.$type;\n                            // If the cache and the message are both references,\n                            // check if we need to replace the cache reference.\n                            if (mType === $ref) {\n                                if (node === message) {\n                                    // If the cache and message are the same reference,\n                                    // we performed a whole-branch merge of one of the\n                                    // grandparents. If we've previously graphed this\n                                    // reference, break early. Otherwise, continue to\n                                    // leaf insertion below.\n                                    if (node.$_parent != null) {\n                                        return node;\n                                    }\n                                } else {\n\n                                    cTimestamp = node.$timestamp;\n                                    mTimestamp = message.$timestamp;\n\n                                    // - If either the cache or message reference is expired,\n                                    //   replace the cache reference with the message.\n                                    // - If neither of the references are expired, compare their\n                                    //   timestamps. If either of them don't have a timestamp,\n                                    //   or the message's timestamp is newer, replace the cache\n                                    //   reference with the message reference.\n                                    // - If the message reference is older than the cache\n                                    //   reference, short-circuit.\n                                    if (!isExpired(node) && !isExpired(message) && mTimestamp < cTimestamp) {\n                                        return void 0;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n                if (cType && mIsObject && !mType) {\n                    return insertNode(replaceNode(node, message, parent, key, lru, replacedPaths), parent, key, undefined, optimizedPath);\n                }\n                // If the message is a sentinel or primitive, insert it into the cache.\n                else if (mType || !mIsObject) {\n                        // If the cache and the message are the same value, we branch-merged one\n                        // of the message's ancestors. If this is the first time we've seen this\n                        // leaf, give the message a $size and $type, attach its graph pointers,\n                        // and update the cache sizes and versions.\n\n                        if (mType === $error && isFunction(errorSelector)) {\n                            message = errorSelector(reconstructPath(requestedPath, key), message);\n                            mType = message.$type || mType;\n                        }\n\n                        if (mType && node === message) {\n                            if (node.$_parent == null) {\n                                node = wrapNode(node, mType, node.value);\n                                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                                node = insertNode(node, parent, key, version, optimizedPath);\n                            }\n                        }\n                        // If the cache and message are different, the cache value is expired,\n                        // or the message is a primitive, replace the cache with the message value.\n                        // If the message is a sentinel, clone and maintain its type.\n                        // If the message is a primitive value, wrap it in an atom.\n                        else {\n                                var isDistinct = true;\n                                // If the cache is a branch, but the message is a leaf, replace the\n                                // cache branch with the message leaf.\n                                if (cType && !isExpired(node) || !cIsObject) {\n                                    // Compare the current cache value with the new value. If either of\n                                    // them don't have a timestamp, or the message's timestamp is newer,\n                                    // replace the cache value with the message value. If a comparator\n                                    // is specified, the comparator takes precedence over timestamps.\n                                    //\n                                    // Comparing either Number or undefined to undefined always results in false.\n                                    isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n\n                                    // If at least one of the cache/message are sentinels, compare them.\n                                    if (isDistinct && (cType || mType) && isFunction(comparator)) {\n                                        isDistinct = !comparator(nodeValue, message, optimizedPath.slice(0, optimizedPath.index));\n                                    }\n                                }\n                                if (isDistinct) {\n                                    message = wrapNode(message, mType, mType ? message.value : message);\n                                    sizeOffset = getSize(node) - getSize(message);\n                                    node = replaceNode(node, message, parent, key, lru, replacedPaths);\n                                    parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                                    node = insertNode(node, parent, key, version, optimizedPath);\n                                }\n                            }\n\n                        // Promote the message edge in the LRU.\n                        if (isExpired(node)) {\n                            expireNode(node, expired, lru);\n                        }\n                    } else if (node == null) {\n                        node = insertNode({}, parent, key, undefined, optimizedPath);\n                    }\n\n                return node;\n            };\n        }, { \"104\": 104, \"107\": 107, \"112\": 112, \"114\": 114, \"117\": 117, \"118\": 118, \"83\": 83, \"85\": 85, \"86\": 86, \"90\": 90, \"92\": 92, \"93\": 93, \"97\": 97 }], 101: [function (require, module, exports) {\n            var $ref = require(118);\n            var $error = require(117);\n            var getType = require(87);\n            var getSize = require(85);\n            var getTimestamp = require(86);\n\n            var isExpired = require(92);\n            var isPrimitive = require(99);\n            var isFunction = require(93);\n\n            var wrapNode = require(114);\n            var expireNode = require(83);\n            var insertNode = require(90);\n            var replaceNode = require(107);\n            var updateNodeAncestors = require(112);\n            var updateBackReferenceVersions = require(111);\n            var reconstructPath = require(104);\n\n            module.exports = function mergeValueOrInsertBranch(parent, node, key, value, branch, reference, requestedPath, optimizedPath, version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n                var type = getType(node, reference);\n\n                if (branch || reference) {\n                    if (type && isExpired(node)) {\n                        type = \"expired\";\n                        expireNode(node, expired, lru);\n                    }\n                    if (type && type !== $ref || isPrimitive(node)) {\n                        node = replaceNode(node, {}, parent, key, lru, replacedPaths);\n                        node = insertNode(node, parent, key, version, optimizedPath);\n                        node = updateBackReferenceVersions(node, version);\n                    }\n                } else {\n                    var message = value;\n                    var mType = getType(message);\n                    // Compare the current cache value with the new value. If either of\n                    // them don't have a timestamp, or the message's timestamp is newer,\n                    // replace the cache value with the message value. If a comparator\n                    // is specified, the comparator takes precedence over timestamps.\n                    //\n                    // Comparing either Number or undefined to undefined always results in false.\n                    var isDistinct = getTimestamp(message) < getTimestamp(node) === false;\n                    // If at least one of the cache/message are sentinels, compare them.\n                    if ((type || mType) && isFunction(comparator)) {\n                        isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n                    }\n                    if (isDistinct) {\n\n                        if (mType === $error && isFunction(errorSelector)) {\n                            message = errorSelector(reconstructPath(requestedPath, key), message);\n                            mType = message.$type || mType;\n                        }\n\n                        message = wrapNode(message, mType, mType ? message.value : message);\n\n                        var sizeOffset = getSize(node) - getSize(message);\n\n                        node = replaceNode(node, message, parent, key, lru, replacedPaths);\n                        parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                        node = insertNode(node, parent, key, version, optimizedPath);\n                    }\n                }\n\n                return node;\n            };\n        }, { \"104\": 104, \"107\": 107, \"111\": 111, \"112\": 112, \"114\": 114, \"117\": 117, \"118\": 118, \"83\": 83, \"85\": 85, \"86\": 86, \"87\": 87, \"90\": 90, \"92\": 92, \"93\": 93, \"99\": 99 }], 102: [function (require, module, exports) {\n            module.exports = function noop() {};\n        }, {}], 103: [function (require, module, exports) {\n            module.exports = Date.now;\n        }, {}], 104: [function (require, module, exports) {\n            /**\n             * Reconstructs the path for the current key, from currentPath (requestedPath)\n             * state maintained during set/merge walk operations.\n             *\n             * During the walk, since the requestedPath array is updated after we attempt to\n             * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n             * we need to reconstitute a path from it.\n             *\n             * @param  {Array} currentPath The current requestedPath state, during the walk\n             * @param  {String} key        The current key value, during the walk\n             * @return {Array} A new array, with the path which represents the node we're about\n             * to insert\n             */\n            module.exports = function reconstructPath(currentPath, key) {\n\n                var path = currentPath.slice(0, currentPath.depth);\n                path[path.length] = key;\n\n                return path;\n            };\n        }, {}], 105: [function (require, module, exports) {\n            var $ref = require(118);\n            var splice = require(42);\n            var isObject = require(97);\n            var unlinkBackReferences = require(109);\n            var unlinkForwardReference = require(110);\n\n            module.exports = function removeNode(node, parent, key, lru) {\n                if (isObject(node)) {\n                    var type = node.$type;\n                    if (type) {\n                        if (type === $ref) {\n                            unlinkForwardReference(node);\n                        }\n                        splice(lru, node);\n                    }\n                    unlinkBackReferences(node);\n                    // eslint-disable-next-line camelcase\n                    parent[key] = node.$_parent = void 0;\n                    return true;\n                }\n                return false;\n            };\n        }, { \"109\": 109, \"110\": 110, \"118\": 118, \"42\": 42, \"97\": 97 }], 106: [function (require, module, exports) {\n            var hasOwn = require(88);\n            var prefix = require(37);\n            var removeNode = require(105);\n\n            module.exports = function removeNodeAndDescendants(node, parent, key, lru, mergeContext) {\n                if (removeNode(node, parent, key, lru)) {\n                    if (node.$type !== undefined && mergeContext && node.$_absolutePath) {\n                        mergeContext.hasInvalidatedResult = true;\n                    }\n\n                    if (node.$type == null) {\n                        for (var key2 in node) {\n                            if (key2[0] !== prefix && hasOwn(node, key2)) {\n                                removeNodeAndDescendants(node[key2], node, key2, lru, mergeContext);\n                            }\n                        }\n                    }\n                    return true;\n                }\n                return false;\n            };\n        }, { \"105\": 105, \"37\": 37, \"88\": 88 }], 107: [function (require, module, exports) {\n            var isObject = require(97);\n            var transferBackReferences = require(108);\n            var removeNodeAndDescendants = require(106);\n\n            module.exports = function replaceNode(node, replacement, parent, key, lru, mergeContext) {\n                if (node === replacement) {\n                    return node;\n                } else if (isObject(node)) {\n                    transferBackReferences(node, replacement);\n                    removeNodeAndDescendants(node, parent, key, lru, mergeContext);\n                }\n\n                parent[key] = replacement;\n                return replacement;\n            };\n        }, { \"106\": 106, \"108\": 108, \"97\": 97 }], 108: [function (require, module, exports) {\n            var __ref = require(36);\n\n            module.exports = function transferBackReferences(fromNode, destNode) {\n                // eslint-disable-next-line camelcase\n                var fromNodeRefsLength = fromNode.$_refsLength || 0,\n\n                // eslint-disable-next-line camelcase\n                destNodeRefsLength = destNode.$_refsLength || 0,\n                    i = -1;\n                while (++i < fromNodeRefsLength) {\n                    var ref = fromNode[__ref + i];\n                    if (ref !== void 0) {\n                        // eslint-disable-next-line camelcase\n                        ref.$_context = destNode;\n                        destNode[__ref + (destNodeRefsLength + i)] = ref;\n                        fromNode[__ref + i] = void 0;\n                    }\n                }\n                // eslint-disable-next-line camelcase\n                destNode.$_refsLength = fromNodeRefsLength + destNodeRefsLength;\n                // eslint-disable-next-line camelcase\n                fromNode.$_refsLength = void 0;\n                return destNode;\n            };\n        }, { \"36\": 36 }], 109: [function (require, module, exports) {\n            var __ref = require(36);\n\n            module.exports = function unlinkBackReferences(node) {\n                // eslint-disable-next-line camelcase\n                var i = -1,\n                    n = node.$_refsLength || 0;\n                while (++i < n) {\n                    var ref = node[__ref + i];\n                    if (ref != null) {\n                        // eslint-disable-next-line camelcase\n                        ref.$_context = ref.$_refIndex = node[__ref + i] = void 0;\n                    }\n                }\n                // eslint-disable-next-line camelcase\n                node.$_refsLength = void 0;\n                return node;\n            };\n        }, { \"36\": 36 }], 110: [function (require, module, exports) {\n            var __ref = require(36);\n\n            module.exports = function unlinkForwardReference(reference) {\n                // eslint-disable-next-line camelcase\n                var destination = reference.$_context;\n                if (destination) {\n                    // eslint-disable-next-line camelcase\n                    var i = (reference.$_refIndex || 0) - 1,\n\n                    // eslint-disable-next-line camelcase\n                    n = (destination.$_refsLength || 0) - 1;\n                    while (++i <= n) {\n                        destination[__ref + i] = destination[__ref + (i + 1)];\n                    }\n                    // eslint-disable-next-line camelcase\n                    destination.$_refsLength = n;\n                    // eslint-disable-next-line camelcase\n                    reference.$_refIndex = reference.$_context = destination = void 0;\n                }\n                return reference;\n            };\n        }, { \"36\": 36 }], 111: [function (require, module, exports) {\n            var __ref = require(36);\n\n            module.exports = function updateBackReferenceVersions(nodeArg, version) {\n                var stack = [nodeArg];\n                var count = 0;\n                do {\n                    var node = stack[count];\n                    // eslint-disable-next-line camelcase\n                    if (node && node.$_version !== version) {\n                        // eslint-disable-next-line camelcase\n                        node.$_version = version;\n                        // eslint-disable-next-line camelcase\n                        stack[count++] = node.$_parent;\n                        var i = -1;\n                        // eslint-disable-next-line camelcase\n                        var n = node.$_refsLength || 0;\n                        while (++i < n) {\n                            stack[count++] = node[__ref + i];\n                        }\n                    }\n                } while (--count > -1);\n                return nodeArg;\n            };\n        }, { \"36\": 36 }], 112: [function (require, module, exports) {\n            var removeNode = require(105);\n            var updateBackReferenceVersions = require(111);\n\n            module.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n                var child = nodeArg;\n                do {\n                    var node = child.$_parent;\n                    var size = child.$size = (child.$size || 0) - offset;\n                    if (size <= 0 && node != null) {\n                        removeNode(child, node, child.$_key, lru);\n                    } else if (child.$_version !== version) {\n                        updateBackReferenceVersions(child, version);\n                    }\n                    child = node;\n                } while (child);\n                return nodeArg;\n            };\n        }, { \"105\": 105, \"111\": 111 }], 113: [function (require, module, exports) {\n            var isArray = Array.isArray;\n            var isPathValue = require(98);\n            var isJSONGraphEnvelope = require(96);\n            var isJSONEnvelope = require(95);\n            var pathSyntax = require(134);\n\n            /**\n             *\n             * @param {Object} allowedInput - allowedInput is a map of input styles\n             * that are allowed\n             * @private\n             */\n            module.exports = function validateInput(args, allowedInput, method) {\n                for (var i = 0, len = args.length; i < len; ++i) {\n                    var arg = args[i];\n                    var valid = false;\n\n                    // Path\n                    if (isArray(arg) && allowedInput.path) {\n                        valid = true;\n                    }\n\n                    // Path Syntax\n                    else if (typeof arg === \"string\" && allowedInput.pathSyntax) {\n                            valid = true;\n                        }\n\n                        // Path Value\n                        else if (isPathValue(arg) && allowedInput.pathValue) {\n                                arg.path = pathSyntax.fromPath(arg.path);\n                                valid = true;\n                            }\n\n                            // jsonGraph {jsonGraph: { ... }, paths: [ ... ]}\n                            else if (isJSONGraphEnvelope(arg) && allowedInput.jsonGraph) {\n                                    valid = true;\n                                }\n\n                                // json env {json: {...}}\n                                else if (isJSONEnvelope(arg) && allowedInput.json) {\n                                        valid = true;\n                                    }\n\n                                    // selector functions\n                                    else if (typeof arg === \"function\" && i + 1 === len && allowedInput.selector) {\n                                            valid = true;\n                                        }\n\n                    if (!valid) {\n                        return new Error(\"Unrecognized argument \" + typeof arg + \" [\" + String(arg) + \"] \" + \"to Model#\" + method + \"\");\n                    }\n                }\n                return true;\n            };\n        }, { \"134\": 134, \"95\": 95, \"96\": 96, \"98\": 98 }], 114: [function (require, module, exports) {\n            var now = require(103);\n            var expiresNow = require(120);\n\n            var atomSize = 50;\n\n            var clone = require(80);\n            var isArray = Array.isArray;\n            var getSize = require(85);\n            var getExpires = require(84);\n            var atomType = require(116);\n\n            module.exports = function wrapNode(nodeArg, typeArg, value) {\n\n                var size = 0;\n                var node = nodeArg;\n                var type = typeArg;\n\n                if (type) {\n                    var modelCreated = node.$_modelCreated;\n                    node = clone(node);\n                    size = getSize(node);\n                    node.$type = type;\n                    // eslint-disable-next-line camelcase\n                    node.$_prev = undefined;\n                    // eslint-disable-next-line camelcase\n                    node.$_next = undefined;\n                    // eslint-disable-next-line camelcase\n                    node.$_modelCreated = modelCreated || false;\n                } else {\n                    node = {\n                        $type: atomType,\n                        value: value,\n                        // eslint-disable-next-line camelcase\n                        $_prev: undefined,\n                        // eslint-disable-next-line camelcase\n                        $_next: undefined,\n                        // eslint-disable-next-line camelcase\n                        $_modelCreated: true\n                    };\n                }\n\n                if (value == null) {\n                    size = atomSize + 1;\n                } else if (size == null || size <= 0) {\n                    switch (typeof value) {\n                        case \"object\":\n                            if (isArray(value)) {\n                                size = atomSize + value.length;\n                            } else {\n                                size = atomSize + 1;\n                            }\n                            break;\n                        case \"string\":\n                            size = atomSize + value.length;\n                            break;\n                        default:\n                            size = atomSize + 1;\n                            break;\n                    }\n                }\n\n                var expires = getExpires(node);\n\n                if (typeof expires === \"number\" && expires < expiresNow) {\n                    node.$expires = now() + expires * -1;\n                }\n\n                node.$size = size;\n\n                return node;\n            };\n        }, { \"103\": 103, \"116\": 116, \"120\": 120, \"80\": 80, \"84\": 84, \"85\": 85 }], 115: [function (require, module, exports) {\n            /**\n             * FromEsObserverAdapter is an adpater from an ES Observer to an Rx 2 Observer\n             * @constructor FromEsObserverAdapter\n            */\n            function FromEsObserverAdapter(esObserver) {\n                this.esObserver = esObserver;\n            }\n\n            FromEsObserverAdapter.prototype = {\n                onNext: function onNext(value) {\n                    if (typeof this.esObserver.next === \"function\") {\n                        this.esObserver.next(value);\n                    }\n                },\n                onError: function onError(error) {\n                    if (typeof this.esObserver.error === \"function\") {\n                        this.esObserver.error(error);\n                    }\n                },\n                onCompleted: function onCompleted() {\n                    if (typeof this.esObserver.complete === \"function\") {\n                        this.esObserver.complete();\n                    }\n                }\n            };\n\n            /**\n             * ToEsSubscriptionAdapter is an adpater from the Rx 2 subscription to the ES subscription\n             * @constructor ToEsSubscriptionAdapter\n            */\n            function ToEsSubscriptionAdapter(subscription) {\n                this.subscription = subscription;\n            }\n\n            ToEsSubscriptionAdapter.prototype.unsubscribe = function unsubscribe() {\n                this.subscription.dispose();\n            };\n\n            function toEsObservable(_self) {\n                return {\n                    subscribe: function subscribe(observer) {\n                        return new ToEsSubscriptionAdapter(_self.subscribe(new FromEsObserverAdapter(observer)));\n                    }\n                };\n            }\n\n            module.exports = toEsObservable;\n        }, {}], 116: [function (require, module, exports) {\n            module.exports = \"atom\";\n        }, {}], 117: [function (require, module, exports) {\n            module.exports = \"error\";\n        }, {}], 118: [function (require, module, exports) {\n            module.exports = \"ref\";\n        }, {}], 119: [function (require, module, exports) {\n            module.exports = 1;\n        }, {}], 120: [function (require, module, exports) {\n            module.exports = 0;\n        }, {}], 121: [function (require, module, exports) {\n            \"use strict\";\n\n            // rawAsap provides everything we need except exception management.\n\n            var rawAsap = require(122);\n            // RawTasks are recycled to reduce GC churn.\n            var freeTasks = [];\n            // We queue errors to ensure they are thrown in right order (FIFO).\n            // Array-as-queue is good enough here, since we are just dealing with exceptions.\n            var pendingErrors = [];\n            var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\n            function throwFirstError() {\n                if (pendingErrors.length) {\n                    throw pendingErrors.shift();\n                }\n            }\n\n            /**\n             * Calls a task as soon as possible after returning, in its own event, with priority\n             * over other events like animation, reflow, and repaint. An error thrown from an\n             * event will not interrupt, nor even substantially slow down the processing of\n             * other events, but will be rather postponed to a lower priority event.\n             * @param {{call}} task A callable object, typically a function that takes no\n             * arguments.\n             */\n            module.exports = asap;\n            function asap(task) {\n                var rawTask;\n                if (freeTasks.length) {\n                    rawTask = freeTasks.pop();\n                } else {\n                    rawTask = new RawTask();\n                }\n                rawTask.task = task;\n                rawAsap(rawTask);\n            }\n\n            // We wrap tasks with recyclable task objects.  A task object implements\n            // `call`, just like a function.\n            function RawTask() {\n                this.task = null;\n            }\n\n            // The sole purpose of wrapping the task is to catch the exception and recycle\n            // the task object after its single use.\n            RawTask.prototype.call = function () {\n                try {\n                    this.task.call();\n                } catch (error) {\n                    if (asap.onerror) {\n                        // This hook exists purely for testing purposes.\n                        // Its name will be periodically randomized to break any code that\n                        // depends on its existence.\n                        asap.onerror(error);\n                    } else {\n                        // In a web browser, exceptions are not fatal. However, to avoid\n                        // slowing down the queue of pending tasks, we rethrow the error in a\n                        // lower priority turn.\n                        pendingErrors.push(error);\n                        requestErrorThrow();\n                    }\n                } finally {\n                    this.task = null;\n                    freeTasks[freeTasks.length] = this;\n                }\n            };\n        }, { \"122\": 122 }], 122: [function (require, module, exports) {\n            (function (global) {\n                \"use strict\";\n\n                // Use the fastest means possible to execute a task in its own turn, with\n                // priority over other events including IO, animation, reflow, and redraw\n                // events in browsers.\n                //\n                // An exception thrown by a task will permanently interrupt the processing of\n                // subsequent tasks. The higher level `asap` function ensures that if an\n                // exception is thrown by a task, that the task queue will continue flushing as\n                // soon as possible, but if you use `rawAsap` directly, you are responsible to\n                // either ensure that no exceptions are thrown from your task, or to manually\n                // call `rawAsap.requestFlush` if an exception is thrown.\n\n                module.exports = rawAsap;\n                function rawAsap(task) {\n                    if (!queue.length) {\n                        requestFlush();\n                        flushing = true;\n                    }\n                    // Equivalent to push, but avoids a function call.\n                    queue[queue.length] = task;\n                }\n\n                var queue = [];\n                // Once a flush has been requested, no further calls to `requestFlush` are\n                // necessary until the next `flush` completes.\n                var flushing = false;\n                // `requestFlush` is an implementation-specific method that attempts to kick\n                // off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n                // the event queue before yielding to the browser's own event loop.\n                var requestFlush;\n                // The position of the next task to execute in the task queue. This is\n                // preserved between calls to `flush` so that it can be resumed if\n                // a task throws an exception.\n                var index = 0;\n                // If a task schedules additional tasks recursively, the task queue can grow\n                // unbounded. To prevent memory exhaustion, the task queue will periodically\n                // truncate already-completed tasks.\n                var capacity = 1024;\n\n                // The flush function processes all tasks that have been scheduled with\n                // `rawAsap` unless and until one of those tasks throws an exception.\n                // If a task throws an exception, `flush` ensures that its state will remain\n                // consistent and will resume where it left off when called again.\n                // However, `flush` does not make any arrangements to be called again if an\n                // exception is thrown.\n                function flush() {\n                    while (index < queue.length) {\n                        var currentIndex = index;\n                        // Advance the index before calling the task. This ensures that we will\n                        // begin flushing on the next task the task throws an error.\n                        index = index + 1;\n                        queue[currentIndex].call();\n                        // Prevent leaking memory for long chains of recursive calls to `asap`.\n                        // If we call `asap` within tasks scheduled by `asap`, the queue will\n                        // grow, but to avoid an O(n) walk for every task we execute, we don't\n                        // shift tasks off the queue after they have been executed.\n                        // Instead, we periodically shift 1024 tasks off the queue.\n                        if (index > capacity) {\n                            // Manually shift all values starting at the index back to the\n                            // beginning of the queue.\n                            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                                queue[scan] = queue[scan + index];\n                            }\n                            queue.length -= index;\n                            index = 0;\n                        }\n                    }\n                    queue.length = 0;\n                    index = 0;\n                    flushing = false;\n                }\n\n                // `requestFlush` is implemented using a strategy based on data collected from\n                // every available SauceLabs Selenium web driver worker at time of writing.\n                // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n                // Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n                // have WebKitMutationObserver but not un-prefixed MutationObserver.\n                // Must use `global` instead of `window` to work in both frames and web\n                // workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n                var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\n                // MutationObservers are desirable because they have high priority and work\n                // reliably everywhere they are implemented.\n                // They are implemented in all modern browsers.\n                //\n                // - Android 4-4.3\n                // - Chrome 26-34\n                // - Firefox 14-29\n                // - Internet Explorer 11\n                // - iPad Safari 6-7.1\n                // - iPhone Safari 7-7.1\n                // - Safari 6-7\n                if (typeof BrowserMutationObserver === \"function\") {\n                    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n                    // MessageChannels are desirable because they give direct access to the HTML\n                    // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n                    // 11-12, and in web workers in many engines.\n                    // Although message channels yield to any queued rendering and IO tasks, they\n                    // would be better than imposing the 4ms delay of timers.\n                    // However, they do not work reliably in Internet Explorer or Safari.\n\n                    // Internet Explorer 10 is the only browser that has setImmediate but does\n                    // not have MutationObservers.\n                    // Although setImmediate yields to the browser's renderer, it would be\n                    // preferrable to falling back to setTimeout since it does not have\n                    // the minimum 4ms penalty.\n                    // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n                    // Desktop to a lesser extent) that renders both setImmediate and\n                    // MessageChannel useless for the purposes of ASAP.\n                    // https://github.com/kriskowal/q/issues/396\n\n                    // Timers are implemented universally.\n                    // We fall back to timers in workers in most engines, and in foreground\n                    // contexts in the following browsers.\n                    // However, note that even this simple case requires nuances to operate in a\n                    // broad spectrum of browsers.\n                    //\n                    // - Firefox 3-13\n                    // - Internet Explorer 6-9\n                    // - iPad Safari 4.3\n                    // - Lynx 2.8.7\n                } else {\n                    requestFlush = makeRequestCallFromTimer(flush);\n                }\n\n                // `requestFlush` requests that the high priority event queue be flushed as\n                // soon as possible.\n                // This is useful to prevent an error thrown in a task from stalling the event\n                // queue if the exception handled by Node.jss\n                // `process.on(\"uncaughtException\")` or by a domain.\n                rawAsap.requestFlush = requestFlush;\n\n                // To request a high priority event, we induce a mutation observer by toggling\n                // the text of a text node between \"1\" and \"-1\".\n                function makeRequestCallFromMutationObserver(callback) {\n                    var toggle = 1;\n                    var observer = new BrowserMutationObserver(callback);\n                    var node = document.createTextNode(\"\");\n                    observer.observe(node, { characterData: true });\n                    return function requestCall() {\n                        toggle = -toggle;\n                        node.data = toggle;\n                    };\n                }\n\n                // The message channel technique was discovered by Malte Ubl and was the\n                // original foundation for this library.\n                // http://www.nonblocking.io/2011/06/windownexttick.html\n\n                // Safari 6.0.5 (at least) intermittently fails to create message ports on a\n                // page's first load. Thankfully, this version of Safari supports\n                // MutationObservers, so we don't need to fall back in that case.\n\n                // function makeRequestCallFromMessageChannel(callback) {\n                //     var channel = new MessageChannel();\n                //     channel.port1.onmessage = callback;\n                //     return function requestCall() {\n                //         channel.port2.postMessage(0);\n                //     };\n                // }\n\n                // For reasons explained above, we are also unable to use `setImmediate`\n                // under any circumstances.\n                // Even if we were, there is another bug in Internet Explorer 10.\n                // It is not sufficient to assign `setImmediate` to `requestFlush` because\n                // `setImmediate` must be called *by name* and therefore must be wrapped in a\n                // closure.\n                // Never forget.\n\n                // function makeRequestCallFromSetImmediate(callback) {\n                //     return function requestCall() {\n                //         setImmediate(callback);\n                //     };\n                // }\n\n                // Safari 6.0 has a problem where timers will get lost while the user is\n                // scrolling. This problem does not impact ASAP because Safari 6.0 supports\n                // mutation observers, so that implementation is used instead.\n                // However, if we ever elect to use timers in Safari, the prevalent work-around\n                // is to add a scroll event listener that calls for a flush.\n\n                // `setTimeout` does not call the passed callback if the delay is less than\n                // approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n                // even then.\n\n                function makeRequestCallFromTimer(callback) {\n                    return function requestCall() {\n                        // We dispatch a timeout with a specified delay of 0 for engines that\n                        // can reliably accommodate that request. This will usually be snapped\n                        // to a 4 milisecond delay, but once we're flushing, there's no delay\n                        // between events.\n                        var timeoutHandle = setTimeout(handleTimer, 0);\n                        // However, since this timer gets frequently dropped in Firefox\n                        // workers, we enlist an interval handle that will try to fire\n                        // an event 20 times per second until it succeeds.\n                        var intervalHandle = setInterval(handleTimer, 50);\n\n                        function handleTimer() {\n                            // Whichever timer succeeds will cancel both timers and\n                            // execute the callback.\n                            clearTimeout(timeoutHandle);\n                            clearInterval(intervalHandle);\n                            callback();\n                        }\n                    };\n                }\n\n                // This is for `asap.js` only.\n                // Its name will be periodically randomized to break any code that depends on\n                // its existence.\n                rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n                // ASAP was originally a nextTick shim included in Q. This was factored out\n                // into this ASAP package. It was later adapted to RSVP which made further\n                // amendments. These decisions, particularly to marginalize MessageChannel and\n                // to capture the MutationObserver implementation in a closure, were integrated\n                // back into ASAP proper.\n                // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n            }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n        }, {}], 123: [function (require, module, exports) {\n            \"use strict\";\n\n            // rawAsap provides everything we need except exception management.\n\n            var rawAsap = require(124);\n            // RawTasks are recycled to reduce GC churn.\n            var freeTasks = [];\n            // We queue errors to ensure they are thrown in right order (FIFO).\n            // Array-as-queue is good enough here, since we are just dealing with exceptions.\n            var pendingErrors = [];\n            var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\n            function throwFirstError() {\n                if (pendingErrors.length) {\n                    throw pendingErrors.shift();\n                }\n            }\n\n            /**\n             * Calls a task as soon as possible after returning, in its own event, with priority\n             * over other events like animation, reflow, and repaint. An error thrown from an\n             * event will not interrupt, nor even substantially slow down the processing of\n             * other events, but will be rather postponed to a lower priority event.\n             * @param {{call}} task A callable object, typically a function that takes no\n             * arguments.\n             */\n            module.exports = asap;\n            function asap(task) {\n                var rawTask;\n                if (freeTasks.length) {\n                    rawTask = freeTasks.pop();\n                } else {\n                    rawTask = new RawTask();\n                }\n                rawTask.task = task;\n                rawAsap(rawTask);\n            }\n\n            // We wrap tasks with recyclable task objects.  A task object implements\n            // `call`, just like a function.\n            function RawTask() {\n                this.task = null;\n            }\n\n            // The sole purpose of wrapping the task is to catch the exception and recycle\n            // the task object after its single use.\n            RawTask.prototype.call = function () {\n                try {\n                    this.task.call();\n                } catch (error) {\n                    if (asap.onerror) {\n                        // This hook exists purely for testing purposes.\n                        // Its name will be periodically randomized to break any code that\n                        // depends on its existence.\n                        asap.onerror(error);\n                    } else {\n                        // In a web browser, exceptions are not fatal. However, to avoid\n                        // slowing down the queue of pending tasks, we rethrow the error in a\n                        // lower priority turn.\n                        pendingErrors.push(error);\n                        requestErrorThrow();\n                    }\n                } finally {\n                    this.task = null;\n                    freeTasks[freeTasks.length] = this;\n                }\n            };\n        }, { \"124\": 124 }], 124: [function (require, module, exports) {\n            (function (global) {\n                \"use strict\";\n\n                // Use the fastest means possible to execute a task in its own turn, with\n                // priority over other events including IO, animation, reflow, and redraw\n                // events in browsers.\n                //\n                // An exception thrown by a task will permanently interrupt the processing of\n                // subsequent tasks. The higher level `asap` function ensures that if an\n                // exception is thrown by a task, that the task queue will continue flushing as\n                // soon as possible, but if you use `rawAsap` directly, you are responsible to\n                // either ensure that no exceptions are thrown from your task, or to manually\n                // call `rawAsap.requestFlush` if an exception is thrown.\n\n                module.exports = rawAsap;\n                function rawAsap(task) {\n                    if (!queue.length) {\n                        requestFlush();\n                        flushing = true;\n                    }\n                    // Equivalent to push, but avoids a function call.\n                    queue[queue.length] = task;\n                }\n\n                var queue = [];\n                // Once a flush has been requested, no further calls to `requestFlush` are\n                // necessary until the next `flush` completes.\n                var flushing = false;\n                // `requestFlush` is an implementation-specific method that attempts to kick\n                // off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n                // the event queue before yielding to the browser's own event loop.\n                var requestFlush;\n                // The position of the next task to execute in the task queue. This is\n                // preserved between calls to `flush` so that it can be resumed if\n                // a task throws an exception.\n                var index = 0;\n                // If a task schedules additional tasks recursively, the task queue can grow\n                // unbounded. To prevent memory exhaustion, the task queue will periodically\n                // truncate already-completed tasks.\n                var capacity = 1024;\n\n                // The flush function processes all tasks that have been scheduled with\n                // `rawAsap` unless and until one of those tasks throws an exception.\n                // If a task throws an exception, `flush` ensures that its state will remain\n                // consistent and will resume where it left off when called again.\n                // However, `flush` does not make any arrangements to be called again if an\n                // exception is thrown.\n                function flush() {\n                    while (index < queue.length) {\n                        var currentIndex = index;\n                        // Advance the index before calling the task. This ensures that we will\n                        // begin flushing on the next task the task throws an error.\n                        index = index + 1;\n                        queue[currentIndex].call();\n                        // Prevent leaking memory for long chains of recursive calls to `asap`.\n                        // If we call `asap` within tasks scheduled by `asap`, the queue will\n                        // grow, but to avoid an O(n) walk for every task we execute, we don't\n                        // shift tasks off the queue after they have been executed.\n                        // Instead, we periodically shift 1024 tasks off the queue.\n                        if (index > capacity) {\n                            // Manually shift all values starting at the index back to the\n                            // beginning of the queue.\n                            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                                queue[scan] = queue[scan + index];\n                            }\n                            queue.length -= index;\n                            index = 0;\n                        }\n                    }\n                    queue.length = 0;\n                    index = 0;\n                    flushing = false;\n                }\n\n                // `requestFlush` is implemented using a strategy based on data collected from\n                // every available SauceLabs Selenium web driver worker at time of writing.\n                // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n                // Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n                // have WebKitMutationObserver but not un-prefixed MutationObserver.\n                // Must use `global` or `self` instead of `window` to work in both frames and web\n                // workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n                /* globals self */\n                var scope = typeof global !== \"undefined\" ? global : self;\n                var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n                // MutationObservers are desirable because they have high priority and work\n                // reliably everywhere they are implemented.\n                // They are implemented in all modern browsers.\n                //\n                // - Android 4-4.3\n                // - Chrome 26-34\n                // - Firefox 14-29\n                // - Internet Explorer 11\n                // - iPad Safari 6-7.1\n                // - iPhone Safari 7-7.1\n                // - Safari 6-7\n                if (typeof BrowserMutationObserver === \"function\") {\n                    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n                    // MessageChannels are desirable because they give direct access to the HTML\n                    // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n                    // 11-12, and in web workers in many engines.\n                    // Although message channels yield to any queued rendering and IO tasks, they\n                    // would be better than imposing the 4ms delay of timers.\n                    // However, they do not work reliably in Internet Explorer or Safari.\n\n                    // Internet Explorer 10 is the only browser that has setImmediate but does\n                    // not have MutationObservers.\n                    // Although setImmediate yields to the browser's renderer, it would be\n                    // preferrable to falling back to setTimeout since it does not have\n                    // the minimum 4ms penalty.\n                    // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n                    // Desktop to a lesser extent) that renders both setImmediate and\n                    // MessageChannel useless for the purposes of ASAP.\n                    // https://github.com/kriskowal/q/issues/396\n\n                    // Timers are implemented universally.\n                    // We fall back to timers in workers in most engines, and in foreground\n                    // contexts in the following browsers.\n                    // However, note that even this simple case requires nuances to operate in a\n                    // broad spectrum of browsers.\n                    //\n                    // - Firefox 3-13\n                    // - Internet Explorer 6-9\n                    // - iPad Safari 4.3\n                    // - Lynx 2.8.7\n                } else {\n                    requestFlush = makeRequestCallFromTimer(flush);\n                }\n\n                // `requestFlush` requests that the high priority event queue be flushed as\n                // soon as possible.\n                // This is useful to prevent an error thrown in a task from stalling the event\n                // queue if the exception handled by Node.jss\n                // `process.on(\"uncaughtException\")` or by a domain.\n                rawAsap.requestFlush = requestFlush;\n\n                // To request a high priority event, we induce a mutation observer by toggling\n                // the text of a text node between \"1\" and \"-1\".\n                function makeRequestCallFromMutationObserver(callback) {\n                    var toggle = 1;\n                    var observer = new BrowserMutationObserver(callback);\n                    var node = document.createTextNode(\"\");\n                    observer.observe(node, { characterData: true });\n                    return function requestCall() {\n                        toggle = -toggle;\n                        node.data = toggle;\n                    };\n                }\n\n                // The message channel technique was discovered by Malte Ubl and was the\n                // original foundation for this library.\n                // http://www.nonblocking.io/2011/06/windownexttick.html\n\n                // Safari 6.0.5 (at least) intermittently fails to create message ports on a\n                // page's first load. Thankfully, this version of Safari supports\n                // MutationObservers, so we don't need to fall back in that case.\n\n                // function makeRequestCallFromMessageChannel(callback) {\n                //     var channel = new MessageChannel();\n                //     channel.port1.onmessage = callback;\n                //     return function requestCall() {\n                //         channel.port2.postMessage(0);\n                //     };\n                // }\n\n                // For reasons explained above, we are also unable to use `setImmediate`\n                // under any circumstances.\n                // Even if we were, there is another bug in Internet Explorer 10.\n                // It is not sufficient to assign `setImmediate` to `requestFlush` because\n                // `setImmediate` must be called *by name* and therefore must be wrapped in a\n                // closure.\n                // Never forget.\n\n                // function makeRequestCallFromSetImmediate(callback) {\n                //     return function requestCall() {\n                //         setImmediate(callback);\n                //     };\n                // }\n\n                // Safari 6.0 has a problem where timers will get lost while the user is\n                // scrolling. This problem does not impact ASAP because Safari 6.0 supports\n                // mutation observers, so that implementation is used instead.\n                // However, if we ever elect to use timers in Safari, the prevalent work-around\n                // is to add a scroll event listener that calls for a flush.\n\n                // `setTimeout` does not call the passed callback if the delay is less than\n                // approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n                // even then.\n\n                function makeRequestCallFromTimer(callback) {\n                    return function requestCall() {\n                        // We dispatch a timeout with a specified delay of 0 for engines that\n                        // can reliably accommodate that request. This will usually be snapped\n                        // to a 4 milisecond delay, but once we're flushing, there's no delay\n                        // between events.\n                        var timeoutHandle = setTimeout(handleTimer, 0);\n                        // However, since this timer gets frequently dropped in Firefox\n                        // workers, we enlist an interval handle that will try to fire\n                        // an event 20 times per second until it succeeds.\n                        var intervalHandle = setInterval(handleTimer, 50);\n\n                        function handleTimer() {\n                            // Whichever timer succeeds will cancel both timers and\n                            // execute the callback.\n                            clearTimeout(timeoutHandle);\n                            clearInterval(intervalHandle);\n                            callback();\n                        }\n                    };\n                }\n\n                // This is for `asap.js` only.\n                // Its name will be periodically randomized to break any code that depends on\n                // its existence.\n                rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n                // ASAP was originally a nextTick shim included in Q. This was factored out\n                // into this ASAP package. It was later adapted to RSVP which made further\n                // amendments. These decisions, particularly to marginalize MessageChannel and\n                // to capture the MutationObserver implementation in a closure, were integrated\n                // back into ASAP proper.\n                // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n            }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n        }, {}], 125: [function (require, module, exports) {\n            'use strict';\n\n            var request = require(129);\n            var buildQueryObject = require(126);\n            var isArray = Array.isArray;\n\n            function simpleExtend(obj, obj2) {\n                var prop;\n                for (prop in obj2) {\n                    obj[prop] = obj2[prop];\n                }\n                return obj;\n            }\n\n            function XMLHttpSource(jsongUrl, config) {\n                this._jsongUrl = jsongUrl;\n                if (typeof config === 'number') {\n                    var newConfig = {\n                        timeout: config\n                    };\n                    config = newConfig;\n                }\n                this._config = simpleExtend({\n                    timeout: 15000,\n                    headers: {}\n                }, config || {});\n            }\n\n            XMLHttpSource.prototype = {\n                // because javascript\n                constructor: XMLHttpSource,\n                /**\n                 * buildQueryObject helper\n                 */\n                buildQueryObject: buildQueryObject,\n\n                /**\n                 * @inheritDoc DataSource#get\n                 */\n                get: function httpSourceGet(pathSet) {\n                    var method = 'GET';\n                    var queryObject = this.buildQueryObject(this._jsongUrl, method, {\n                        paths: pathSet,\n                        method: 'get'\n                    });\n                    var config = simpleExtend(queryObject, this._config);\n                    // pass context for onBeforeRequest callback\n                    var context = this;\n                    return request(method, config, context);\n                },\n\n                /**\n                 * @inheritDoc DataSource#set\n                 */\n                set: function httpSourceSet(jsongEnv) {\n                    var method = 'POST';\n                    var queryObject = this.buildQueryObject(this._jsongUrl, method, {\n                        jsonGraph: jsongEnv,\n                        method: 'set'\n                    });\n                    var config = simpleExtend(queryObject, this._config);\n                    config.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n\n                    // pass context for onBeforeRequest callback\n                    var context = this;\n                    return request(method, config, context);\n                },\n\n                /**\n                 * @inheritDoc DataSource#call\n                 */\n                call: function httpSourceCall(callPath, args, pathSuffix, paths) {\n                    // arguments defaults\n                    args = args || [];\n                    pathSuffix = pathSuffix || [];\n                    paths = paths || [];\n\n                    var method = 'POST';\n                    var queryData = [];\n                    queryData.push('method=call');\n                    queryData.push('callPath=' + encodeURIComponent(JSON.stringify(callPath)));\n                    queryData.push('arguments=' + encodeURIComponent(JSON.stringify(args)));\n                    queryData.push('pathSuffixes=' + encodeURIComponent(JSON.stringify(pathSuffix)));\n                    queryData.push('paths=' + encodeURIComponent(JSON.stringify(paths)));\n\n                    var queryObject = this.buildQueryObject(this._jsongUrl, method, queryData.join('&'));\n                    var config = simpleExtend(queryObject, this._config);\n                    config.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n\n                    // pass context for onBeforeRequest callback\n                    var context = this;\n                    return request(method, config, context);\n                }\n            };\n            // ES6 modules\n            XMLHttpSource.XMLHttpSource = XMLHttpSource;\n            XMLHttpSource['default'] = XMLHttpSource;\n            // commonjs\n            module.exports = XMLHttpSource;\n        }, { \"126\": 126, \"129\": 129 }], 126: [function (require, module, exports) {\n            'use strict';\n\n            module.exports = function buildQueryObject(url, method, queryData) {\n                var qData = [];\n                var keys;\n                var data = { url: url };\n                var isQueryParamUrl = url.indexOf('?') !== -1;\n                var startUrl = isQueryParamUrl ? '&' : '?';\n\n                if (typeof queryData === 'string') {\n                    qData.push(queryData);\n                } else {\n\n                    keys = Object.keys(queryData);\n                    keys.forEach(function (k) {\n                        var value = typeof queryData[k] === 'object' ? JSON.stringify(queryData[k]) : queryData[k];\n                        qData.push(k + '=' + encodeURIComponent(value));\n                    });\n                }\n\n                if (method === 'GET') {\n                    data.url += startUrl + qData.join('&');\n                } else {\n                    data.data = qData.join('&');\n                }\n\n                return data;\n            };\n        }, {}], 127: [function (require, module, exports) {\n            (function (global) {\n                'use strict';\n                // Get CORS support even for older IE\n\n                module.exports = function getCORSRequest() {\n                    var xhr = new global.XMLHttpRequest();\n                    if ('withCredentials' in xhr) {\n                        return xhr;\n                    } else if (!!global.XDomainRequest) {\n                        return new XDomainRequest();\n                    } else {\n                        throw new Error('CORS is not supported by your browser');\n                    }\n                };\n            }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n        }, {}], 128: [function (require, module, exports) {\n            (function (global) {\n                'use strict';\n\n                module.exports = function getXMLHttpRequest() {\n                    var progId, progIds, i;\n                    if (global.XMLHttpRequest) {\n                        return new global.XMLHttpRequest();\n                    } else {\n                        try {\n                            progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n                            for (i = 0; i < 3; i++) {\n                                try {\n                                    progId = progIds[i];\n                                    if (new global.ActiveXObject(progId)) {\n                                        break;\n                                    }\n                                } catch (e) {}\n                            }\n                            return new global.ActiveXObject(progId);\n                        } catch (e) {\n                            throw new Error('XMLHttpRequest is not supported by your browser');\n                        }\n                    }\n                };\n            }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n        }, {}], 129: [function (require, module, exports) {\n            'use strict';\n\n            var getXMLHttpRequest = require(128);\n            var getCORSRequest = require(127);\n            var hasOwnProp = Object.prototype.hasOwnProperty;\n\n            var noop = function noop() {};\n\n            function Observable() {}\n\n            Observable.create = function (subscribe) {\n                var o = new Observable();\n\n                o.subscribe = function (onNext, onError, onCompleted) {\n\n                    var observer;\n                    var disposable;\n\n                    if (typeof onNext === 'function') {\n                        observer = {\n                            onNext: onNext,\n                            onError: onError || noop,\n                            onCompleted: onCompleted || noop\n                        };\n                    } else {\n                        observer = onNext;\n                    }\n\n                    disposable = subscribe(observer);\n\n                    if (typeof disposable === 'function') {\n                        return {\n                            dispose: disposable\n                        };\n                    } else {\n                        return disposable;\n                    }\n                };\n\n                return o;\n            };\n\n            function request(method, options, context) {\n                return Observable.create(function requestObserver(observer) {\n\n                    var config = {\n                        method: method || 'GET',\n                        crossDomain: false,\n                        async: true,\n                        headers: {},\n                        responseType: 'json'\n                    };\n\n                    var xhr, isDone, headers, header, prop;\n\n                    for (prop in options) {\n                        if (hasOwnProp.call(options, prop)) {\n                            config[prop] = options[prop];\n                        }\n                    }\n\n                    // Add request with Headers\n                    if (!config.crossDomain && !config.headers['X-Requested-With']) {\n                        config.headers['X-Requested-With'] = 'XMLHttpRequest';\n                    }\n\n                    // allow the user to mutate the config open\n                    if (context.onBeforeRequest != null) {\n                        context.onBeforeRequest(config);\n                    }\n\n                    // create xhr\n                    try {\n                        xhr = config.crossDomain ? getCORSRequest() : getXMLHttpRequest();\n                    } catch (err) {\n                        observer.onError(err);\n                    }\n                    try {\n                        // Takes the url and opens the connection\n                        if (config.user) {\n                            xhr.open(config.method, config.url, config.async, config.user, config.password);\n                        } else {\n                            xhr.open(config.method, config.url, config.async);\n                        }\n\n                        // Sets timeout information\n                        xhr.timeout = config.timeout;\n\n                        // Anything but explicit false results in true.\n                        xhr.withCredentials = config.withCredentials !== false;\n\n                        // Fills the request headers\n                        headers = config.headers;\n                        for (header in headers) {\n                            if (hasOwnProp.call(headers, header)) {\n                                xhr.setRequestHeader(header, headers[header]);\n                            }\n                        }\n\n                        if (config.responseType) {\n                            try {\n                                xhr.responseType = config.responseType;\n                            } catch (e) {\n                                // WebKit added support for the json responseType value on 09/03/2013\n                                // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are\n                                // known to throw when setting the value \"json\" as the response type. Other older\n                                // browsers implementing the responseType\n                                //\n                                // The json response type can be ignored if not supported, because JSON payloads are\n                                // parsed on the client-side regardless.\n                                if (config.responseType !== 'json') {\n                                    throw e;\n                                }\n                            }\n                        }\n\n                        xhr.onreadystatechange = function onreadystatechange(e) {\n                            // Complete\n                            if (xhr.readyState === 4) {\n                                if (!isDone) {\n                                    isDone = true;\n                                    onXhrLoad(observer, xhr, e);\n                                }\n                            }\n                        };\n\n                        // Timeout\n                        xhr.ontimeout = function ontimeout(e) {\n                            if (!isDone) {\n                                isDone = true;\n                                onXhrError(observer, xhr, 'timeout error', e);\n                            }\n                        };\n\n                        // Send Request\n                        xhr.send(config.data);\n                    } catch (e) {\n                        observer.onError(e);\n                    }\n                    // Dispose\n                    return function dispose() {\n                        // Doesn't work in IE9\n                        if (!isDone && xhr.readyState !== 4) {\n                            isDone = true;\n                            xhr.abort();\n                        }\n                    }; //Dispose\n                });\n            }\n\n            /*\n             * General handling of ultimate failure (after appropriate retries)\n             */\n            function _handleXhrError(observer, textStatus, errorThrown) {\n                // IE9: cross-domain request may be considered errors\n                if (!errorThrown) {\n                    errorThrown = new Error(textStatus);\n                }\n\n                observer.onError(errorThrown);\n            }\n\n            function onXhrLoad(observer, xhr, e) {\n                var responseData, responseObject, responseType;\n\n                // If there's no observer, the request has been (or is being) cancelled.\n                if (xhr && observer) {\n                    responseType = xhr.responseType;\n                    // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n                    // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)\n                    responseData = 'response' in xhr ? xhr.response : xhr.responseText;\n\n                    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                    var status = xhr.status === 1223 ? 204 : xhr.status;\n\n                    if (status >= 200 && status <= 399) {\n                        try {\n                            if (responseType !== 'json') {\n                                responseData = JSON.parse(responseData || '');\n                            }\n                            if (typeof responseData === 'string') {\n                                responseData = JSON.parse(responseData || '');\n                            }\n                        } catch (e) {\n                            _handleXhrError(observer, 'invalid json', e);\n                        }\n                        observer.onNext(responseData);\n                        observer.onCompleted();\n                        return;\n                    } else if (status === 401 || status === 403 || status === 407) {\n\n                        return _handleXhrError(observer, responseData);\n                    } else if (status === 410) {\n                        // TODO: Retry ?\n                        return _handleXhrError(observer, responseData);\n                    } else if (status === 408 || status === 504) {\n                        // TODO: Retry ?\n                        return _handleXhrError(observer, responseData);\n                    } else {\n\n                        return _handleXhrError(observer, responseData || 'Response code ' + status);\n                    } //if\n                } //if\n            } //onXhrLoad\n\n            function onXhrError(observer, xhr, status, e) {\n                _handleXhrError(observer, status || xhr.statusText || 'request error', e);\n            }\n\n            module.exports = request;\n        }, { \"127\": 127, \"128\": 128 }], 130: [function (require, module, exports) {\n            var pathSyntax = require(134);\n\n            function sentinel(type, value, props) {\n                var copy = Object.create(null);\n                if (props != null) {\n                    for (var key in props) {\n                        copy[key] = props[key];\n                    }\n\n                    copy[\"$type\"] = type;\n                    copy.value = value;\n                    return copy;\n                } else {\n                    return { $type: type, value: value };\n                }\n            }\n\n            module.exports = {\n                ref: function ref(path, props) {\n                    return sentinel(\"ref\", pathSyntax.fromPath(path), props);\n                },\n                atom: function atom(value, props) {\n                    return sentinel(\"atom\", value, props);\n                },\n                undefined: function undefined() {\n                    return sentinel(\"atom\");\n                },\n                error: function error(errorValue, props) {\n                    return sentinel(\"error\", errorValue, props);\n                },\n                pathValue: function pathValue(path, value) {\n                    return { path: pathSyntax.fromPath(path), value: value };\n                },\n                pathInvalidation: function pathInvalidation(path) {\n                    return { path: pathSyntax.fromPath(path), invalidated: true };\n                }\n            };\n        }, { \"134\": 134 }], 131: [function (require, module, exports) {\n            module.exports = {\n                integers: 'integers',\n                ranges: 'ranges',\n                keys: 'keys'\n            };\n        }, {}], 132: [function (require, module, exports) {\n            var TokenTypes = {\n                token: 'token',\n                dotSeparator: '.',\n                commaSeparator: ',',\n                openingBracket: '[',\n                closingBracket: ']',\n                openingBrace: '{',\n                closingBrace: '}',\n                escape: '\\\\',\n                space: ' ',\n                colon: ':',\n                quote: 'quote',\n                unknown: 'unknown'\n            };\n\n            module.exports = TokenTypes;\n        }, {}], 133: [function (require, module, exports) {\n            module.exports = {\n                indexer: {\n                    nested: 'Indexers cannot be nested.',\n                    needQuotes: 'unquoted indexers must be numeric.',\n                    empty: 'cannot have empty indexers.',\n                    leadingDot: 'Indexers cannot have leading dots.',\n                    leadingComma: 'Indexers cannot have leading comma.',\n                    requiresComma: 'Indexers require commas between indexer args.',\n                    routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'\n                },\n                range: {\n                    precedingNaN: 'ranges must be preceded by numbers.',\n                    suceedingNaN: 'ranges must be suceeded by numbers.'\n                },\n                routed: {\n                    invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'\n                },\n                quote: {\n                    empty: 'cannot have empty quoted keys.',\n                    illegalEscape: 'Invalid escape character.  Only quotes are escapable.'\n                },\n                unexpectedToken: 'Unexpected token.',\n                invalidIdentifier: 'Invalid Identifier.',\n                invalidPath: 'Please provide a valid path.',\n                throwError: function throwError(err, tokenizer, token) {\n                    if (token) {\n                        throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;\n                    }\n                    throw err + ' -- ' + tokenizer.parseString;\n                }\n            };\n        }, {}], 134: [function (require, module, exports) {\n            var Tokenizer = require(140);\n            var head = require(135);\n            var RoutedTokens = require(131);\n\n            var parser = function parser(string, extendedRules) {\n                return head(new Tokenizer(string, extendedRules));\n            };\n\n            module.exports = parser;\n\n            // Constructs the paths from paths / pathValues that have strings.\n            // If it does not have a string, just moves the value into the return\n            // results.\n            parser.fromPathsOrPathValues = function (paths, ext) {\n                if (!paths) {\n                    return [];\n                }\n\n                var out = [];\n                for (var i = 0, len = paths.length; i < len; i++) {\n\n                    // Is the path a string\n                    if (typeof paths[i] === 'string') {\n                        out[i] = parser(paths[i], ext);\n                    }\n\n                    // is the path a path value with a string value.\n                    else if (typeof paths[i].path === 'string') {\n                            out[i] = {\n                                path: parser(paths[i].path, ext), value: paths[i].value\n                            };\n                        }\n\n                        // just copy it over.\n                        else {\n                                out[i] = paths[i];\n                            }\n                }\n\n                return out;\n            };\n\n            // If the argument is a string, this with convert, else just return\n            // the path provided.\n            parser.fromPath = function (path, ext) {\n                if (!path) {\n                    return [];\n                }\n\n                if (typeof path === 'string') {\n                    return parser(path, ext);\n                }\n\n                return path;\n            };\n\n            // Potential routed tokens.\n            parser.RoutedTokens = RoutedTokens;\n        }, { \"131\": 131, \"135\": 135, \"140\": 140 }], 135: [function (require, module, exports) {\n            var TokenTypes = require(132);\n            var E = require(133);\n            var indexer = require(136);\n\n            /**\n             * The top level of the parse tree.  This returns the generated path\n             * from the tokenizer.\n             */\n            module.exports = function head(tokenizer) {\n                var token = tokenizer.next();\n                var state = {};\n                var out = [];\n\n                while (!token.done) {\n\n                    switch (token.type) {\n                        case TokenTypes.token:\n                            var first = +token.token[0];\n                            if (!isNaN(first)) {\n                                E.throwError(E.invalidIdentifier, tokenizer);\n                            }\n                            out[out.length] = token.token;\n                            break;\n\n                        // dotSeparators at the top level have no meaning\n                        case TokenTypes.dotSeparator:\n                            if (out.length === 0) {\n                                E.throwError(E.unexpectedToken, tokenizer);\n                            }\n                            break;\n\n                        // Spaces do nothing.\n                        case TokenTypes.space:\n                            // NOTE: Spaces at the top level are allowed.\n                            // titlesById  .summary is a valid path.\n                            break;\n\n                        // Its time to decend the parse tree.\n                        case TokenTypes.openingBracket:\n                            indexer(tokenizer, token, state, out);\n                            break;\n\n                        default:\n                            E.throwError(E.unexpectedToken, tokenizer);\n                            break;\n                    }\n\n                    // Keep cycling through the tokenizer.\n                    token = tokenizer.next();\n                }\n\n                if (out.length === 0) {\n                    E.throwError(E.invalidPath, tokenizer);\n                }\n\n                return out;\n            };\n        }, { \"132\": 132, \"133\": 133, \"136\": 136 }], 136: [function (require, module, exports) {\n            var TokenTypes = require(132);\n            var E = require(133);\n            var idxE = E.indexer;\n            var range = require(138);\n            var quote = require(137);\n            var routed = require(139);\n\n            /**\n             * The indexer is all the logic that happens in between\n             * the '[', opening bracket, and ']' closing bracket.\n             */\n            module.exports = function indexer(tokenizer, openingToken, state, out) {\n                var token = tokenizer.next();\n                var done = false;\n                var allowedMaxLength = 1;\n                var routedIndexer = false;\n\n                // State variables\n                state.indexer = [];\n\n                while (!token.done) {\n\n                    switch (token.type) {\n                        case TokenTypes.token:\n                        case TokenTypes.quote:\n\n                            // ensures that token adders are properly delimited.\n                            if (state.indexer.length === allowedMaxLength) {\n                                E.throwError(idxE.requiresComma, tokenizer);\n                            }\n                            break;\n                    }\n\n                    switch (token.type) {\n                        // Extended syntax case\n                        case TokenTypes.openingBrace:\n                            routedIndexer = true;\n                            routed(tokenizer, token, state, out);\n                            break;\n\n                        case TokenTypes.token:\n                            var t = +token.token;\n                            if (isNaN(t)) {\n                                E.throwError(idxE.needQuotes, tokenizer);\n                            }\n                            state.indexer[state.indexer.length] = t;\n                            break;\n\n                        // dotSeparators at the top level have no meaning\n                        case TokenTypes.dotSeparator:\n                            if (!state.indexer.length) {\n                                E.throwError(idxE.leadingDot, tokenizer);\n                            }\n                            range(tokenizer, token, state, out);\n                            break;\n\n                        // Spaces do nothing.\n                        case TokenTypes.space:\n                            break;\n\n                        case TokenTypes.closingBracket:\n                            done = true;\n                            break;\n\n                        // The quotes require their own tree due to what can be in it.\n                        case TokenTypes.quote:\n                            quote(tokenizer, token, state, out);\n                            break;\n\n                        // Its time to decend the parse tree.\n                        case TokenTypes.openingBracket:\n                            E.throwError(idxE.nested, tokenizer);\n                            break;\n\n                        case TokenTypes.commaSeparator:\n                            ++allowedMaxLength;\n                            break;\n\n                        default:\n                            E.throwError(E.unexpectedToken, tokenizer);\n                            break;\n                    }\n\n                    // If done, leave loop\n                    if (done) {\n                        break;\n                    }\n\n                    // Keep cycling through the tokenizer.\n                    token = tokenizer.next();\n                }\n\n                if (state.indexer.length === 0) {\n                    E.throwError(idxE.empty, tokenizer);\n                }\n\n                if (state.indexer.length > 1 && routedIndexer) {\n                    E.throwError(idxE.routedTokens, tokenizer);\n                }\n\n                // Remember, if an array of 1, keySets will be generated.\n                if (state.indexer.length === 1) {\n                    state.indexer = state.indexer[0];\n                }\n\n                out[out.length] = state.indexer;\n\n                // Clean state.\n                state.indexer = undefined;\n            };\n        }, { \"132\": 132, \"133\": 133, \"137\": 137, \"138\": 138, \"139\": 139 }], 137: [function (require, module, exports) {\n            var TokenTypes = require(132);\n            var E = require(133);\n            var quoteE = E.quote;\n\n            /**\n             * quote is all the parse tree in between quotes.  This includes the only\n             * escaping logic.\n             *\n             * parse-tree:\n             * <opening-quote>(.|(<escape><opening-quote>))*<opening-quote>\n             */\n            module.exports = function quote(tokenizer, openingToken, state, out) {\n                var token = tokenizer.next();\n                var innerToken = '';\n                var openingQuote = openingToken.token;\n                var escaping = false;\n                var done = false;\n\n                while (!token.done) {\n\n                    switch (token.type) {\n                        case TokenTypes.token:\n                        case TokenTypes.space:\n\n                        case TokenTypes.dotSeparator:\n                        case TokenTypes.commaSeparator:\n\n                        case TokenTypes.openingBracket:\n                        case TokenTypes.closingBracket:\n                        case TokenTypes.openingBrace:\n                        case TokenTypes.closingBrace:\n                            if (escaping) {\n                                E.throwError(quoteE.illegalEscape, tokenizer);\n                            }\n\n                            innerToken += token.token;\n                            break;\n\n                        case TokenTypes.quote:\n                            // the simple case.  We are escaping\n                            if (escaping) {\n                                innerToken += token.token;\n                                escaping = false;\n                            }\n\n                            // its not a quote that is the opening quote\n                            else if (token.token !== openingQuote) {\n                                    innerToken += token.token;\n                                }\n\n                                // last thing left.  Its a quote that is the opening quote\n                                // therefore we must produce the inner token of the indexer.\n                                else {\n                                        done = true;\n                                    }\n\n                            break;\n                        case TokenTypes.escape:\n                            escaping = true;\n                            break;\n\n                        default:\n                            E.throwError(E.unexpectedToken, tokenizer);\n                    }\n\n                    // If done, leave loop\n                    if (done) {\n                        break;\n                    }\n\n                    // Keep cycling through the tokenizer.\n                    token = tokenizer.next();\n                }\n\n                if (innerToken.length === 0) {\n                    E.throwError(quoteE.empty, tokenizer);\n                }\n\n                state.indexer[state.indexer.length] = innerToken;\n            };\n        }, { \"132\": 132, \"133\": 133 }], 138: [function (require, module, exports) {\n            var Tokenizer = require(140);\n            var TokenTypes = require(132);\n            var E = require(133);\n\n            /**\n             * The indexer is all the logic that happens in between\n             * the '[', opening bracket, and ']' closing bracket.\n             */\n            module.exports = function range(tokenizer, openingToken, state, out) {\n                var token = tokenizer.peek();\n                var dotCount = 1;\n                var done = false;\n                var inclusive = true;\n\n                // Grab the last token off the stack.  Must be an integer.\n                var idx = state.indexer.length - 1;\n                var from = Tokenizer.toNumber(state.indexer[idx]);\n                var to;\n\n                if (isNaN(from)) {\n                    E.throwError(E.range.precedingNaN, tokenizer);\n                }\n\n                // Why is number checking so difficult in javascript.\n\n                while (!done && !token.done) {\n\n                    switch (token.type) {\n\n                        // dotSeparators at the top level have no meaning\n                        case TokenTypes.dotSeparator:\n                            if (dotCount === 3) {\n                                E.throwError(E.unexpectedToken, tokenizer);\n                            }\n                            ++dotCount;\n\n                            if (dotCount === 3) {\n                                inclusive = false;\n                            }\n                            break;\n\n                        case TokenTypes.token:\n                            // move the tokenizer forward and save to.\n                            to = Tokenizer.toNumber(tokenizer.next().token);\n\n                            // throw potential error.\n                            if (isNaN(to)) {\n                                E.throwError(E.range.suceedingNaN, tokenizer);\n                            }\n\n                            done = true;\n                            break;\n\n                        default:\n                            done = true;\n                            break;\n                    }\n\n                    // Keep cycling through the tokenizer.  But ranges have to peek\n                    // before they go to the next token since there is no 'terminating'\n                    // character.\n                    if (!done) {\n                        tokenizer.next();\n\n                        // go to the next token without consuming.\n                        token = tokenizer.peek();\n                    }\n\n                    // break and remove state information.\n                    else {\n                            break;\n                        }\n                }\n\n                state.indexer[idx] = { from: from, to: inclusive ? to : to - 1 };\n            };\n        }, { \"132\": 132, \"133\": 133, \"140\": 140 }], 139: [function (require, module, exports) {\n            var TokenTypes = require(132);\n            var RoutedTokens = require(131);\n            var E = require(133);\n            var routedE = E.routed;\n\n            /**\n             * The routing logic.\n             *\n             * parse-tree:\n             * <opening-brace><routed-token>(:<token>)<closing-brace>\n             */\n            module.exports = function routed(tokenizer, openingToken, state, out) {\n                var routeToken = tokenizer.next();\n                var named = false;\n                var name = '';\n\n                // ensure the routed token is a valid ident.\n                switch (routeToken.token) {\n                    case RoutedTokens.integers:\n                    case RoutedTokens.ranges:\n                    case RoutedTokens.keys:\n                        //valid\n                        break;\n                    default:\n                        E.throwError(routedE.invalid, tokenizer);\n                        break;\n                }\n\n                // Now its time for colon or ending brace.\n                var next = tokenizer.next();\n\n                // we are parsing a named identifier.\n                if (next.type === TokenTypes.colon) {\n                    named = true;\n\n                    // Get the token name.\n                    next = tokenizer.next();\n                    if (next.type !== TokenTypes.token) {\n                        E.throwError(routedE.invalid, tokenizer);\n                    }\n                    name = next.token;\n\n                    // move to the closing brace.\n                    next = tokenizer.next();\n                }\n\n                // must close with a brace.\n\n                if (next.type === TokenTypes.closingBrace) {\n                    var outputToken = {\n                        type: routeToken.token,\n                        named: named,\n                        name: name\n                    };\n                    state.indexer[state.indexer.length] = outputToken;\n                }\n\n                // closing brace expected\n                else {\n                        E.throwError(routedE.invalid, tokenizer);\n                    }\n            };\n        }, { \"131\": 131, \"132\": 132, \"133\": 133 }], 140: [function (require, module, exports) {\n            var TokenTypes = require(132);\n            var DOT_SEPARATOR = '.';\n            var COMMA_SEPARATOR = ',';\n            var OPENING_BRACKET = '[';\n            var CLOSING_BRACKET = ']';\n            var OPENING_BRACE = '{';\n            var CLOSING_BRACE = '}';\n            var COLON = ':';\n            var ESCAPE = '\\\\';\n            var DOUBLE_OUOTES = '\"';\n            var SINGE_OUOTES = \"'\";\n            var SPACE = \" \";\n            var SPECIAL_CHARACTERS = '\\\\\\'\"[]., ';\n            var EXT_SPECIAL_CHARACTERS = '\\\\{}\\'\"[]., :';\n\n            var Tokenizer = module.exports = function (string, ext) {\n                this._string = string;\n                this._idx = -1;\n                this._extended = ext;\n                this.parseString = '';\n            };\n\n            Tokenizer.prototype = {\n                /**\n                 * grabs the next token either from the peek operation or generates the\n                 * next token.\n                 */\n                next: function next() {\n                    var nextToken = this._nextToken ? this._nextToken : getNext(this._string, this._idx, this._extended);\n\n                    this._idx = nextToken.idx;\n                    this._nextToken = false;\n                    this.parseString += nextToken.token.token;\n\n                    return nextToken.token;\n                },\n\n                /**\n                 * will peak but not increment the tokenizer\n                 */\n                peek: function peek() {\n                    var nextToken = this._nextToken ? this._nextToken : getNext(this._string, this._idx, this._extended);\n                    this._nextToken = nextToken;\n\n                    return nextToken.token;\n                }\n            };\n\n            Tokenizer.toNumber = function toNumber(x) {\n                if (!isNaN(+x)) {\n                    return +x;\n                }\n                return NaN;\n            };\n\n            function toOutput(token, type, done) {\n                return {\n                    token: token,\n                    done: done,\n                    type: type\n                };\n            }\n\n            function getNext(string, idx, ext) {\n                var output = false;\n                var token = '';\n                var specialChars = ext ? EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;\n                var done;\n\n                do {\n\n                    done = idx + 1 >= string.length;\n                    if (done) {\n                        break;\n                    }\n\n                    // we have to peek at the next token\n                    var character = string[idx + 1];\n\n                    if (character !== undefined && specialChars.indexOf(character) === -1) {\n\n                        token += character;\n                        ++idx;\n                        continue;\n                    }\n\n                    // The token to delimiting character transition.\n                    else if (token.length) {\n                            break;\n                        }\n\n                    ++idx;\n                    var type;\n                    switch (character) {\n                        case DOT_SEPARATOR:\n                            type = TokenTypes.dotSeparator;\n                            break;\n                        case COMMA_SEPARATOR:\n                            type = TokenTypes.commaSeparator;\n                            break;\n                        case OPENING_BRACKET:\n                            type = TokenTypes.openingBracket;\n                            break;\n                        case CLOSING_BRACKET:\n                            type = TokenTypes.closingBracket;\n                            break;\n                        case OPENING_BRACE:\n                            type = TokenTypes.openingBrace;\n                            break;\n                        case CLOSING_BRACE:\n                            type = TokenTypes.closingBrace;\n                            break;\n                        case SPACE:\n                            type = TokenTypes.space;\n                            break;\n                        case DOUBLE_OUOTES:\n                        case SINGE_OUOTES:\n                            type = TokenTypes.quote;\n                            break;\n                        case ESCAPE:\n                            type = TokenTypes.escape;\n                            break;\n                        case COLON:\n                            type = TokenTypes.colon;\n                            break;\n                        default:\n                            type = TokenTypes.unknown;\n                            break;\n                    }\n                    output = toOutput(character, type, false);\n                    break;\n                } while (!done);\n\n                if (!output && token.length) {\n                    output = toOutput(token, TokenTypes.token, false);\n                }\n\n                if (!output) {\n                    output = { done: true };\n                }\n\n                return {\n                    token: output,\n                    idx: idx\n                };\n            }\n        }, { \"132\": 132 }], 141: [function (require, module, exports) {\n            var toPaths = require(154);\n            var toTree = require(155);\n\n            module.exports = function collapse(paths) {\n                var collapseMap = paths.reduce(function (acc, path) {\n                    var len = path.length;\n                    if (!acc[len]) {\n                        acc[len] = [];\n                    }\n                    acc[len].push(path);\n                    return acc;\n                }, {});\n\n                Object.keys(collapseMap).forEach(function (collapseKey) {\n                    collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);\n                });\n\n                return toPaths(collapseMap);\n            };\n        }, { \"154\": 154, \"155\": 155 }], 142: [function (require, module, exports) {\n            /*eslint-disable*/\n            module.exports = {\n                innerReferences: 'References with inner references are not allowed.',\n                circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n            };\n        }, {}], 143: [function (require, module, exports) {\n            var cloneArray = require(152);\n            var $ref = require(153).$ref;\n            var errors = require(142);\n\n            /**\n             * performs the simplified cache reference follow.  This\n             * differs from get as there is just following and reporting,\n             * not much else.\n             *\n             * @param {Object} cacheRoot\n             * @param {Array} ref\n             */\n            module.exports = function followReference(cacheRoot, ref, maxRefFollow) {\n                var current = cacheRoot;\n                var refPath = ref;\n                var depth = -1;\n                var length = refPath.length;\n                var key, next, type;\n                var referenceCount = 0;\n\n                while (++depth < length) {\n                    key = refPath[depth];\n                    next = current[key];\n                    type = next && next.$type;\n\n                    if (!next || type && type !== $ref) {\n                        current = next;\n                        break;\n                    }\n\n                    // Show stopper exception.  This route is malformed.\n                    if (type && type === $ref && depth + 1 < length) {\n                        var err = new Error(errors.innerReferences);\n                        err.throwToNext = true;\n                        throw err;\n                    }\n\n                    // potentially follow reference\n                    if (depth + 1 === length) {\n                        if (type === $ref) {\n                            depth = -1;\n                            refPath = next.value;\n                            length = refPath.length;\n                            next = cacheRoot;\n                            referenceCount++;\n                        }\n\n                        if (referenceCount > maxRefFollow) {\n                            throw new Error(errors.circularReference);\n                        }\n                    }\n                    current = next;\n                }\n\n                return [current, cloneArray(refPath)];\n            };\n        }, { \"142\": 142, \"152\": 152, \"153\": 153 }], 144: [function (require, module, exports) {\n            var iterateKeySet = require(146);\n\n            /**\n             * Tests to see if the intersection should be stripped from the\n             * total paths.  The only way this happens currently is if the entirety\n             * of the path is contained in the tree.\n             * @private\n             */\n            module.exports = function hasIntersection(tree, path, depth) {\n                var current = tree;\n                var intersects = true;\n\n                // Continue iteratively going down a path until a complex key is\n                // encountered, then recurse.\n                for (; intersects && depth < path.length; ++depth) {\n                    var key = path[depth];\n                    var keyType = typeof key;\n\n                    // We have to iterate key set\n                    if (key && keyType === 'object') {\n                        var note = {};\n                        var innerKey = iterateKeySet(key, note);\n                        var nextDepth = depth + 1;\n\n                        // Loop through the innerKeys setting the intersects flag\n                        // to each result.  Break out on false.\n                        do {\n                            var next = current[innerKey];\n                            intersects = next !== undefined;\n\n                            if (intersects) {\n                                intersects = hasIntersection(next, path, nextDepth);\n                            }\n                            innerKey = iterateKeySet(key, note);\n                        } while (intersects && !note.done);\n\n                        // Since we recursed, we shall not pass any further!\n                        break;\n                    }\n\n                    // Its a simple key, just move forward with the testing.\n                    current = current[key];\n                    intersects = current !== undefined;\n                }\n\n                return intersects;\n            };\n        }, { \"146\": 146 }], 145: [function (require, module, exports) {\n            module.exports = {\n                iterateKeySet: require(146),\n                toTree: require(155),\n                pathsComplementFromTree: require(150),\n                pathsComplementFromLengthTree: require(149),\n                hasIntersection: require(144),\n                toPaths: require(154),\n                collapse: require(141),\n                optimizePathSets: require(147),\n                pathCount: require(148)\n            };\n        }, { \"141\": 141, \"144\": 144, \"146\": 146, \"147\": 147, \"148\": 148, \"149\": 149, \"150\": 150, \"154\": 154, \"155\": 155 }], 146: [function (require, module, exports) {\n            var isArray = Array.isArray;\n\n            /**\n             * Takes in a keySet and a note attempts to iterate over it.\n             * If the value is a primitive, the key will be returned and the note will\n             * be marked done\n             * If the value is an object, then each value of the range will be returned\n             * and when finished the note will be marked done.\n             * If the value is an array, each value will be iterated over, if any of the\n             * inner values are ranges, those will be iterated over.  When fully done,\n             * the note will be marked done.\n             *\n             * @param {Object|Array|String|Number} keySet -\n             * @param {Object} note - The non filled note\n             * @returns {String|Number|undefined} - The current iteration value.\n             * If undefined, then the keySet is empty\n             * @public\n             */\n            module.exports = function iterateKeySet(keySet, note) {\n                if (note.isArray === undefined) {\n                    initializeNote(keySet, note);\n                }\n\n                // Array iteration\n                if (note.isArray) {\n                    var nextValue;\n\n                    // Cycle through the array and pluck out the next value.\n                    do {\n                        if (note.loaded && note.rangeOffset > note.to) {\n                            ++note.arrayOffset;\n                            note.loaded = false;\n                        }\n\n                        var idx = note.arrayOffset,\n                            length = keySet.length;\n                        if (idx >= length) {\n                            note.done = true;\n                            break;\n                        }\n\n                        var el = keySet[note.arrayOffset];\n                        var type = typeof el;\n\n                        // Inner range iteration.\n                        if (type === 'object') {\n                            if (!note.loaded) {\n                                initializeRange(el, note);\n                            }\n\n                            // Empty to/from\n                            if (note.empty) {\n                                continue;\n                            }\n\n                            nextValue = note.rangeOffset++;\n                        }\n\n                        // Primitive iteration in array.\n                        else {\n                                ++note.arrayOffset;\n                                nextValue = el;\n                            }\n                    } while (nextValue === undefined);\n\n                    return nextValue;\n                }\n\n                // Range iteration\n                else if (note.isObject) {\n                        if (!note.loaded) {\n                            initializeRange(keySet, note);\n                        }\n                        if (note.rangeOffset > note.to) {\n                            note.done = true;\n                            return undefined;\n                        }\n\n                        return note.rangeOffset++;\n                    }\n\n                    // Primitive value\n                    else {\n                            note.done = true;\n                            return keySet;\n                        }\n            };\n\n            function initializeRange(key, memo) {\n                var from = memo.from = key.from || 0;\n                var to = memo.to = key.to || typeof key.length === 'number' && memo.from + key.length - 1 || 0;\n                memo.rangeOffset = memo.from;\n                memo.loaded = true;\n                if (from > to) {\n                    memo.empty = true;\n                }\n            }\n\n            function initializeNote(key, note) {\n                note.done = false;\n                var isObject = note.isObject = !!(key && typeof key === 'object');\n                note.isArray = isObject && isArray(key);\n                note.arrayOffset = 0;\n            }\n        }, {}], 147: [function (require, module, exports) {\n            var iterateKeySet = require(146);\n            var cloneArray = require(152);\n            var catAndSlice = require(151);\n            var $types = require(153);\n            var $ref = $types.$ref;\n            var followReference = require(143);\n\n            /**\n             * The fastest possible optimize of paths.\n             *\n             * What it does:\n             * - Any atom short-circuit / found value will be removed from the path.\n             * - All paths will be exploded which means that collapse will need to be\n             *   ran afterwords.\n             * - Any missing path will be optimized as much as possible.\n             */\n            module.exports = function optimizePathSets(cache, paths, maxRefFollow) {\n                var optimized = [];\n                paths.forEach(function (p) {\n                    optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);\n                });\n\n                return optimized;\n            };\n\n            /**\n             * optimizes one pathSet at a time.\n             */\n            function optimizePathSet(cache, cacheRoot, pathSet, depth, out, optimizedPath, maxRefFollow) {\n\n                // at missing, report optimized path.\n                if (cache === undefined) {\n                    out[out.length] = catAndSlice(optimizedPath, pathSet, depth);\n                    return;\n                }\n\n                // all other sentinels are short circuited.\n                // Or we found a primitive (which includes null)\n                if (cache === null || cache.$type && cache.$type !== $ref || typeof cache !== 'object') {\n                    return;\n                }\n\n                // If the reference is the last item in the path then do not\n                // continue to search it.\n                if (cache.$type === $ref && depth === pathSet.length) {\n                    return;\n                }\n\n                var keySet = pathSet[depth];\n                var isKeySet = typeof keySet === 'object';\n                var nextDepth = depth + 1;\n                var iteratorNote = false;\n                var key = keySet;\n                if (isKeySet) {\n                    iteratorNote = {};\n                    key = iterateKeySet(keySet, iteratorNote);\n                }\n                var next, nextOptimized;\n                do {\n                    next = cache[key];\n                    var optimizedPathLength = optimizedPath.length;\n                    if (key !== null) {\n                        optimizedPath[optimizedPathLength] = key;\n                    }\n\n                    if (next && next.$type === $ref && nextDepth < pathSet.length) {\n                        var refResults = followReference(cacheRoot, next.value, maxRefFollow);\n                        next = refResults[0];\n\n                        // must clone to avoid the mutation from above destroying the cache.\n                        nextOptimized = cloneArray(refResults[1]);\n                    } else {\n                        nextOptimized = optimizedPath;\n                    }\n\n                    optimizePathSet(next, cacheRoot, pathSet, nextDepth, out, nextOptimized, maxRefFollow);\n                    optimizedPath.length = optimizedPathLength;\n\n                    if (iteratorNote && !iteratorNote.done) {\n                        key = iterateKeySet(keySet, iteratorNote);\n                    }\n                } while (iteratorNote && !iteratorNote.done);\n            }\n        }, { \"143\": 143, \"146\": 146, \"151\": 151, \"152\": 152, \"153\": 153 }], 148: [function (require, module, exports) {\n            \"use strict\";\n\n            /**\n             * Helper for getPathCount. Used to determine the size of a key or range.\n             * @function\n             * @param {Object} rangeOrKey\n             * @return The size of the key or range passed in.\n             */\n\n            function getRangeOrKeySize(rangeOrKey) {\n                if (rangeOrKey == null) {\n                    return 1;\n                } else if (Array.isArray(rangeOrKey)) {\n                    throw new Error(\"Unexpected Array found in keySet: \" + JSON.stringify(rangeOrKey));\n                } else if (typeof rangeOrKey === \"object\") {\n                    return getRangeSize(rangeOrKey);\n                } else {\n                    return 1;\n                }\n            }\n\n            /**\n             * Returns the size (number of items) in a Range,\n             * @function\n             * @param {Object} range The Range with both \"from\" and \"to\", or just \"to\"\n             * @return The number of items in the range.\n             */\n            function getRangeSize(range) {\n\n                var to = range.to;\n                var length = range.length;\n\n                if (to != null) {\n                    if (isNaN(to) || parseInt(to, 10) !== to) {\n                        throw new Error(\"Invalid range, 'to' is not an integer: \" + JSON.stringify(range));\n                    }\n                    var from = range.from || 0;\n                    if (isNaN(from) || parseInt(from, 10) !== from) {\n                        throw new Error(\"Invalid range, 'from' is not an integer: \" + JSON.stringify(range));\n                    }\n                    if (from <= to) {\n                        return to - from + 1;\n                    } else {\n                        return 0;\n                    }\n                } else if (length != null) {\n                    if (isNaN(length) || parseInt(length, 10) !== length) {\n                        throw new Error(\"Invalid range, 'length' is not an integer: \" + JSON.stringify(range));\n                    } else {\n                        return length;\n                    }\n                } else {\n                    throw new Error(\"Invalid range, expected 'to' or 'length': \" + JSON.stringify(range));\n                }\n            }\n\n            /**\n             * Returns a count of the number of paths this pathset\n             * represents.\n             *\n             * For example, [\"foo\", {\"from\":0, \"to\":10}, \"bar\"],\n             * would represent 11 paths (0 to 10, inclusive), and\n             * [\"foo, [\"baz\", \"boo\"], \"bar\"] would represent 2 paths.\n             *\n             * @function\n             * @param {Object[]} pathSet the path set.\n             *\n             * @return The number of paths this represents\n             */\n            function getPathCount(pathSet) {\n                if (pathSet.length === 0) {\n                    throw new Error(\"All paths must have length larger than zero.\");\n                }\n\n                var numPaths = 1;\n\n                for (var i = 0; i < pathSet.length; i++) {\n                    var segment = pathSet[i];\n\n                    if (Array.isArray(segment)) {\n\n                        var numKeys = 0;\n\n                        for (var j = 0; j < segment.length; j++) {\n                            var keySet = segment[j];\n\n                            numKeys += getRangeOrKeySize(keySet);\n                        }\n\n                        numPaths *= numKeys;\n                    } else {\n                        numPaths *= getRangeOrKeySize(segment);\n                    }\n                }\n\n                return numPaths;\n            }\n\n            module.exports = getPathCount;\n        }, {}], 149: [function (require, module, exports) {\n            var hasIntersection = require(144);\n\n            /**\n             * Compares the paths passed in with the tree.  Any of the paths that are in\n             * the tree will be stripped from the paths.\n             *\n             * **Does not mutate** the incoming paths object.\n             * **Proper subset** only matching.\n             *\n             * @param {Array} paths - A list of paths (complex or simple) to strip the\n             * intersection\n             * @param {Object} tree -\n             * @public\n             */\n            module.exports = function pathsComplementFromLengthTree(paths, tree) {\n                var out = [];\n                var outLength = -1;\n\n                for (var i = 0, len = paths.length; i < len; ++i) {\n                    // If this does not intersect then add it to the output.\n                    var path = paths[i];\n                    if (!hasIntersection(tree[path.length], path, 0)) {\n                        out[++outLength] = path;\n                    }\n                }\n                return out;\n            };\n        }, { \"144\": 144 }], 150: [function (require, module, exports) {\n            var hasIntersection = require(144);\n\n            /**\n             * Compares the paths passed in with the tree.  Any of the paths that are in\n             * the tree will be stripped from the paths.\n             *\n             * **Does not mutate** the incoming paths object.\n             * **Proper subset** only matching.\n             *\n             * @param {Array} paths - A list of paths (complex or simple) to strip the\n             * intersection\n             * @param {Object} tree -\n             * @public\n             */\n            module.exports = function pathsComplementFromTree(paths, tree) {\n                var out = [];\n                var outLength = -1;\n\n                for (var i = 0, len = paths.length; i < len; ++i) {\n                    // If this does not intersect then add it to the output.\n                    if (!hasIntersection(tree, paths[i], 0)) {\n                        out[++outLength] = paths[i];\n                    }\n                }\n                return out;\n            };\n        }, { \"144\": 144 }], 151: [function (require, module, exports) {\n            module.exports = function catAndSlice(a, b, slice) {\n                var next = [],\n                    i,\n                    j,\n                    len;\n                for (i = 0, len = a.length; i < len; ++i) {\n                    next[i] = a[i];\n                }\n\n                for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n                    next[i] = b[j];\n                }\n\n                return next;\n            };\n        }, {}], 152: [function (require, module, exports) {\n            function cloneArray(arr, index) {\n                var a = [];\n                var len = arr.length;\n                for (var i = index || 0; i < len; i++) {\n                    a[i] = arr[i];\n                }\n                return a;\n            }\n\n            module.exports = cloneArray;\n        }, {}], 153: [function (require, module, exports) {\n            module.exports = {\n                $ref: 'ref',\n                $atom: 'atom',\n                $error: 'error'\n            };\n        }, {}], 154: [function (require, module, exports) {\n            var isArray = Array.isArray;\n            var typeOfObject = \"object\";\n            var typeOfString = \"string\";\n            var typeOfNumber = \"number\";\n            var MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\n            var MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\n            var MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\n            var abs = Math.abs;\n            var safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\n\n            /* jshint forin: false */\n            module.exports = function toPaths(lengths) {\n                var pathmap;\n                var allPaths = [];\n                var allPathsLength = 0;\n                for (var length in lengths) {\n                    if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n                        var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n                        var pathsIndex = -1;\n                        var pathsCount = paths.length;\n                        while (++pathsIndex < pathsCount) {\n                            allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n                        }\n                    }\n                }\n                return allPaths;\n            };\n\n            function isObject(value) {\n                return value !== null && typeof value === typeOfObject;\n            }\n\n            function collapsePathMap(pathmap, depth, length) {\n\n                var key;\n                var code = getHashCode(String(depth));\n                var subs = Object.create(null);\n\n                var codes = [];\n                var codesIndex = -1;\n                var codesCount = 0;\n\n                var pathsets = [];\n                var pathsetsCount = 0;\n\n                var subPath, subCode, subKeys, subKeysIndex, subKeysCount, subSets, subSetsIndex, subSetsCount, pathset, pathsetIndex, pathsetCount, firstSubKey, pathsetClone;\n\n                subKeys = [];\n                subKeysIndex = -1;\n\n                if (depth < length - 1) {\n\n                    subKeysCount = getSortedKeys(pathmap, subKeys);\n\n                    while (++subKeysIndex < subKeysCount) {\n                        key = subKeys[subKeysIndex];\n                        subPath = collapsePathMap(pathmap[key], depth + 1, length);\n                        subCode = subPath.code;\n                        if (subs[subCode]) {\n                            subPath = subs[subCode];\n                        } else {\n                            codes[codesCount++] = subCode;\n                            subPath = subs[subCode] = {\n                                keys: [],\n                                sets: subPath.sets\n                            };\n                        }\n                        code = getHashCode(code + key + subCode);\n\n                        isSafeNumber(key) && subPath.keys.push(parseInt(key, 10)) || subPath.keys.push(key);\n                    }\n\n                    while (++codesIndex < codesCount) {\n\n                        key = codes[codesIndex];\n                        subPath = subs[key];\n                        subKeys = subPath.keys;\n                        subKeysCount = subKeys.length;\n\n                        if (subKeysCount > 0) {\n\n                            subSets = subPath.sets;\n                            subSetsIndex = -1;\n                            subSetsCount = subSets.length;\n                            firstSubKey = subKeys[0];\n\n                            while (++subSetsIndex < subSetsCount) {\n\n                                pathset = subSets[subSetsIndex];\n                                pathsetIndex = -1;\n                                pathsetCount = pathset.length;\n                                pathsetClone = new Array(pathsetCount + 1);\n                                pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                                while (++pathsetIndex < pathsetCount) {\n                                    pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                                }\n\n                                pathsets[pathsetsCount++] = pathsetClone;\n                            }\n                        }\n                    }\n                } else {\n                    subKeysCount = getSortedKeys(pathmap, subKeys);\n                    if (subKeysCount > 1) {\n                        pathsets[pathsetsCount++] = [subKeys];\n                    } else {\n                        pathsets[pathsetsCount++] = subKeys;\n                    }\n                    while (++subKeysIndex < subKeysCount) {\n                        code = getHashCode(code + subKeys[subKeysIndex]);\n                    }\n                }\n\n                return {\n                    code: code,\n                    sets: pathsets\n                };\n            }\n\n            function collapsePathSetIndexes(pathset) {\n\n                var keysetIndex = -1;\n                var keysetCount = pathset.length;\n\n                while (++keysetIndex < keysetCount) {\n                    var keyset = pathset[keysetIndex];\n                    if (isArray(keyset)) {\n                        pathset[keysetIndex] = collapseIndex(keyset);\n                    }\n                }\n\n                return pathset;\n            }\n\n            /**\n             * Collapse range indexers, e.g. when there is a continuous\n             * range in an array, turn it into an object instead:\n             *\n             * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n             *\n             * @private\n             */\n            function collapseIndex(keyset) {\n\n                // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n                // var hash = {};\n                var keyIndex = -1;\n                var keyCount = keyset.length - 1;\n                var isSparseRange = keyCount > 0;\n\n                while (++keyIndex <= keyCount) {\n\n                    var key = keyset[keyIndex];\n\n                    if (!isSafeNumber(key) /* || hash[key] === true*/) {\n                            isSparseRange = false;\n                            break;\n                        }\n                    // hash[key] = true;\n                    // Cast number indexes to integers.\n                    keyset[keyIndex] = parseInt(key, 10);\n                }\n\n                if (isSparseRange === true) {\n\n                    keyset.sort(sortListAscending);\n\n                    var from = keyset[0];\n                    var to = keyset[keyCount];\n\n                    // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n                    if (to - from <= keyCount) {\n                        return {\n                            from: from,\n                            to: to\n                        };\n                    }\n                }\n\n                return keyset;\n            }\n\n            function sortListAscending(a, b) {\n                return a - b;\n            }\n\n            /* jshint forin: false */\n            function getSortedKeys(map, keys, sort) {\n                var len = 0;\n                for (var key in map) {\n                    keys[len++] = key;\n                }\n                if (len > 1) {\n                    keys.sort(sort);\n                }\n                return len;\n            }\n\n            function getHashCode(key) {\n                var code = 5381;\n                var index = -1;\n                var count = key.length;\n                while (++index < count) {\n                    code = (code << 5) + code + key.charCodeAt(index);\n                }\n                return String(code);\n            }\n\n            /**\n             * Return true if argument is a number or can be cast to a number which\n             * roundtrips to the same string.\n             * @private\n             */\n            function isSafeNumber(val) {\n                var num = val;\n                var type = typeof val;\n                if (type === typeOfString) {\n                    var length = val.length;\n                    // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n                    // Anything longer cannot be safe.\n                    if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n                        return false;\n                    }\n                    if (!safeNumberRegEx.test(val)) {\n                        return false;\n                    }\n                    // Number.MAX_SAFE_INTEGER is 16 digits.\n                    // Anything shorter must be safe.\n                    if (length < MAX_SAFE_INTEGER_DIGITS) {\n                        return true;\n                    }\n                    num = +val;\n                } else if (type !== typeOfNumber) {\n                    return false;\n                }\n                // Number.isSafeInteger(num) in es6.\n                return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n            }\n\n            // export for testing\n            module.exports._isSafeNumber = isSafeNumber;\n        }, {}], 155: [function (require, module, exports) {\n            var iterateKeySet = require(146);\n            var isArray = Array.isArray;\n\n            /**\n             * @param {Array} paths -\n             * @returns {Object} -\n             */\n            module.exports = function toTree(paths) {\n                return paths.reduce(function (acc, path) {\n                    innerToTree(acc, path, 0);\n                    return acc;\n                }, {});\n            };\n\n            function innerToTree(seed, path, depth) {\n\n                var keySet = path[depth];\n                var iteratorNote = {};\n                var key;\n                var nextDepth = depth + 1;\n\n                key = iterateKeySet(keySet, iteratorNote);\n\n                do {\n\n                    var next = seed[key];\n                    if (!next) {\n                        if (nextDepth === path.length) {\n                            seed[key] = null;\n                        } else {\n                            next = seed[key] = {};\n                        }\n                    }\n\n                    if (nextDepth < path.length) {\n                        innerToTree(next, path, nextDepth);\n                    }\n\n                    if (!iteratorNote.done) {\n                        key = iterateKeySet(keySet, iteratorNote);\n                    }\n                } while (!iteratorNote.done);\n            }\n        }, { \"146\": 146 }], 156: [function (require, module, exports) {\n            'use strict';\n\n            module.exports = require(161);\n        }, { \"161\": 161 }], 157: [function (require, module, exports) {\n            'use strict';\n\n            var asap = require(122);\n\n            function noop() {}\n\n            // States:\n            //\n            // 0 - pending\n            // 1 - fulfilled with _value\n            // 2 - rejected with _value\n            // 3 - adopted the state of another promise, _value\n            //\n            // once the state is no longer pending (0) it is immutable\n\n            // All `_` prefixed properties will be reduced to `_{random number}`\n            // at build time to obfuscate them and discourage their use.\n            // We don't use symbols or Object.defineProperty to fully hide them\n            // because the performance isn't good enough.\n\n\n            // to avoid using try/catch inside critical functions, we\n            // extract them to here.\n            var LAST_ERROR = null;\n            var IS_ERROR = {};\n            function getThen(obj) {\n                try {\n                    return obj.then;\n                } catch (ex) {\n                    LAST_ERROR = ex;\n                    return IS_ERROR;\n                }\n            }\n\n            function tryCallOne(fn, a) {\n                try {\n                    return fn(a);\n                } catch (ex) {\n                    LAST_ERROR = ex;\n                    return IS_ERROR;\n                }\n            }\n            function tryCallTwo(fn, a, b) {\n                try {\n                    fn(a, b);\n                } catch (ex) {\n                    LAST_ERROR = ex;\n                    return IS_ERROR;\n                }\n            }\n\n            module.exports = Promise;\n\n            function Promise(fn) {\n                if (typeof this !== 'object') {\n                    throw new TypeError('Promises must be constructed via new');\n                }\n                if (typeof fn !== 'function') {\n                    throw new TypeError('Promise constructor\\'s argument is not a function');\n                }\n                this._75 = 0;\n                this._83 = 0;\n                this._18 = null;\n                this._38 = null;\n                if (fn === noop) return;\n                doResolve(fn, this);\n            }\n            Promise._47 = null;\n            Promise._71 = null;\n            Promise._44 = noop;\n\n            Promise.prototype.then = function (onFulfilled, onRejected) {\n                if (this.constructor !== Promise) {\n                    return safeThen(this, onFulfilled, onRejected);\n                }\n                var res = new Promise(noop);\n                handle(this, new Handler(onFulfilled, onRejected, res));\n                return res;\n            };\n\n            function safeThen(self, onFulfilled, onRejected) {\n                return new self.constructor(function (resolve, reject) {\n                    var res = new Promise(noop);\n                    res.then(resolve, reject);\n                    handle(self, new Handler(onFulfilled, onRejected, res));\n                });\n            }\n            function handle(self, deferred) {\n                while (self._83 === 3) {\n                    self = self._18;\n                }\n                if (Promise._47) {\n                    Promise._47(self);\n                }\n                if (self._83 === 0) {\n                    if (self._75 === 0) {\n                        self._75 = 1;\n                        self._38 = deferred;\n                        return;\n                    }\n                    if (self._75 === 1) {\n                        self._75 = 2;\n                        self._38 = [self._38, deferred];\n                        return;\n                    }\n                    self._38.push(deferred);\n                    return;\n                }\n                handleResolved(self, deferred);\n            }\n\n            function handleResolved(self, deferred) {\n                asap(function () {\n                    var cb = self._83 === 1 ? deferred.onFulfilled : deferred.onRejected;\n                    if (cb === null) {\n                        if (self._83 === 1) {\n                            resolve(deferred.promise, self._18);\n                        } else {\n                            reject(deferred.promise, self._18);\n                        }\n                        return;\n                    }\n                    var ret = tryCallOne(cb, self._18);\n                    if (ret === IS_ERROR) {\n                        reject(deferred.promise, LAST_ERROR);\n                    } else {\n                        resolve(deferred.promise, ret);\n                    }\n                });\n            }\n            function resolve(self, newValue) {\n                // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n                if (newValue === self) {\n                    return reject(self, new TypeError('A promise cannot be resolved with itself.'));\n                }\n                if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n                    var then = getThen(newValue);\n                    if (then === IS_ERROR) {\n                        return reject(self, LAST_ERROR);\n                    }\n                    if (then === self.then && newValue instanceof Promise) {\n                        self._83 = 3;\n                        self._18 = newValue;\n                        finale(self);\n                        return;\n                    } else if (typeof then === 'function') {\n                        doResolve(then.bind(newValue), self);\n                        return;\n                    }\n                }\n                self._83 = 1;\n                self._18 = newValue;\n                finale(self);\n            }\n\n            function reject(self, newValue) {\n                self._83 = 2;\n                self._18 = newValue;\n                if (Promise._71) {\n                    Promise._71(self, newValue);\n                }\n                finale(self);\n            }\n            function finale(self) {\n                if (self._75 === 1) {\n                    handle(self, self._38);\n                    self._38 = null;\n                }\n                if (self._75 === 2) {\n                    for (var i = 0; i < self._38.length; i++) {\n                        handle(self, self._38[i]);\n                    }\n                    self._38 = null;\n                }\n            }\n\n            function Handler(onFulfilled, onRejected, promise) {\n                this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n                this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n                this.promise = promise;\n            }\n\n            /**\n             * Take a potentially misbehaving resolver function and make sure\n             * onFulfilled and onRejected are only called once.\n             *\n             * Makes no guarantees about asynchrony.\n             */\n            function doResolve(fn, promise) {\n                var done = false;\n                var res = tryCallTwo(fn, function (value) {\n                    if (done) return;\n                    done = true;\n                    resolve(promise, value);\n                }, function (reason) {\n                    if (done) return;\n                    done = true;\n                    reject(promise, reason);\n                });\n                if (!done && res === IS_ERROR) {\n                    done = true;\n                    reject(promise, LAST_ERROR);\n                }\n            }\n        }, { \"122\": 122 }], 158: [function (require, module, exports) {\n            'use strict';\n\n            var Promise = require(157);\n\n            module.exports = Promise;\n            Promise.prototype.done = function (onFulfilled, onRejected) {\n                var self = arguments.length ? this.then.apply(this, arguments) : this;\n                self.then(null, function (err) {\n                    setTimeout(function () {\n                        throw err;\n                    }, 0);\n                });\n            };\n        }, { \"157\": 157 }], 159: [function (require, module, exports) {\n            'use strict';\n\n            //This file contains the ES6 extensions to the core Promises/A+ API\n\n            var Promise = require(157);\n\n            module.exports = Promise;\n\n            /* Static Functions */\n\n            var TRUE = valuePromise(true);\n            var FALSE = valuePromise(false);\n            var NULL = valuePromise(null);\n            var UNDEFINED = valuePromise(undefined);\n            var ZERO = valuePromise(0);\n            var EMPTYSTRING = valuePromise('');\n\n            function valuePromise(value) {\n                var p = new Promise(Promise._44);\n                p._83 = 1;\n                p._18 = value;\n                return p;\n            }\n            Promise.resolve = function (value) {\n                if (value instanceof Promise) return value;\n\n                if (value === null) return NULL;\n                if (value === undefined) return UNDEFINED;\n                if (value === true) return TRUE;\n                if (value === false) return FALSE;\n                if (value === 0) return ZERO;\n                if (value === '') return EMPTYSTRING;\n\n                if (typeof value === 'object' || typeof value === 'function') {\n                    try {\n                        var then = value.then;\n                        if (typeof then === 'function') {\n                            return new Promise(then.bind(value));\n                        }\n                    } catch (ex) {\n                        return new Promise(function (resolve, reject) {\n                            reject(ex);\n                        });\n                    }\n                }\n                return valuePromise(value);\n            };\n\n            Promise.all = function (arr) {\n                var args = Array.prototype.slice.call(arr);\n\n                return new Promise(function (resolve, reject) {\n                    if (args.length === 0) return resolve([]);\n                    var remaining = args.length;\n                    function res(i, val) {\n                        if (val && (typeof val === 'object' || typeof val === 'function')) {\n                            if (val instanceof Promise && val.then === Promise.prototype.then) {\n                                while (val._83 === 3) {\n                                    val = val._18;\n                                }\n                                if (val._83 === 1) return res(i, val._18);\n                                if (val._83 === 2) reject(val._18);\n                                val.then(function (val) {\n                                    res(i, val);\n                                }, reject);\n                                return;\n                            } else {\n                                var then = val.then;\n                                if (typeof then === 'function') {\n                                    var p = new Promise(then.bind(val));\n                                    p.then(function (val) {\n                                        res(i, val);\n                                    }, reject);\n                                    return;\n                                }\n                            }\n                        }\n                        args[i] = val;\n                        if (--remaining === 0) {\n                            resolve(args);\n                        }\n                    }\n                    for (var i = 0; i < args.length; i++) {\n                        res(i, args[i]);\n                    }\n                });\n            };\n\n            Promise.reject = function (value) {\n                return new Promise(function (resolve, reject) {\n                    reject(value);\n                });\n            };\n\n            Promise.race = function (values) {\n                return new Promise(function (resolve, reject) {\n                    values.forEach(function (value) {\n                        Promise.resolve(value).then(resolve, reject);\n                    });\n                });\n            };\n\n            /* Prototype Methods */\n\n            Promise.prototype['catch'] = function (onRejected) {\n                return this.then(null, onRejected);\n            };\n        }, { \"157\": 157 }], 160: [function (require, module, exports) {\n            'use strict';\n\n            var Promise = require(157);\n\n            module.exports = Promise;\n            Promise.prototype['finally'] = function (f) {\n                return this.then(function (value) {\n                    return Promise.resolve(f()).then(function () {\n                        return value;\n                    });\n                }, function (err) {\n                    return Promise.resolve(f()).then(function () {\n                        throw err;\n                    });\n                });\n            };\n        }, { \"157\": 157 }], 161: [function (require, module, exports) {\n            'use strict';\n\n            module.exports = require(157);\n            require(158);\n            require(160);\n            require(159);\n            require(162);\n            require(163);\n        }, { \"157\": 157, \"158\": 158, \"159\": 159, \"160\": 160, \"162\": 162, \"163\": 163 }], 162: [function (require, module, exports) {\n            'use strict';\n\n            // This file contains then/promise specific extensions that are only useful\n            // for node.js interop\n\n            var Promise = require(157);\n            var asap = require(121);\n\n            module.exports = Promise;\n\n            /* Static Functions */\n\n            Promise.denodeify = function (fn, argumentCount) {\n                if (typeof argumentCount === 'number' && argumentCount !== Infinity) {\n                    return denodeifyWithCount(fn, argumentCount);\n                } else {\n                    return denodeifyWithoutCount(fn);\n                }\n            };\n\n            var callbackFn = 'function (err, res) {' + 'if (err) { rj(err); } else { rs(res); }' + '}';\n            function denodeifyWithCount(fn, argumentCount) {\n                var args = [];\n                for (var i = 0; i < argumentCount; i++) {\n                    args.push('a' + i);\n                }\n                var body = ['return function (' + args.join(',') + ') {', 'var self = this;', 'return new Promise(function (rs, rj) {', 'var res = fn.call(', ['self'].concat(args).concat([callbackFn]).join(','), ');', 'if (res &&', '(typeof res === \"object\" || typeof res === \"function\") &&', 'typeof res.then === \"function\"', ') {rs(res);}', '});', '};'].join('');\n                return Function(['Promise', 'fn'], body)(Promise, fn);\n            }\n            function denodeifyWithoutCount(fn) {\n                var fnLength = Math.max(fn.length - 1, 3);\n                var args = [];\n                for (var i = 0; i < fnLength; i++) {\n                    args.push('a' + i);\n                }\n                var body = ['return function (' + args.join(',') + ') {', 'var self = this;', 'var args;', 'var argLength = arguments.length;', 'if (arguments.length > ' + fnLength + ') {', 'args = new Array(arguments.length + 1);', 'for (var i = 0; i < arguments.length; i++) {', 'args[i] = arguments[i];', '}', '}', 'return new Promise(function (rs, rj) {', 'var cb = ' + callbackFn + ';', 'var res;', 'switch (argLength) {', args.concat(['extra']).map(function (_, index) {\n                    return 'case ' + index + ':' + 'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' + 'break;';\n                }).join(''), 'default:', 'args[argLength] = cb;', 'res = fn.apply(self, args);', '}', 'if (res &&', '(typeof res === \"object\" || typeof res === \"function\") &&', 'typeof res.then === \"function\"', ') {rs(res);}', '});', '};'].join('');\n\n                return Function(['Promise', 'fn'], body)(Promise, fn);\n            }\n\n            Promise.nodeify = function (fn) {\n                return function () {\n                    var args = Array.prototype.slice.call(arguments);\n                    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;\n                    var ctx = this;\n                    try {\n                        return fn.apply(this, arguments).nodeify(callback, ctx);\n                    } catch (ex) {\n                        if (callback === null || typeof callback == 'undefined') {\n                            return new Promise(function (resolve, reject) {\n                                reject(ex);\n                            });\n                        } else {\n                            asap(function () {\n                                callback.call(ctx, ex);\n                            });\n                        }\n                    }\n                };\n            };\n\n            Promise.prototype.nodeify = function (callback, ctx) {\n                if (typeof callback != 'function') return this;\n\n                this.then(function (value) {\n                    asap(function () {\n                        callback.call(ctx, null, value);\n                    });\n                }, function (err) {\n                    asap(function () {\n                        callback.call(ctx, err);\n                    });\n                });\n            };\n        }, { \"121\": 121, \"157\": 157 }], 163: [function (require, module, exports) {\n            'use strict';\n\n            var Promise = require(157);\n\n            module.exports = Promise;\n            Promise.enableSynchronous = function () {\n                Promise.prototype.isPending = function () {\n                    return this.getState() == 0;\n                };\n\n                Promise.prototype.isFulfilled = function () {\n                    return this.getState() == 1;\n                };\n\n                Promise.prototype.isRejected = function () {\n                    return this.getState() == 2;\n                };\n\n                Promise.prototype.getValue = function () {\n                    if (this._83 === 3) {\n                        return this._18.getValue();\n                    }\n\n                    if (!this.isFulfilled()) {\n                        throw new Error('Cannot get a value of an unfulfilled promise.');\n                    }\n\n                    return this._18;\n                };\n\n                Promise.prototype.getReason = function () {\n                    if (this._83 === 3) {\n                        return this._18.getReason();\n                    }\n\n                    if (!this.isRejected()) {\n                        throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n                    }\n\n                    return this._18;\n                };\n\n                Promise.prototype.getState = function () {\n                    if (this._83 === 3) {\n                        return this._18.getState();\n                    }\n                    if (this._83 === -1 || this._83 === -2) {\n                        return 0;\n                    }\n\n                    return this._83;\n                };\n            };\n\n            Promise.disableSynchronous = function () {\n                Promise.prototype.isPending = undefined;\n                Promise.prototype.isFulfilled = undefined;\n                Promise.prototype.isRejected = undefined;\n                Promise.prototype.getValue = undefined;\n                Promise.prototype.getReason = undefined;\n                Promise.prototype.getState = undefined;\n            };\n        }, { \"157\": 157 }], 164: [function (require, module, exports) {\n            (function (global) {\n                'use strict';\n\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n\n                var _ponyfill = require(165);\n\n                var _ponyfill2 = _interopRequireDefault(_ponyfill);\n\n                function _interopRequireDefault(obj) {\n                    return obj && obj.__esModule ? obj : { 'default': obj };\n                }\n\n                var root; /* global window */\n\n                if (typeof self !== 'undefined') {\n                    root = self;\n                } else if (typeof window !== 'undefined') {\n                    root = window;\n                } else if (typeof global !== 'undefined') {\n                    root = global;\n                } else if (typeof module !== 'undefined') {\n                    root = module;\n                } else {\n                    root = Function('return this')();\n                }\n\n                var result = (0, _ponyfill2['default'])(root);\n                exports['default'] = result;\n            }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n        }, { \"165\": 165 }], 165: [function (require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, \"__esModule\", {\n                value: true\n            });\n            exports['default'] = symbolObservablePonyfill;\n            function symbolObservablePonyfill(root) {\n                var result;\n                var _Symbol = root.Symbol;\n\n                if (typeof _Symbol === 'function') {\n                    if (_Symbol.observable) {\n                        result = _Symbol.observable;\n                    } else {\n                        result = _Symbol('observable');\n                        _Symbol.observable = result;\n                    }\n                } else {\n                    result = '@@observable';\n                }\n\n                return result;\n            };\n        }, {}] }, {}, [1])(1);\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"h6ac\")))\n\n/***/ }),\n\n/***/ \"h6ac\":\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n\n/***/ \"kTIn\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"LFiD\");\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(\"BMrJ\")(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js??ref--4-2!../../../node_modules/postcss-loader/lib/index.js??postcss!../../../node_modules/preact-cli/lib/lib/webpack/proxy-loader.js??ref--2-0!./style.scss\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js??ref--4-2!../../../node_modules/postcss-loader/lib/index.js??postcss!../../../node_modules/preact-cli/lib/lib/webpack/proxy-loader.js??ref--2-0!./style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/***/ }),\n\n/***/ \"lcwS\":\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif (item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function (modules, mediaQuery) {\n\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t}\n\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n/***/ }),\n\n/***/ \"m+Gh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nif (!global.Promise) global.Promise = __webpack_require__(\"BtxX\");\nif (!global.fetch) global.fetch = __webpack_require__(\"VS7n\");\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"h6ac\")))\n\n/***/ }),\n\n/***/ \"pwNi\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _preact = __webpack_require__(\"KM04\");\n\nif (false) {\n\trequire('preact/devtools');\n} else if (false) {\n\tnavigator.serviceWorker.register(__webpack_public_path__ + 'sw.js');\n}\n\nvar interopDefault = function interopDefault(m) {\n\treturn m && m.default ? m.default : m;\n};\n\nvar app = interopDefault(__webpack_require__(\"JkW7\"));\n\nif (typeof app === 'function') {\n\tvar root = document.body.firstElementChild;\n\n\tvar init = function init() {\n\t\tvar app = interopDefault(__webpack_require__(\"JkW7\"));\n\t\troot = (0, _preact.render)((0, _preact.h)(app), document.body, root);\n\t};\n\n\tif (false) module.hot.accept('preact-cli-entrypoint', init);\n\n\tinit();\n}\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"pwNi\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 76c7519a5fa8b0cdb02b","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/style-loader/lib/addStyles.js","(function (root) {\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {}\n  \n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  function Promise(fn) {\n    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    Promise._immediateFn(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise._immediateFn(function() {\n        if (!self._handled) {\n          Promise._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var prom = new (this.constructor)(noop);\n\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function (arr) {\n    return new Promise(function (resolve, reject) {\n      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');\n      var args = Array.prototype.slice.call(arr);\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  // Use polyfill for setImmediate for performance gains\n  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||\n    function (fn) {\n      setTimeoutFunc(fn, 0);\n    };\n\n  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  /**\n   * Set the immediate function to execute callbacks\n   * @param fn {function} Function to execute\n   * @deprecated\n   */\n  Promise._setImmediateFn = function _setImmediateFn(fn) {\n    Promise._immediateFn = fn;\n  };\n\n  /**\n   * Change the function to execute on unhandled rejection\n   * @param {function} fn Function to execute on unhandled rejection\n   * @deprecated\n   */\n  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n    Promise._unhandledRejectionFn = fn;\n  };\n  \n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  }\n\n})(this);\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/promise-polyfill/promise.js","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/style-loader/lib/urls.js","import preact from 'preact';\n\n/**\r\n * Removes `-` fron a string and capetalize the letter after\r\n * example: data-props-hello-world =>  dataPropsHelloWorld\r\n * Used for props passed from host DOM element\r\n * @param  {String} str string\r\n * @return {String} Capetalized string\r\n */\r\nvar camelcasize = function (str) {\r\n  return str.replace(/-([a-z])/gi, function (all, letter) {\r\n    return letter.toUpperCase();\r\n  });\r\n};\r\n\r\n/**\r\n * [getExecutedScript internal widget to provide the currently executed script]\r\n * @param  {document} document [Browser document object]\r\n * @return {HTMLElement}     [script Element]\r\n */\r\nvar getExecutedScript = function () {\r\n  return (\r\n    document.currentScript ||\r\n    (function () {\r\n      var scripts = document.getElementsByTagName(\"script\");\r\n      return scripts[scripts.length - 1];\r\n    })()\r\n  );\r\n};\r\n\r\n/**\r\n * Get the props from a host element's data attributes\r\n * @param  {Element} tag The host element\r\n * @return {Object}  props object to be passed to the component\r\n */\r\nvar collectPropsFromElement = function (element, defaultProps) {\n  if ( defaultProps === void 0 ) defaultProps = {};\n\r\n  var attrs = element.attributes;\r\n\r\n  var props = Object.assign({}, defaultProps);\r\n\r\n  // collect from element\r\n  Object.keys(attrs).forEach(function (key) {\r\n    if (attrs.hasOwnProperty(key)) {\r\n      var dataAttrName = attrs[key].name;\r\n      if (!dataAttrName || typeof dataAttrName !== \"string\") {\r\n        return false;\r\n      }\r\n      var propName = dataAttrName.split(/(data-props?-)/).pop() || '';\r\n      propName = camelcasize(propName);\r\n      if (dataAttrName !== propName) {\r\n        var propValue = attrs[key].nodeValue;\r\n        props[propName] = propValue;\r\n      }\r\n    }\r\n  });\r\n\r\n  // check for child script text/props\r\n  [].forEach.call(element.getElementsByTagName('script'), function (scrp) {\r\n    var propsObj = {};\r\n    if(scrp.hasAttribute('type')) {\r\n      if (scrp.getAttribute('type') !== 'text/props' ) { return; }\r\n      try {\r\n        propsObj = JSON.parse(scrp.innerHTML);\r\n      } catch(e) {\r\n        throw new Error(e)\r\n      }\r\n      Object.assign(props, propsObj);\r\n    }\r\n  });  \r\n\r\n  return props;\r\n};\r\n\r\nvar getHabitatSelectorFromClient = function (currentScript) {\r\n  var scriptTagAttrs = currentScript.attributes;\r\n  var selector = null;\r\n  // check for another props attached to the tag\r\n  Object.keys(scriptTagAttrs).forEach(function (key) {\r\n    if (scriptTagAttrs.hasOwnProperty(key)) {\r\n      var dataAttrName = scriptTagAttrs[key].name;\r\n      if (dataAttrName === 'data-mount-in') {\r\n        selector = scriptTagAttrs[key].nodeValue;\r\n      }\r\n    }\r\n  });\r\n  return selector\r\n};\r\n\r\n/**\r\n * Return array of 0 or more elements that will host our widget\r\n * @param  {id} attrId the data widget id attribute the host should have\r\n * @param  {document} scope  Docuemnt object or DOM Element as a scope\r\n * @return {Array}        Array of matching habitats\r\n */\r\nvar widgetDOMHostElements = function (\r\n  ref\r\n) {\n  var selector = ref.selector;\n  var inline = ref.inline;\n  var clientSpecified = ref.clientSpecified;\n\r\n  var hostNodes = [];\r\n  var currentScript = getExecutedScript();\r\n\r\n  if (inline === true) {\r\n    var parentNode = currentScript.parentNode;\r\n    hostNodes.push(parentNode);\r\n  }\r\n  if (clientSpecified === true && !selector) {\r\n    // user did not specify where to mount - get it from script tag attributes\r\n    selector = getHabitatSelectorFromClient(currentScript);\r\n  }\r\n  if (selector) {\r\n    [].forEach.call(document.querySelectorAll(selector), function (queriedTag) {\r\n      hostNodes.push(queriedTag);\r\n    });\r\n  }\r\n  return hostNodes;\r\n};\r\n\r\n/**\r\n * preact render function that will be queued if the DOM is not ready\r\n * and executed immeidatly if DOM is ready\r\n */\r\nvar preactRender = function (widget, hostElements, root, cleanRoot, defaultProps) {\r\n  hostElements.forEach(function (elm) {\r\n    var hostNode = elm;\r\n    if (hostNode._habitat) {\r\n      return; \r\n    }\r\n    hostNode._habitat = true;\r\n    var props = collectPropsFromElement(elm, defaultProps) || defaultProps;\r\n    if(cleanRoot) {\r\n      hostNode.innerHTML = \"\";\r\n    }\r\n    return preact.render(preact.h(widget, props), hostNode, root);\r\n  });\r\n};\n\nvar habitat = function (Widget) {\r\n  // Widget represents the Preact component we need to mount\r\n  var widget = Widget;\r\n  // preact root render helper\r\n  var root = null;\r\n\r\n  var render = function (\r\n    ref\r\n  ) {\n    if ( ref === void 0 ) ref = {};\n    var selector = ref.selector; if ( selector === void 0 ) selector = null;\n    var inline = ref.inline; if ( inline === void 0 ) inline = false;\n    var clean = ref.clean; if ( clean === void 0 ) clean = false;\n    var clientSpecified = ref.clientSpecified; if ( clientSpecified === void 0 ) clientSpecified = false;\n    var defaultProps = ref.defaultProps; if ( defaultProps === void 0 ) defaultProps = {};\n\r\n    var elements = widgetDOMHostElements({\r\n      selector: selector,\r\n      inline: inline,\r\n      clientSpecified: clientSpecified\r\n    });\r\n    var loaded = function () {\r\n      if (elements.length > 0) {\r\n        var elements$1 = widgetDOMHostElements({\r\n          selector: selector,\r\n          inline: inline,\r\n          clientSpecified: clientSpecified\r\n        });\r\n\r\n        return preactRender(widget, elements$1, root, clean, defaultProps);\r\n      }\r\n    };\r\n    loaded();\r\n    document.addEventListener(\"DOMContentLoaded\", loaded);\r\n    document.addEventListener(\"load\", loaded);\r\n  };\r\n\r\n  return { render: render };\r\n};\n\nexport default habitat;\n//# sourceMappingURL=preact-habitat.es.js.map\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/preact-habitat/dist/preact-habitat.es.js","import Falcor from 'falcor/dist/falcor.browser';\n\nlet $ref = Falcor.Model.ref;\nlet $atom = Falcor.Model.atom;\nlet pathValue = Falcor.pathValue;\n\nconst api_url = 'http://81.17.61.67';\n\nlet model = new Falcor.Model({\n  source: new Falcor.HttpDataSource(api_url + ':3001/model.json', {\n    crossDomain: true,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  })\n});\n\nconst ApiModel = {\n  getAllAgents: (account_id) => {\n    return model.call('agent.all', [{ account_id: account_id }]);\n  },\n  addResponse: (intent) => {\n    let args = {\n      intent_id: intent.intent_id,\n      agent_id: intent.agent_id,\n      intent_action: intent.intent_action,\n    }\n    return model.call('response.add', [args]);\n  },\n  addAgent: () => {\n    let args = {\n      agent_name: 'NewAgent',\n      account_id: 'abc',\n      flg_active: true,\n    }\n    return model.call('agent.add', [args]);\n  },\n  trainModel: (agent_id) => {\n    let args = {\n      agent_id: agent_id\n    }\n    return model.call('train.do', [args]);\n  },\n  generateIntents: (dsl, agent_id) => {\n    let args = {\n      dsl: dsl,\n      agent_id: agent_id\n    }\n    return model.call('intent.generate', [args]);\n  },\n  resetSession: (id) => {\n    let args = {\n      id: id,\n    }\n    return model.call('session.reset', [args]);\n  },\n  addConnection: (from, to) => {\n    console.log({ from: from, to: to });\n    return model.call('connection.add', [{ from: from, to: to }]);\n  },\n  delInteraction: (id) => {\n    let args = {id: id};\n    return model.call('interaction.remove', [args]);\n  },\n  setResponse: (response_id, data) => {\n    let paths = [\n      pathValue(['response', response_id, 'message'], data.message)\n    ];\n    return model.set(\n      paths[0]\n    );\n  },\n  setAgent: (agent_id, data) => {\n    let paths = [\n      pathValue(['agent', agent_id, 'agent_name'], data.agent_name)\n    ];\n    console.log(paths);\n    return model.set(\n      paths[0]\n    );\n  },\n  doChat: (data) => {\n    return model.call('chat.add', [data]);\n  },\n  getAllResponses: (intent_id) => {\n    return model.call('response.all', [{intent_id: intent_id}]);\n  },\n  getAllIntents: (agent_id) => {\n    return model.call('intent.all', [{ agent_id: agent_id }]);\n  }\n}\n\nexport default ApiModel;\n\n\n\n// WEBPACK FOOTER //\n// ./components/chatbox/model.js","import { h, Component } from \"preact\";\nimport style from \"./style.scss\";\nimport ApiModel from './model';\n\n\nconst ENTER_KEY = 13;\n\nclass UserMessage extends Component {\n  render({chat, props}) {\n    console.log(chat);\n    if (chat.isbot) {\n      return (\n        <div class={ `${style.message} ${style.new}` }>\n          <figure class={ style.avatar }>\n            <img src={ props.avatar } />\n          </figure>\n          { chat.message }\n        </div>\n      );\n    } else {\n      return (\n        <div class={ `${style.message} ${style.message_personal} ${style.new}` }>\n          { chat.message }\n        </div>\n      );\n    }\n  }\n\n}\n\nexport default class App extends Component {\n\n  agent_id=0;\n  state = {\n\t\taccount: 'me',\n\t\tshowChatBox: false,\n\t\tsession: 100,\n\t\tstarted: false,\n\t\tmessage: '',\n    messages: []\n\t};\n\n  onEnter = (e) => {\n    if (e.which===ENTER_KEY) {\n      let message = e.target.value.trim();\n      if (!message.length) {\n        alert('Ingrese un Mensaje!');\n        return\n      }\n      this.setState({\n        message: message\n      });\n      this.sendChat(message);\n      e.target.value = null;\n    }\n  }\n\n  sendChat = (message) => {\n\n    let chat = {\n      from: this.state.account,\n      message: message,\n      image: false,\n      session: this.state.session,\n      agent_id: this.agent_id\n    }\n\n    this.renderChat(chat);\n\n    this.setState({\n      message: '',\n    });\n\n    // ADD BOT RESPONSE\n    var that = this;\n    this.apiDoChat(chat).then( responses => {\n      console.log(responses);\n      responses.map( r => {\n        that.renderChat(r);\n      });\n    });\n\n  }\n\n  apiDoChat = (chat) => {\n    return new Promise( (resolve, reject) => {\n\n      ApiModel.doChat(chat).then( data => {\n        let r = data.json.chat;\n        let id = Object.keys(r)[1];\n        let response = r[id];\n        let responses = [];\n\n        delete response.messages['$__path'];\n        var messages = response.messages;\n\n        Object.keys(messages).map( item => {\n          let message = messages[item];\n          responses.push({\n            from: 'LBot',\n            message: message.text,\n            image: !message.image ?  false : message.image\n          });\n        });\n        resolve(responses);\n        document.getElementById(\"lg_compose_chat\").focus();\n      });\n\n    });\n  }\n\n  handleChange = (e) => {\n    this.setState({\n      message: e.target.value\n    });\n  }\n\n\n  renderChat = (data) => {\n    let messages = this.state.messages;\n    let isbot = data.from == 'LBot' ? true : false;\n    let image = data.image ? data.image : false;\n\n    let chat = {\n      from: data.from,\n      message: data.message,\n      image: image,\n      isbot: isbot\n    };\n\n    messages.push(chat);\n\n    this.setState({\n      messages: messages\n    }, e => {\n      let bodychat = document.getElementById('lg_body_messages');\n      bodychat.scrollTop = bodychat.scrollHeight;\n    });\n  }\n\n\n  render(props) {\n    this.agent_id = props.agent_id;\n    return (\n      <div class={ style.chat }>\n        <div class={ style.chat_title }>\n          <h1>{ props.name }</h1>\n          <h2>{ props.title }</h2>\n          <figure class={ style.avatar }>\n            <img src={ props.avatar } />\n          </figure>\n        </div>\n        <div class={ style.messages }>\n          <div id=\"lg_body_messages\" class={ style.messages_content }>\n            { this.state.messages.map( chat => (\n              <UserMessage chat={ chat } props={ props } />\n            )) }\n          </div>\n        </div>\n        <div class={ style.message_box }>\n          <textarea\n            id=\"lg_compose_chat\"\n            type=\"text\"\n            onKeyUp={this.onEnter}\n            class={ style.message_input }\n            placeholder=\"Escriba su consulta aqu ...\"\n          ></textarea>\n          <button type=\"submit\" class={ style.message_submit }>Enviar</button>\n        </div>\n      </div>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./components/chatbox/index.js","let poly = require(\"preact-cli/lib/lib/webpack/polyfills\");\n\nimport { h } from \"preact\";\nimport habitat from \"preact-habitat\";\n\nimport Widget from \"./components/chatbox\";\n\nlet _habitat = habitat(Widget);\n\n_habitat.render({\n  selector: '[data-widget-host=\"habitat\"]',\n  clean: true\n});\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","!function(){\"use strict\";function e(e,t){var n,o,r,i,l=M;for(i=arguments.length;i-- >2;)T.push(arguments[i]);t&&null!=t.children&&(T.length||T.push(t.children),delete t.children);while(T.length)if((o=T.pop())&&void 0!==o.pop)for(i=o.length;i--;)T.push(o[i]);else\"boolean\"==typeof o&&(o=null),(r=\"function\"!=typeof e)&&(null==o?o=\"\":\"number\"==typeof o?o+=\"\":\"string\"!=typeof o&&(r=!1)),r&&n?l[l.length-1]+=o:l===M?l=[o]:l.push(o),n=r;var a=new S;return a.nodeName=e,a.children=l,a.attributes=null==t?void 0:t,a.key=null==t?void 0:t.key,void 0!==L.vnode&&L.vnode(a),a}function t(e,t){for(var n in t)e[n]=t[n];return e}function n(n,o){return e(n.nodeName,t(t({},n.attributes),o),arguments.length>2?[].slice.call(arguments,2):n.children)}function o(e){!e.__d&&(e.__d=!0)&&1==D.push(e)&&(L.debounceRendering||P)(r)}function r(){var e,t=D;D=[];while(e=t.pop())e.__d&&C(e)}function i(e,t,n){return\"string\"==typeof t||\"number\"==typeof t?void 0!==e.splitText:\"string\"==typeof t.nodeName?!e._componentConstructor&&l(e,t.nodeName):n||e._componentConstructor===t.nodeName}function l(e,t){return e.__n===t||e.nodeName.toLowerCase()===t.toLowerCase()}function a(e){var n=t({},e.attributes);n.children=e.children;var o=e.nodeName.defaultProps;if(void 0!==o)for(var r in o)void 0===n[r]&&(n[r]=o[r]);return n}function p(e,t){var n=t?document.createElementNS(\"http://www.w3.org/2000/svg\",e):document.createElement(e);return n.__n=e,n}function s(e){var t=e.parentNode;t&&t.removeChild(e)}function u(e,t,n,o,r){if(\"className\"===t&&(t=\"class\"),\"key\"===t);else if(\"ref\"===t)n&&n(null),o&&o(e);else if(\"class\"!==t||r)if(\"style\"===t){if(o&&\"string\"!=typeof o&&\"string\"!=typeof n||(e.style.cssText=o||\"\"),o&&\"object\"==typeof o){if(\"string\"!=typeof n)for(var i in n)i in o||(e.style[i]=\"\");for(var i in o)e.style[i]=\"number\"==typeof o[i]&&!1===W.test(i)?o[i]+\"px\":o[i]}}else if(\"dangerouslySetInnerHTML\"===t)o&&(e.innerHTML=o.__html||\"\");else if(\"o\"==t[0]&&\"n\"==t[1]){var l=t!==(t=t.replace(/Capture$/,\"\"));t=t.toLowerCase().substring(2),o?n||e.addEventListener(t,c,l):e.removeEventListener(t,c,l),(e.__l||(e.__l={}))[t]=o}else if(\"list\"!==t&&\"type\"!==t&&!r&&t in e){try{e[t]=null==o?\"\":o}catch(e){}null!=o&&!1!==o||\"spellcheck\"==t||e.removeAttribute(t)}else{var a=r&&t!==(t=t.replace(/^xlink:?/,\"\"));null==o||!1===o?a?e.removeAttributeNS(\"http://www.w3.org/1999/xlink\",t.toLowerCase()):e.removeAttribute(t):\"function\"!=typeof o&&(a?e.setAttributeNS(\"http://www.w3.org/1999/xlink\",t.toLowerCase(),o):e.setAttribute(t,o))}else e.className=o||\"\"}function c(e){return this.__l[e.type](L.event&&L.event(e)||e)}function _(){var e;while(e=E.pop())L.afterMount&&L.afterMount(e),e.componentDidMount&&e.componentDidMount()}function d(e,t,n,o,r,i){V++||(A=null!=r&&void 0!==r.ownerSVGElement,H=null!=e&&!(\"__preactattr_\"in e));var l=f(e,t,n,o,i);return r&&l.parentNode!==r&&r.appendChild(l),--V||(H=!1,i||_()),l}function f(e,t,n,o,r){var i=e,a=A;if(null!=t&&\"boolean\"!=typeof t||(t=\"\"),\"string\"==typeof t||\"number\"==typeof t)return e&&void 0!==e.splitText&&e.parentNode&&(!e._component||r)?e.nodeValue!=t&&(e.nodeValue=t):(i=document.createTextNode(t),e&&(e.parentNode&&e.parentNode.replaceChild(i,e),m(e,!0))),i.__preactattr_=!0,i;var s=t.nodeName;if(\"function\"==typeof s)return x(e,t,n,o);if(A=\"svg\"===s||\"foreignObject\"!==s&&A,s+=\"\",(!e||!l(e,s))&&(i=p(s,A),e)){while(e.firstChild)i.appendChild(e.firstChild);e.parentNode&&e.parentNode.replaceChild(i,e),m(e,!0)}var u=i.firstChild,c=i.__preactattr_,_=t.children;if(null==c){c=i.__preactattr_={};for(var d=i.attributes,f=d.length;f--;)c[d[f].name]=d[f].value}return!H&&_&&1===_.length&&\"string\"==typeof _[0]&&null!=u&&void 0!==u.splitText&&null==u.nextSibling?u.nodeValue!=_[0]&&(u.nodeValue=_[0]):(_&&_.length||null!=u)&&h(i,_,n,o,H||null!=c.dangerouslySetInnerHTML),b(i,t.attributes,c),A=a,i}function h(e,t,n,o,r){var l,a,p,u,c,_=e.childNodes,d=[],h={},v=0,b=0,y=_.length,g=0,w=t?t.length:0;if(0!==y)for(var C=0;C<y;C++){var x=_[C],N=x.__preactattr_,k=w&&N?x._component?x._component.__k:N.key:null;null!=k?(v++,h[k]=x):(N||(void 0!==x.splitText?!r||x.nodeValue.trim():r))&&(d[g++]=x)}if(0!==w)for(var C=0;C<w;C++){u=t[C],c=null;var k=u.key;if(null!=k)v&&void 0!==h[k]&&(c=h[k],h[k]=void 0,v--);else if(b<g)for(l=b;l<g;l++)if(void 0!==d[l]&&i(a=d[l],u,r)){c=a,d[l]=void 0,l===g-1&&g--,l===b&&b++;break}c=f(c,u,n,o),p=_[C],c&&c!==e&&c!==p&&(null==p?e.appendChild(c):c===p.nextSibling?s(p):e.insertBefore(c,p))}if(v)for(var C in h)void 0!==h[C]&&m(h[C],!1);while(b<=g)void 0!==(c=d[g--])&&m(c,!1)}function m(e,t){var n=e._component;n?N(n):(null!=e.__preactattr_&&e.__preactattr_.ref&&e.__preactattr_.ref(null),!1!==t&&null!=e.__preactattr_||s(e),v(e))}function v(e){e=e.lastChild;while(e){var t=e.previousSibling;m(e,!0),e=t}}function b(e,t,n){var o;for(o in n)t&&null!=t[o]||null==n[o]||u(e,o,n[o],n[o]=void 0,A);for(o in t)\"children\"===o||\"innerHTML\"===o||o in n&&t[o]===(\"value\"===o||\"checked\"===o?e[o]:n[o])||u(e,o,n[o],n[o]=t[o],A)}function y(e,t,n){var o,r=B.length;e.prototype&&e.prototype.render?(o=new e(t,n),k.call(o,t,n)):(o=new k(t,n),o.constructor=e,o.render=g);while(r--)if(B[r].constructor===e)return o.__b=B[r].__b,B.splice(r,1),o;return o}function g(e,t,n){return this.constructor(e,n)}function w(e,t,n,r,i){e.__x||(e.__x=!0,e.__r=t.ref,e.__k=t.key,delete t.ref,delete t.key,void 0===e.constructor.getDerivedStateFromProps&&(!e.base||i?e.componentWillMount&&e.componentWillMount():e.componentWillReceiveProps&&e.componentWillReceiveProps(t,r)),r&&r!==e.context&&(e.__c||(e.__c=e.context),e.context=r),e.__p||(e.__p=e.props),e.props=t,e.__x=!1,0!==n&&(1!==n&&!1===L.syncComponentUpdates&&e.base?o(e):C(e,1,i)),e.__r&&e.__r(e))}function C(e,n,o,r){if(!e.__x){var i,l,p,s=e.props,u=e.state,c=e.context,f=e.__p||s,h=e.__s||u,v=e.__c||c,b=e.base,g=e.__b,x=b||g,k=e._component,U=!1,S=v;if(e.constructor.getDerivedStateFromProps&&(u=t(t({},u),e.constructor.getDerivedStateFromProps(s,u)),e.state=u),b&&(e.props=f,e.state=h,e.context=v,2!==n&&e.shouldComponentUpdate&&!1===e.shouldComponentUpdate(s,u,c)?U=!0:e.componentWillUpdate&&e.componentWillUpdate(s,u,c),e.props=s,e.state=u,e.context=c),e.__p=e.__s=e.__c=e.__b=null,e.__d=!1,!U){i=e.render(s,u,c),e.getChildContext&&(c=t(t({},c),e.getChildContext())),b&&e.getSnapshotBeforeUpdate&&(S=e.getSnapshotBeforeUpdate(f,h));var T,M,P=i&&i.nodeName;if(\"function\"==typeof P){var W=a(i);l=k,l&&l.constructor===P&&W.key==l.__k?w(l,W,1,c,!1):(T=l,e._component=l=y(P,W,c),l.__b=l.__b||g,l.__u=e,w(l,W,0,c,!1),C(l,1,o,!0)),M=l.base}else p=x,T=k,T&&(p=e._component=null),(x||1===n)&&(p&&(p._component=null),M=d(p,i,c,o||!b,x&&x.parentNode,!0));if(x&&M!==x&&l!==k){var D=x.parentNode;D&&M!==D&&(D.replaceChild(M,x),T||(x._component=null,m(x,!1)))}if(T&&N(T),e.base=M,M&&!r){var A=e,H=e;while(H=H.__u)(A=H).base=M;M._component=A,M._componentConstructor=A.constructor}}!b||o?E.unshift(e):U||(e.componentDidUpdate&&e.componentDidUpdate(f,h,S),L.afterUpdate&&L.afterUpdate(e));while(e.__h.length)e.__h.pop().call(e);V||r||_()}}function x(e,t,n,o){var r=e&&e._component,i=r,l=e,p=r&&e._componentConstructor===t.nodeName,s=p,u=a(t);while(r&&!s&&(r=r.__u))s=r.constructor===t.nodeName;return r&&s&&(!o||r._component)?(w(r,u,3,n,o),e=r.base):(i&&!p&&(N(i),e=l=null),r=y(t.nodeName,u,n),e&&!r.__b&&(r.__b=e,l=null),w(r,u,1,n,o),e=r.base,l&&e!==l&&(l._component=null,m(l,!1))),e}function N(e){L.beforeUnmount&&L.beforeUnmount(e);var t=e.base;e.__x=!0,e.componentWillUnmount&&e.componentWillUnmount(),e.base=null;var n=e._component;n?N(n):t&&(t.__preactattr_&&t.__preactattr_.ref&&t.__preactattr_.ref(null),e.__b=t,s(t),B.push(e),v(t)),e.__r&&e.__r(null)}function k(e,t){this.__d=!0,this.context=t,this.props=e,this.state=this.state||{},this.__h=[]}function U(e,t,n){return d(n,e,{},!1,t,!1)}var S=function(){},L={},T=[],M=[],P=\"function\"==typeof Promise?Promise.resolve().then.bind(Promise.resolve()):setTimeout,W=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,D=[],E=[],V=0,A=!1,H=!1,B=[];t(k.prototype,{setState:function(e,n){this.__s||(this.__s=this.state),this.state=t(t({},this.state),\"function\"==typeof e?e(this.state,this.props):e),n&&this.__h.push(n),o(this)},forceUpdate:function(e){e&&this.__h.push(e),C(this,2)},render:function(){}});var F={h:e,createElement:e,cloneElement:n,Component:k,render:U,rerender:r,options:L};\"undefined\"!=typeof module?module.exports=F:self.preact=F}();\n//# sourceMappingURL=preact.min.js.map\n\n\n// WEBPACK FOOTER //\n// ../node_modules/preact/dist/preact.min.js","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \"body,html{font:14px/1.21 Helvetica Neue,arial,sans-serif;font-weight:400}*,:after,:before{-webkit-box-sizing:border-box;box-sizing:border-box}body,html{height:100%}body{background:linear-gradient(135deg,#044f48,#2a7561);background-size:cover;font-family:Open Sans,sans-serif;font-size:12px;line-height:1.3;overflow:hidden}.bg__Lbpa2{width:100%;height:100%;top:0;left:0;z-index:1;background:url(\\\"https://images.unsplash.com/photo-1451186859696-371d9477be93?crop=entropy&fit=crop&fm=jpg&h=975&ixjsv=2.1.0&ixlib=rb-0.3.5&q=80&w=1925\\\") no-repeat 0 0;-webkit-filter:blur(80px);filter:blur(80px);-webkit-transform:scale(1.2);-ms-transform:scale(1.2);transform:scale(1.2)}.chat__2jjNN{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);width:300px;height:80vh;max-height:500px;z-index:2;overflow:hidden;-webkit-box-shadow:0 5px 30px rgba(0,0,0,.2);box-shadow:0 5px 30px rgba(0,0,0,.2);background:rgba(0,0,0,.5);border-radius:20px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.chat_title__2Two8{-webkit-box-flex:0;-ms-flex:0 1 45px;flex:0 1 45px;position:relative;z-index:2;background:rgba(0,0,0,.2);color:#fff;text-transform:uppercase;text-align:left;padding:10px 10px 10px 50px}.chat_title__2Two8 h1,.chat_title__2Two8 h2{font-weight:400;font-size:10px;margin:0;padding:0}.chat_title__2Two8 h2{color:hsla(0,0%,100%,.5);font-size:8px;letter-spacing:1px}.chat_title__2Two8 .avatar__1kVZr{position:absolute;z-index:1;top:8px;left:9px;border-radius:30px;width:30px;height:30px;overflow:hidden;margin:0;padding:0;border:2px solid hsla(0,0%,100%,.24)}.chat_title__2Two8 .avatar__1kVZr img{width:100%;height:auto}.messages__1Smla{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;color:hsla(0,0%,100%,.5);overflow:hidden;position:relative;width:100%}.messages__1Smla .messages_content__3WVlQ{position:absolute;top:0;left:0;padding:1em;height:101%;width:100%;overflow-x:hidden;overflow-y:auto}.messages__1Smla .messages_content__3WVlQ::-webkit-scrollbar-thumb{background-color:#08221d;background-image:none}.messages__1Smla .messages_content__3WVlQ::-webkit-scrollbar{width:5px;height:1px;z-index:10;-webkit-transition:all .5s;transition:all .5s}.messages__1Smla .messages_content__3WVlQ::-webkit-scrollbar-track{background:transparent}.messages__1Smla .message__2LwDs{clear:both;float:left;padding:6px 10px 7px;border-radius:10px 10px 10px 0;background:rgba(0,0,0,.3);margin:8px 0;font-size:11px;line-height:1.4;margin-left:35px;position:relative;text-shadow:0 1px 1px rgba(0,0,0,.2)}.messages__1Smla .message__2LwDs .timestamp__1qXhv{position:absolute;bottom:-15px;font-size:9px;color:hsla(0,0%,100%,.3)}.messages__1Smla .message__2LwDs:before{content:\\\"\\\";position:absolute;bottom:-6px;border-top:6px solid rgba(0,0,0,.3);left:0;border-right:7px solid transparent}.messages__1Smla .message__2LwDs .avatar__1kVZr{position:absolute;z-index:1;bottom:-15px;left:-35px;border-radius:30px;width:30px;height:30px;overflow:hidden;margin:0;padding:0;border:2px solid hsla(0,0%,100%,.24)}.messages__1Smla .message__2LwDs .avatar__1kVZr img{width:100%;height:auto}.messages__1Smla .message__2LwDs.message_personal__1oyIu{float:right;color:#fff;text-align:right;background:linear-gradient(120deg,#248a52,#257287);border-radius:10px 10px 0 10px}.messages__1Smla .message__2LwDs.message_personal__1oyIu:before{left:auto;right:0;border-right:none;border-left:5px solid transparent;border-top:4px solid #257287;bottom:-4px}.messages__1Smla .message__2LwDs:last-child{margin-bottom:30px}.messages__1Smla .message__2LwDs.new__3ShF9{-webkit-transform:scale(0);-ms-transform:scale(0);transform:scale(0);-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0;-webkit-animation:bounce__JRajZ .5s linear both;animation:bounce__JRajZ .5s linear both}.messages__1Smla .message__2LwDs.loading__YMEmP:before{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);content:\\\"\\\";display:block;width:3px;height:3px;border-radius:50%;background:hsla(0,0%,100%,.5);z-index:2;margin-top:4px;-webkit-animation:ball__1AQxl .45s cubic-bezier(0,0,.15,1) alternate infinite;animation:ball__1AQxl .45s cubic-bezier(0,0,.15,1) alternate infinite;border:none;-webkit-animation-delay:.15s;animation-delay:.15s}.messages__1Smla .message__2LwDs.loading__YMEmP span{display:block;font-size:0;width:20px;height:10px;position:relative}.messages__1Smla .message__2LwDs.loading__YMEmP span:before{margin-left:-7px}.messages__1Smla .message__2LwDs.loading__YMEmP span:after,.messages__1Smla .message__2LwDs.loading__YMEmP span:before{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);content:\\\"\\\";display:block;width:3px;height:3px;border-radius:50%;background:hsla(0,0%,100%,.5);z-index:2;margin-top:4px;-webkit-animation:ball__1AQxl .45s cubic-bezier(0,0,.15,1) alternate infinite;animation:ball__1AQxl .45s cubic-bezier(0,0,.15,1) alternate infinite}.messages__1Smla .message__2LwDs.loading__YMEmP span:after{margin-left:7px;-webkit-animation-delay:.3s;animation-delay:.3s}.message_box__u0ndM{-webkit-box-flex:0;-ms-flex:0 1 40px;flex:0 1 40px;width:100%;background:rgba(0,0,0,.3);padding:10px;position:relative}.message_box__u0ndM .message_input__2Jrco{background:none;border:none;outline:none!important;resize:none;color:hsla(0,0%,100%,.7);font-size:11px;height:40px;margin:0;padding-right:20px;width:265px}.message_box__u0ndM textarea:focus:-webkit-placeholder{color:transparent}.message_box__u0ndM .message_submit__1ZiW2{position:absolute;z-index:1;top:9px;right:10px;color:#fff;border:none;background:#248a52;font-size:10px;text-transform:uppercase;line-height:1;padding:6px 10px;border-radius:10px;outline:none!important;-webkit-transition:background .2s ease;transition:background .2s ease}.message_box__u0ndM .message_submit__1ZiW2:hover{background:#1d7745}.mCSB_scrollTools__35sBe{margin:1px -3px 1px 0;opacity:0}.mCSB_inside__2EgcE>.mCSB_container__tzOAO{margin-right:0;padding:0 10px}.mCSB_scrollTools__35sBe .mCSB_dragger__3za9I .mCSB_dragger_bar__4GZu9{background-color:rgba(0,0,0,.5)!important}@-webkit-keyframes bounce__JRajZ{0%{-webkit-transform:matrix(0,0,0,0,0,0);transform:matrix(0,0,0,0,0,0)}4.7%{-webkit-transform:matrix(.45,0,0,.45,0,0);transform:matrix(.45,0,0,.45,0,0)}9.41%{-webkit-transform:matrix(.883,0,0,.883,0,0);transform:matrix(.883,0,0,.883,0,0)}14.11%{-webkit-transform:matrix(1.141,0,0,1.141,0,0);transform:matrix(1.141,0,0,1.141,0,0)}18.72%{-webkit-transform:matrix(1.212,0,0,1.212,0,0);transform:matrix(1.212,0,0,1.212,0,0)}24.32%{-webkit-transform:matrix(1.151,0,0,1.151,0,0);transform:matrix(1.151,0,0,1.151,0,0)}29.93%{-webkit-transform:matrix(1.048,0,0,1.048,0,0);transform:matrix(1.048,0,0,1.048,0,0)}35.54%{-webkit-transform:matrix(.979,0,0,.979,0,0);transform:matrix(.979,0,0,.979,0,0)}41.04%{-webkit-transform:matrix(.961,0,0,.961,0,0);transform:matrix(.961,0,0,.961,0,0)}52.15%{-webkit-transform:matrix(.991,0,0,.991,0,0);transform:matrix(.991,0,0,.991,0,0)}63.26%{-webkit-transform:matrix(1.007,0,0,1.007,0,0);transform:matrix(1.007,0,0,1.007,0,0)}85.49%{-webkit-transform:matrix(.999,0,0,.999,0,0);transform:matrix(.999,0,0,.999,0,0)}to{-webkit-transform:matrix(1,0,0,1,0,0);transform:matrix(1,0,0,1,0,0)}}@keyframes bounce__JRajZ{0%{-webkit-transform:matrix(0,0,0,0,0,0);transform:matrix(0,0,0,0,0,0)}4.7%{-webkit-transform:matrix(.45,0,0,.45,0,0);transform:matrix(.45,0,0,.45,0,0)}9.41%{-webkit-transform:matrix(.883,0,0,.883,0,0);transform:matrix(.883,0,0,.883,0,0)}14.11%{-webkit-transform:matrix(1.141,0,0,1.141,0,0);transform:matrix(1.141,0,0,1.141,0,0)}18.72%{-webkit-transform:matrix(1.212,0,0,1.212,0,0);transform:matrix(1.212,0,0,1.212,0,0)}24.32%{-webkit-transform:matrix(1.151,0,0,1.151,0,0);transform:matrix(1.151,0,0,1.151,0,0)}29.93%{-webkit-transform:matrix(1.048,0,0,1.048,0,0);transform:matrix(1.048,0,0,1.048,0,0)}35.54%{-webkit-transform:matrix(.979,0,0,.979,0,0);transform:matrix(.979,0,0,.979,0,0)}41.04%{-webkit-transform:matrix(.961,0,0,.961,0,0);transform:matrix(.961,0,0,.961,0,0)}52.15%{-webkit-transform:matrix(.991,0,0,.991,0,0);transform:matrix(.991,0,0,.991,0,0)}63.26%{-webkit-transform:matrix(1.007,0,0,1.007,0,0);transform:matrix(1.007,0,0,1.007,0,0)}85.49%{-webkit-transform:matrix(.999,0,0,.999,0,0);transform:matrix(.999,0,0,.999,0,0)}to{-webkit-transform:matrix(1,0,0,1,0,0);transform:matrix(1,0,0,1,0,0)}}@-webkit-keyframes ball__1AQxl{0%{-webkit-transform:translateY(0) scaleY(.8);transform:translateY(0) scaleY(.8)}to{-webkit-transform:translateY(-10px);transform:translateY(-10px)}}@keyframes ball__1AQxl{0%{-webkit-transform:translateY(0) scaleY(.8);transform:translateY(0) scaleY(.8)}to{-webkit-transform:translateY(-10px);transform:translateY(-10px)}}\", \"\", {\"version\":3,\"sources\":[\"/app/src/components/chatbox/style.scss\"],\"names\":[],\"mappings\":\"AAAA,UACC,+CACA,eAAgB,CAChB,iBAgCC,8BAAA,qBAAsB,CACvB,UAIC,WAAY,CACb,KAGC,mDACA,sBACA,iCACA,eACA,gBACA,eAAgB,CACjB,WAGC,WACA,YACA,MACA,OACA,UACA,uKACA,0BAAA,kBACA,6BAAA,yBAAA,oBAAqB,CACtB,aApDC,kBACA,QACA,SACA,uCAAA,mCAAA,+BAyDA,YACA,YACA,iBACA,UACA,gBACA,6CAAA,qCACA,0BACA,mBACA,oBAAA,oBAAA,aACA,yBAAA,sBAAA,8BACA,4BAAA,6BAAA,0BAAA,qBAAsB,CACvB,mBAOC,mBAAA,kBAAA,cACA,kBACA,UACA,0BACA,WACA,yBACA,gBACA,2BAA4B,CAR9B,4CAWI,gBACA,eACA,SACA,SAAU,CAdd,sBAkBI,yBACA,cACA,kBAAmB,CApBvB,kCAwBI,kBACA,UACA,QACA,SACA,mBACA,WACA,YACA,gBACA,SACA,UACA,oCAA2C,CAlC/C,sCAqCM,WACA,WAAY,CACb,iBASH,mBAAA,kBAAA,cACA,yBACA,gBACA,kBACA,UAAW,CALb,0CAQI,kBACA,MACA,OACF,YACE,YACA,WACF,kBACE,eAAgB,CAfpB,mEAiBK,yBACA,qBAAsB,CAlB3B,6DAqBM,UACA,WACA,WACA,2BAAA,kBAAmB,CAxBzB,mEA2BM,sBAAuB,CA3B7B,iCAiCI,WACA,WACA,qBACA,+BACA,0BACA,aACA,eACA,gBACA,iBACA,kBACA,oCAAwC,CA3C5C,mDA8CM,kBACA,aACA,cACA,wBAA8B,CAjDpC,wCAqDM,WACA,kBACA,YACA,oCACA,OACA,kCAAmC,CA1DzC,gDA8DM,kBACA,UACA,aACA,WACA,mBACA,WACA,YACA,gBACA,SACA,UACA,oCAA2C,CAxEjD,oDA2EQ,WACA,WAAY,CA5EpB,yDAiFM,YACA,WACA,iBACA,mDACA,8BAA+B,CArFrC,gEAwFQ,UACA,QACA,kBACA,kCACA,6BACA,WAAY,CA7FpB,4CAkGM,kBAAmB,CAlGzB,4CAsGM,2BAAA,uBAAA,mBACA,6BAAA,yBAAA,qBACA,gDAAA,uCAAmC,CAxGzC,uDA5HE,kBACA,QACA,SACA,uCAAA,mCAAA,+BAKA,WACA,cACA,UACA,WACA,kBACA,8BACA,UACA,eACA,8EAAA,sEA2NM,YACA,6BAAA,oBAAqB,CAhH7B,qDAoHQ,cACA,YACA,WACA,YACA,iBAAkB,CAxH1B,4DA4HU,gBAAiB,CA5H3B,uHA5HE,kBACA,QACA,SACA,uCAAA,mCAAA,+BAKA,WACA,cACA,UACA,WACA,kBACA,8BACA,UACA,eACA,8EAAA,qEAwOQ,CAOD,AAnIT,2DAiIU,gBACA,4BAAA,mBAAoB,CACrB,oBAYP,mBAAA,kBAAA,cACA,WACA,0BACA,aACA,iBAAkB,CALpB,0CAQI,gBACA,YACA,uBACA,YACA,yBACA,eACA,YACA,SACA,mBACA,WAAY,CAjBhB,uDAqBM,iBAAkB,CArBxB,2CAyBI,kBACA,UACA,QACA,WACA,WACA,YACA,mBACA,eACA,yBACA,cACA,iBACA,mBACA,uBACA,uCAAA,8BAA+B,CAtCnC,iDAyCM,kBAAmB,CACpB,yBASH,sBACA,SAAU,CACX,2CAGC,eACA,cAAe,CAChB,uEAGC,yCAA8C,CAC/C,iCAOC,GAAK,sCAAA,6BAAmE,CACxE,KAAO,0CAAA,iCAAyE,CAChF,MAAQ,4CAAA,mCAA2E,CACnF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,GAAO,sCAAA,6BAAmE,CAAA,CAnB3E,yBAOC,GAAK,sCAAA,6BAAmE,CACxE,KAAO,0CAAA,iCAAyE,CAChF,MAAQ,4CAAA,mCAA2E,CACnF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,OAAS,8CAAA,qCAA2E,CACpF,OAAS,4CAAA,mCAA2E,CACpF,GAAO,sCAAA,6BAAmE,CAAA,CAI5E,+BACE,GACE,2CAAA,kCAAmC,CAErC,GACE,oCAAA,2BAA4B,CAAA,CALhC,uBACE,GACE,2CAAA,kCAAmC,CAErC,GACE,oCAAA,2BAA4B,CAAA,CAAA\",\"file\":\"style.scss\",\"sourcesContent\":[\"html, body {\\n\\tfont: 14px/1.21 'Helvetica Neue', arial, sans-serif;\\n\\tfont-weight: 400;\\n}\\n\\n/*--------------------\\nMixins\\n--------------------*/\\n@mixin center {\\n  position: absolute;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n}\\n\\n@mixin ball {\\n  @include center;\\n  content: '';\\n  display: block;\\n  width: 3px;\\n  height: 3px;\\n  border-radius: 50%;\\n  background: rgba(255, 255, 255, .5);\\n  z-index: 2;\\n  margin-top: 4px;\\n  animation: ball .45s cubic-bezier(0, 0, 0.15, 1) alternate infinite;\\n}\\n\\n\\n/*--------------------\\nBody\\n--------------------*/\\n*,\\n*::before,\\n*::after {\\n  box-sizing: border-box;\\n}\\n\\nhtml,\\nbody {\\n  height: 100%;\\n}\\n\\nbody {\\n  background: linear-gradient(135deg, #044f48, #2a7561);\\n  background-size: cover;\\n  font-family: 'Open Sans', sans-serif;\\n  font-size: 12px;\\n  line-height: 1.3;\\n  overflow: hidden;\\n}\\n\\n.bg {\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  z-index: 1;\\n  background: url('https://images.unsplash.com/photo-1451186859696-371d9477be93?crop=entropy&fit=crop&fm=jpg&h=975&ixjsv=2.1.0&ixlib=rb-0.3.5&q=80&w=1925') no-repeat 0 0;\\n  filter: blur(80px);\\n  transform: scale(1.2);\\n}\\n\\n\\n/*--------------------\\nChat\\n--------------------*/\\n.chat {\\n  @include center;\\n  width: 300px;\\n  height: 80vh;\\n  max-height: 500px;\\n  z-index: 2;\\n  overflow: hidden;\\n  box-shadow: 0 5px 30px rgba(0, 0, 0, .2);\\n  background: rgba(0, 0, 0, .5);\\n  border-radius: 20px;\\n  display: flex;\\n  justify-content: space-between;\\n  flex-direction: column;\\n}\\n\\n\\n/*--------------------\\nChat Title\\n--------------------*/\\n.chat_title {\\n  flex: 0 1 45px;\\n  position: relative;\\n  z-index: 2;\\n  background: rgba(0, 0, 0, 0.2);\\n  color: #fff;\\n  text-transform: uppercase;\\n  text-align: left;\\n  padding: 10px 10px 10px 50px;\\n\\n  h1, h2 {\\n    font-weight: normal;\\n    font-size: 10px;\\n    margin: 0;\\n    padding: 0;\\n  }\\n\\n  h2 {\\n    color: rgba(255, 255, 255, .5);\\n    font-size: 8px;\\n    letter-spacing: 1px;\\n  }\\n\\n  .avatar {\\n    position: absolute;\\n    z-index: 1;\\n    top: 8px;\\n    left: 9px;\\n    border-radius: 30px;\\n    width: 30px;\\n    height: 30px;\\n    overflow: hidden;\\n    margin: 0;\\n    padding: 0;\\n    border: 2px solid rgba(255, 255, 255, 0.24);\\n\\n    img {\\n      width: 100%;\\n      height: auto;\\n    }\\n  }\\n}\\n\\n\\n/*--------------------\\nMessages\\n--------------------*/\\n.messages {\\n  flex: 1 1 auto;\\n  color: rgba(255, 255, 255, .5);\\n  overflow: hidden;\\n  position: relative;\\n  width: 100%;\\n\\n  & .messages_content {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n\\t\\tpadding: 1em;\\n    height: 101%;\\n    width: 100%;\\n\\t\\toverflow-x: hidden;\\n    overflow-y: auto;\\n\\t\\t&::-webkit-scrollbar-thumb {\\n    \\tbackground-color: #08221D;\\n    \\tbackground-image: none;\\n\\t\\t}\\n    &::-webkit-scrollbar{\\n      width: 5px;\\n      height: 1px;\\n      z-index: 10;\\n      transition: all .5s;\\n\\t\\t}\\n    &::-webkit-scrollbar-track {\\n      background: transparent;\\n\\t\\t}\\n  }\\n\\n\\n  .message {\\n    clear: both;\\n    float: left;\\n    padding: 6px 10px 7px;\\n    border-radius: 10px 10px 10px 0;\\n    background: rgba(0, 0, 0, .3);\\n    margin: 8px 0;\\n    font-size: 11px;\\n    line-height: 1.4;\\n    margin-left: 35px;\\n    position: relative;\\n    text-shadow: 0 1px 1px rgba(0, 0, 0, .2);\\n\\n    .timestamp {\\n      position: absolute;\\n      bottom: -15px;\\n      font-size: 9px;\\n      color: rgba(255, 255, 255, .3);\\n    }\\n\\n    &::before {\\n      content: '';\\n      position: absolute;\\n      bottom: -6px;\\n      border-top: 6px solid rgba(0, 0, 0, .3);\\n      left: 0;\\n      border-right: 7px solid transparent;\\n    }\\n\\n    .avatar {\\n      position: absolute;\\n      z-index: 1;\\n      bottom: -15px;\\n      left: -35px;\\n      border-radius: 30px;\\n      width: 30px;\\n      height: 30px;\\n      overflow: hidden;\\n      margin: 0;\\n      padding: 0;\\n      border: 2px solid rgba(255, 255, 255, 0.24);\\n\\n      img {\\n        width: 100%;\\n        height: auto;\\n      }\\n    }\\n\\n    &.message_personal {\\n      float: right;\\n      color: #fff;\\n      text-align: right;\\n      background: linear-gradient(120deg, #248A52, #257287);\\n      border-radius: 10px 10px 0 10px;\\n\\n      &::before {\\n        left: auto;\\n        right: 0;\\n        border-right: none;\\n        border-left: 5px solid transparent;\\n        border-top: 4px solid #257287;\\n        bottom: -4px;\\n      }\\n    }\\n\\n    &:last-child {\\n      margin-bottom: 30px;\\n    }\\n\\n    &.new {\\n      transform: scale(0);\\n      transform-origin: 0 0;\\n      animation: bounce 500ms linear both;\\n    }\\n\\n    &.loading {\\n\\n      &::before {\\n        @include ball;\\n        border: none;\\n        animation-delay: .15s;\\n      }\\n\\n      & span {\\n        display: block;\\n        font-size: 0;\\n        width: 20px;\\n        height: 10px;\\n        position: relative;\\n\\n        &::before {\\n          @include ball;\\n          margin-left: -7px;\\n        }\\n\\n        &::after {\\n          @include ball;\\n          margin-left: 7px;\\n          animation-delay: .3s;\\n        }\\n      }\\n    }\\n\\n  }\\n}\\n\\n\\n/*--------------------\\nMessage Box\\n--------------------*/\\n.message_box {\\n  flex: 0 1 40px;\\n  width: 100%;\\n  background: rgba(0, 0, 0, 0.3);\\n  padding: 10px;\\n  position: relative;\\n\\n  & .message_input {\\n    background: none;\\n    border: none;\\n    outline: none!important;\\n    resize: none;\\n    color: rgba(255, 255, 255, .7);\\n    font-size: 11px;\\n    height: 40px;\\n    margin: 0;\\n    padding-right: 20px;\\n    width: 265px;\\n  }\\n\\n  textarea:focus:-webkit-placeholder{\\n      color: transparent;\\n  }\\n\\n  & .message_submit {\\n    position: absolute;\\n    z-index: 1;\\n    top: 9px;\\n    right: 10px;\\n    color: #fff;\\n    border: none;\\n    background: #248A52;\\n    font-size: 10px;\\n    text-transform: uppercase;\\n    line-height: 1;\\n    padding: 6px 10px;\\n    border-radius: 10px;\\n    outline: none!important;\\n    transition: background .2s ease;\\n\\n    &:hover {\\n      background: #1D7745;\\n    }\\n  }\\n}\\n\\n\\n/*--------------------\\nCustom Srollbar\\n--------------------*/\\n.mCSB_scrollTools {\\n  margin: 1px -3px 1px 0;\\n  opacity: 0;\\n}\\n\\n.mCSB_inside > .mCSB_container {\\n  margin-right: 0px;\\n  padding: 0 10px;\\n}\\n\\n.mCSB_scrollTools .mCSB_dragger .mCSB_dragger_bar {\\n  background-color: rgba(0, 0, 0, 0.5)!important;\\n}\\n\\n\\n/*--------------------\\nBounce\\n--------------------*/\\n@keyframes bounce {\\n  0% { transform: matrix3d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  4.7% { transform: matrix3d(0.45, 0, 0, 0, 0, 0.45, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  9.41% { transform: matrix3d(0.883, 0, 0, 0, 0, 0.883, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  14.11% { transform: matrix3d(1.141, 0, 0, 0, 0, 1.141, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  18.72% { transform: matrix3d(1.212, 0, 0, 0, 0, 1.212, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  24.32% { transform: matrix3d(1.151, 0, 0, 0, 0, 1.151, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  29.93% { transform: matrix3d(1.048, 0, 0, 0, 0, 1.048, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  35.54% { transform: matrix3d(0.979, 0, 0, 0, 0, 0.979, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  41.04% { transform: matrix3d(0.961, 0, 0, 0, 0, 0.961, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  52.15% { transform: matrix3d(0.991, 0, 0, 0, 0, 0.991, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  63.26% { transform: matrix3d(1.007, 0, 0, 0, 0, 1.007, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  85.49% { transform: matrix3d(0.999, 0, 0, 0, 0, 0.999, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n  100% { transform: matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); }\\n}\\n\\n\\n@keyframes ball {\\n  from {\\n    transform: translateY(0) scaleY(.8);\\n  }\\n  to {\\n    transform: translateY(-10px);\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\nexports.locals = {\n\t\"bg\": \"bg__Lbpa2\",\n\t\"chat\": \"chat__2jjNN\",\n\t\"chat_title\": \"chat_title__2Two8\",\n\t\"avatar\": \"avatar__1kVZr\",\n\t\"messages\": \"messages__1Smla\",\n\t\"messages_content\": \"messages_content__3WVlQ\",\n\t\"message\": \"message__2LwDs\",\n\t\"timestamp\": \"timestamp__1qXhv\",\n\t\"message_personal\": \"message_personal__1oyIu\",\n\t\"new\": \"new__3ShF9\",\n\t\"bounce\": \"bounce__JRajZ\",\n\t\"loading\": \"loading__YMEmP\",\n\t\"ball\": \"ball__1AQxl\",\n\t\"message_box\": \"message_box__u0ndM\",\n\t\"message_input\": \"message_input__2Jrco\",\n\t\"message_submit\": \"message_submit__1ZiW2\",\n\t\"mCSB_scrollTools\": \"mCSB_scrollTools__35sBe\",\n\t\"mCSB_inside\": \"mCSB_inside__2EgcE\",\n\t\"mCSB_container\": \"mCSB_container__tzOAO\",\n\t\"mCSB_dragger\": \"mCSB_dragger__3za9I\",\n\t\"mCSB_dragger_bar\": \"mCSB_dragger_bar__4GZu9\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/css-loader??ref--4-2!../node_modules/postcss-loader/lib??postcss!../node_modules/preact-cli/lib/lib/webpack/proxy-loader.js??ref--2-0!./components/chatbox/style.scss\n// module id = LFiD\n// module chunks = 0","var index = typeof fetch=='function' ? fetch.bind() : function(url, options) {\n\toptions = options || {};\n\treturn new Promise( function (resolve, reject) {\n\t\tvar request = new XMLHttpRequest();\n\n\t\trequest.open(options.method || 'get', url, true);\n\n\t\tfor (var i in options.headers) {\n\t\t\trequest.setRequestHeader(i, options.headers[i]);\n\t\t}\n\n\t\trequest.withCredentials = options.credentials=='include';\n\n\t\trequest.onload = function () {\n\t\t\tresolve(response());\n\t\t};\n\n\t\trequest.onerror = reject;\n\n\t\trequest.send(options.body);\n\n\t\tfunction response() {\n\t\t\tvar keys = [],\n\t\t\t\tall = [],\n\t\t\t\theaders = {},\n\t\t\t\theader;\n\n\t\t\trequest.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, function (m, key, value) {\n\t\t\t\tkeys.push(key = key.toLowerCase());\n\t\t\t\tall.push([key, value]);\n\t\t\t\theader = headers[key];\n\t\t\t\theaders[key] = header ? (header + \",\" + value) : value;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tok: (request.status/100|0) == 2,\t\t// 200-299\n\t\t\t\tstatus: request.status,\n\t\t\t\tstatusText: request.statusText,\n\t\t\t\turl: request.responseURL,\n\t\t\t\tclone: response,\n\t\t\t\ttext: function () { return Promise.resolve(request.responseText); },\n\t\t\t\tjson: function () { return Promise.resolve(request.responseText).then(JSON.parse); },\n\t\t\t\tblob: function () { return Promise.resolve(new Blob([request.response])); },\n\t\t\t\theaders: {\n\t\t\t\t\tkeys: function () { return keys; },\n\t\t\t\t\tentries: function () { return all; },\n\t\t\t\t\tget: function (n) { return headers[n.toLowerCase()]; },\n\t\t\t\t\thas: function (n) { return n.toLowerCase() in headers; }\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n};\n\nexport default index;\n//# sourceMappingURL=unfetch.es.js.map\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/unfetch/dist/unfetch.es.js","module.exports = window.fetch || (window.fetch = require('unfetch').default || require('unfetch'));\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/isomorphic-unfetch/browser.js","/*!\n * Copyright 2015 Netflix, Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.falcor = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nvar falcor = require(34);\nvar jsong = require(130);\n\nfalcor.atom = jsong.atom;\nfalcor.ref = jsong.ref;\nfalcor.error = jsong.error;\nfalcor.pathValue = jsong.pathValue;\n\nfalcor.HttpDataSource = require(125);\n\nmodule.exports = falcor;\n\n},{\"125\":125,\"130\":130,\"34\":34}],2:[function(require,module,exports){\nvar ModelRoot = require(4);\nvar ModelDataSourceAdapter = require(3);\n\nvar RequestQueue = require(44);\nvar ModelResponse = require(52);\nvar CallResponse = require(50);\nvar InvalidateResponse = require(51);\n\nvar ASAPScheduler = require(67);\nvar TimeoutScheduler = require(69);\nvar ImmediateScheduler = require(68);\n\nvar arrayClone = require(75);\nvar arraySlice = require(79);\n\nvar collectLru = require(40);\nvar pathSyntax = require(134);\n\nvar getSize = require(85);\nvar isObject = require(97);\nvar isPrimitive = require(99);\nvar isJSONEnvelope = require(95);\nvar isJSONGraphEnvelope = require(96);\n\nvar setCache = require(71);\nvar setJSONGraphs = require(70);\nvar jsong = require(130);\nvar ID = 0;\nvar validateInput = require(113);\nvar noOp = function() {};\nvar getCache = require(18);\nvar get = require(23);\nvar GET_VALID_INPUT = require(59);\n\nmodule.exports = Model;\n\nModel.ref = jsong.ref;\nModel.atom = jsong.atom;\nModel.error = jsong.error;\nModel.pathValue = jsong.pathValue;\n/**\n * This callback is invoked when the Model's cache is changed.\n * @callback Model~onChange\n */\n\n /**\n * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.\n * @callback Model~errorSelector\n * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.\n * @returns {Object} the JSONGraph Error object to store in the Model cache.\n */\n\n /**\n * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.\n * @callback Model~comparator\n * @param {Object} existingValue - the current value in the Model cache.\n * @param {Object} newValue - the value about to be set into the Model cache.\n * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.\n */\n\n/**\n * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.\n * @constructor\n * @param {?Object} options - a set of options to customize behavior\n * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}\n * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}\n * @param {?number} options.maxSize - the maximum size of the cache. This value roughly correlates to item count (where itemCount = maxSize / 50). Each item by default is given a metadata `$size` of 50 (or its length when it's an array or string). You can get better control of falcor's memory usage by tweaking `$size`\n * @param {?number} options.maxRetries - the maximum number of times that the Model will attempt to retrieve the value from the server.\n * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded\n * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned\n * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed\n * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.\n */\nfunction Model(o) {\n\n    var options = o || {};\n    this._root = options._root || new ModelRoot(options);\n    this._path = options.path || options._path || [];\n    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();\n    this._source = options.source || options._source;\n    this._request = options.request || options._request || new RequestQueue(this, this._scheduler);\n    this._ID = ID++;\n\n    if (typeof options.maxSize === \"number\") {\n        this._maxSize = options.maxSize;\n    } else {\n        this._maxSize = options._maxSize || Model.prototype._maxSize;\n    }\n\n    if (typeof options.maxRetries === \"number\") {\n        this._maxRetries = options.maxRetries;\n    } else {\n        this._maxRetries = options._maxRetries || Model.prototype._maxRetries;\n    }\n\n    if (typeof options.collectRatio === \"number\") {\n        this._collectRatio = options.collectRatio;\n    } else {\n        this._collectRatio = options._collectRatio || Model.prototype._collectRatio;\n    }\n\n    if (options.boxed || options.hasOwnProperty(\"_boxed\")) {\n        this._boxed = options.boxed || options._boxed;\n    }\n\n    if (options.materialized || options.hasOwnProperty(\"_materialized\")) {\n        this._materialized = options.materialized || options._materialized;\n    }\n\n    if (typeof options.treatErrorsAsValues === \"boolean\") {\n        this._treatErrorsAsValues = options.treatErrorsAsValues;\n    } else if (options.hasOwnProperty(\"_treatErrorsAsValues\")) {\n        this._treatErrorsAsValues = options._treatErrorsAsValues;\n    }\n\n    this._useServerPaths = options._useServerPaths || false;\n\n    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame ||\n        options._allowFromWhenceYouCame || false;\n\n    this._treatDataSourceErrorsAsJSONGraphErrors = options._treatDataSourceErrorsAsJSONGraphErrors || false;\n\n    if (options.cache) {\n        this.setCache(options.cache);\n    }\n}\n\nModel.prototype.constructor = Model;\n\nModel.prototype._materialized = false;\nModel.prototype._boxed = false;\nModel.prototype._progressive = false;\nModel.prototype._treatErrorsAsValues = false;\nModel.prototype._maxSize = Math.pow(2, 53) - 1;\nModel.prototype._maxRetries = 3;\nModel.prototype._collectRatio = 0.75;\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype.get = require(58);\n\n/**\n * _getOptimizedBoundPath is an extension point for internal users to polyfill\n * legacy soft-bind behavior, as opposed to deref (hardBind). Current falcor\n * only supports deref, and assumes _path to be a fully optimized path.\n * @function\n * @private\n * @return {Path} - fully optimized bound path for the model\n */\nModel.prototype._getOptimizedBoundPath = function _getOptimizedBoundPath() {\n    return arrayClone(this._path);\n};\n\n/**\n * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.\n * @function\n * @private\n * @param {Array.<PathSet>} paths - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON\n */\nModel.prototype._getWithPaths = require(57);\n\n/**\n * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.\n * @function\n * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted\n */\nModel.prototype.set = require(63);\n\n/**\n * Observes the value at provided paths, notifies for changes made at those paths in the local cache\n * @function\n * @return {ObserveResponse} - an {@link Observable} stream containing the paths which got updated\n */\nModel.prototype.observe = require(61);\n\n/**\n * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.\n * @function\n * @param {...PathSet} path - the path(s) to retrieve\n * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.\n */\nModel.prototype.preload = function preload() {\n    var out = validateInput(arguments, GET_VALID_INPUT, \"preload\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n    var args = Array.prototype.slice.call(arguments);\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.get.apply(self, args).subscribe(function() {\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n\n/**\n * Invokes a function in the JSON Graph.\n * @function\n * @param {Path} functionPath - the path to the function to invoke\n * @param {Array.<Object>} args - the arguments to pass to the function\n * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function\n * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution\n * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function\n */\nModel.prototype.call = function call() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = new Array(argsLen);\n    while (++argsIdx < argsLen) {\n        var arg = arguments[argsIdx];\n        args[argsIdx] = arg;\n        var argType = typeof arg;\n        if (argsIdx > 1 && !Array.isArray(arg) ||\n            argsIdx === 0 && !Array.isArray(arg) && argType !== \"string\" ||\n            argsIdx === 1 && !Array.isArray(arg) && !isPrimitive(arg)) {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Invalid argument\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    return new CallResponse(this, args[0], args[1], args[2], args[3]);\n};\n\n/**\n * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.\n * @function\n * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.\n */\nModel.prototype.invalidate = function invalidate() {\n    var args;\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    args = [];\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = pathSyntax.fromPath(arguments[argsIdx]);\n        if (!Array.isArray(args[argsIdx]) || !args[argsIdx].length) {\n            throw new Error(\"Invalid argument\");\n        }\n    }\n\n    // creates the obs, subscribes and will throw the errors if encountered.\n    (new InvalidateResponse(this, args)).\n        subscribe(noOp, function(e) {\n            throw e;\n        });\n};\n\n/**\n * Returns a new {@link Model} bound to a location within the {@link\n * JSONGraph}. The bound location is never a {@link Reference}: any {@link\n * Reference}s encountered while resolving the bound {@link Path} are always\n * replaced with the {@link Reference}s target value. For subsequent operations\n * on the {@link Model}, all paths will be evaluated relative to the bound\n * path. Deref allows you to:\n * - Expose only a fragment of the {@link JSONGraph} to components, rather than\n *   the entire graph\n * - Hide the location of a {@link JSONGraph} fragment from components\n * - Optimize for executing multiple operations and path looksup at/below the\n *   same location in the {@link JSONGraph}\n * @method\n * @param {Object} responseObject - an object previously retrieved from the\n * Model\n * @return {Model} - the dereferenced {@link Model}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.deref = require(6);\n\n/**\n * A dereferenced model can become invalid when the reference from which it was\n * built has been removed/collected/expired/etc etc.  To fix the issue, a from\n * the parent request should be made (no parent, then from the root) for a valid\n * path and re-dereference performed to update what the model is bound too.\n *\n * @method\n * @private\n * @return {Boolean} - If the currently deref'd model is still considered a\n * valid deref.\n */\nModel.prototype._hasValidParentReference = require(5);\n\n/**\n * Get data for a single {@link Path}.\n * @param {Path} path - the path to retrieve\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     getValue('user.name').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.getValue = require(20);\n\n/**\n * Set value for a single {@link Path}.\n * @param {Path} path - the path to set\n * @param {Object} value - the value to set\n * @return {Observable.<*>} - the value for the path\n * @example\n var model = new falcor.Model({source: new falcor.HttpDataSource(\"/model.json\") });\n\n model.\n     setValue('user.name', 'Jim').\n     subscribe(function(name) {\n         console.log(name);\n     });\n\n // The code above prints \"Jim\" to the console.\n */\nModel.prototype.setValue = require(73);\n\n// TODO: Does not throw if given a PathSet rather than a Path, not sure if it should or not.\n// TODO: Doc not accurate? I was able to invoke directly against the Model, perhaps because I don't have a data source?\n// TODO: Not clear on what it means to \"retrieve objects in addition to JSONGraph values\"\n/**\n * Synchronously retrieves a single path from the local {@link Model} only and will not retrieve missing paths from the {@link DataSource}. This method can only be invoked when the {@link Model} does not have a {@link DataSource} or from within a selector function. See {@link Model.prototype.get}. The getValueSync method differs from the asynchronous get methods (ex. get, getValues) in that it can be used to retrieve objects in addition to JSONGraph values.\n * @method\n * @private\n * @arg {Path} path - the path to retrieve\n * @return {*} - the value for the specified path\n */\nModel.prototype._getValueSync = require(28);\n\n/**\n * @private\n */\nModel.prototype._setValueSync = require(74);\n\n/**\n * @private\n */\nModel.prototype._derefSync = require(7);\n\n/**\n * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.\n * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache\n */\nModel.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {\n    var cache = this._root.cache;\n    if (cacheOrJSONGraphEnvelope !== cache) {\n        var modelRoot = this._root;\n        var boundPath = this._path;\n        this._path = [];\n        this._root.cache = {};\n        if (typeof cache !== \"undefined\") {\n            collectLru(modelRoot, modelRoot.expired, getSize(cache), 0);\n        }\n        var out;\n        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setJSONGraphs(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [cacheOrJSONGraphEnvelope])[0];\n        } else if (isObject(cacheOrJSONGraphEnvelope)) {\n            out = setCache(this, [{ json: cacheOrJSONGraphEnvelope }])[0];\n        }\n\n        // performs promotion without producing output.\n        if (out) {\n            get.getWithPathsAsPathMap(this, out, []);\n        }\n        this._path = boundPath;\n    } else if (typeof cache === \"undefined\") {\n        this._root.cache = {};\n    }\n    return this;\n};\n\n/**\n * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.\n * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.\n * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.\n * @example\n // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.\n localStorage.setItem('cache', JSON.stringify(model.getCache(\"genreLists[0...10][0...10].boxshot\")));\n */\nModel.prototype.getCache = function _getCache() {\n    var paths = arraySlice(arguments);\n    if (paths.length === 0) {\n        return getCache(this._root.cache);\n    }\n\n    var result = [{}];\n    var path = this._path;\n    get.getWithPathsAsJSONGraph(this, paths, result);\n    this._path = path;\n    return result[0].jsonGraph;\n};\n\n/**\n * Reset cache maxSize. When the new maxSize is smaller than the old force a collect.\n * @param {Number} maxSize - the new maximum cache size\n */\nModel.prototype._setMaxSize = function setMaxSize(maxSize) {\n    var oldMaxSize = this._maxSize;\n    this._maxSize = maxSize;\n    if (maxSize < oldMaxSize) {\n        var modelRoot = this._root;\n        var modelCache = modelRoot.cache;\n        // eslint-disable-next-line no-cond-assign\n        var currentVersion = modelCache.$_version;\n        collectLru(modelRoot, modelRoot.expired, getSize(modelCache),\n                this._maxSize, this._collectRatio, currentVersion);\n    }\n};\n\n/**\n * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.\n * @param {Path?} path - a path at which to retrieve the version number\n * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path\n */\nModel.prototype.getVersion = function getVersion(pathArg) {\n    var path = pathArg && pathSyntax.fromPath(pathArg) || [];\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#getVersion must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    return this._getVersion(this, path);\n};\n\nModel.prototype._syncCheck = function syncCheck(name) {\n    if (Boolean(this._source) && this._root.syncRefCount <= 0 && this._root.unsafeMode === false) {\n        throw new Error(\"Model#\" + name + \" may only be called within the context of a request selector.\");\n    }\n    return true;\n};\n\n/* eslint-disable guard-for-in */\nModel.prototype._clone = function cloneModel(opts) {\n    var clone = new this.constructor(this);\n    for (var key in opts) {\n        var value = opts[key];\n        if (value === \"delete\") {\n            delete clone[key];\n        } else {\n            clone[key] = value;\n        }\n    }\n    clone.setCache = void 0;\n    return clone;\n};\n/* eslint-enable */\n\n/**\n * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.\n * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.\n * @return {Model} a Model which schedules a batch of get requests to the DataSource.\n */\nModel.prototype.batch = function batch(schedulerOrDelayArg) {\n    var schedulerOrDelay = schedulerOrDelayArg;\n    if (typeof schedulerOrDelay === \"number\") {\n        schedulerOrDelay = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));\n    } else if (!schedulerOrDelay || !schedulerOrDelay.schedule) {\n        schedulerOrDelay = new ASAPScheduler();\n    }\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, schedulerOrDelay);\n\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.\n * @name unbatch\n * @memberof Model.prototype\n * @function\n * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together\n */\nModel.prototype.unbatch = function unbatch() {\n    var clone = this._clone();\n    clone._request = new RequestQueue(clone, new ImmediateScheduler());\n    return clone;\n};\n\n/**\n * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.\n * @return {Model}\n */\nModel.prototype.treatErrorsAsValues = function treatErrorsAsValues() {\n    return this._clone({\n        _treatErrorsAsValues: true\n    });\n};\n\n/**\n * Adapts a Model to the {@link DataSource} interface.\n * @return {DataSource}\n * @example\nvar model =\n    new falcor.Model({\n        cache: {\n            user: {\n                name: \"Steve\",\n                surname: \"McGuire\"\n            }\n        }\n    }),\n    proxyModel = new falcor.Model({ source: model.asDataSource() });\n\n// Prints \"Steve\"\nproxyModel.getValue(\"user.name\").\n    then(function(name) {\n        console.log(name);\n    });\n */\nModel.prototype.asDataSource = function asDataSource() {\n    return new ModelDataSourceAdapter(this);\n};\n\nModel.prototype._materialize = function materialize() {\n    return this._clone({\n        _materialized: true\n    });\n};\n\nModel.prototype._dematerialize = function dematerialize() {\n    return this._clone({\n        _materialized: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.\n * @return {Model}\n */\nModel.prototype.boxValues = function boxValues() {\n    return this._clone({\n        _boxed: true\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.\n * @return {Model}\n */\nModel.prototype.unboxValues = function unboxValues() {\n    return this._clone({\n        _boxed: \"delete\"\n    });\n};\n\n/**\n * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.\n * @return {Model}\n */\nModel.prototype.withoutDataSource = function withoutDataSource() {\n    return this._clone({\n        _source: \"delete\"\n    });\n};\n\nModel.prototype.toJSON = function toJSON() {\n    return {\n        $type: \"ref\",\n        value: this._path\n    };\n};\n\n/**\n * Returns the {@link Path} to the object within the JSON Graph that this Model references.\n * @return {Path}\n * @example\nvar Model = falcor.Model;\nvar model = new Model({\n  cache: {\n    users: [\n      Model.ref([\"usersById\", 32])\n    ],\n    usersById: {\n      32: {\n        name: \"Steve\",\n        surname: \"McGuire\"\n      }\n    }\n  }\n});\n\nmodel.\n    get(['users', 0, 'name']).\n    subscribe(function(jsonEnv) {\n        var userModel = model.deref(jsonEnv.json.users[0]);\n        console.log(model.getPath());\n        console.log(userModel.getPath());\n   });\n});\n\n// prints the following:\n// []\n// [\"usersById\", 32] - because userModel refers to target of reference at [\"users\", 0]\n */\nModel.prototype.getPath = function getPath() {\n    return arrayClone(this._path);\n};\n\n/**\n * This one is actually private.  I would not use this without talking to\n * jhusain, sdesai, or michaelbpaulson (github).\n * @private\n */\nModel.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {\n    return this._clone({\n        _allowFromWhenceYouCame: allow === undefined ? true : allow\n    });\n};\n\nModel.prototype._getBoundValue = require(17);\nModel.prototype._getVersion = require(22);\n\nModel.prototype._getPathValuesAsPathMap = get.getWithPathsAsPathMap;\nModel.prototype._getPathValuesAsJSONG = get.getWithPathsAsJSONGraph;\n\nModel.prototype._setPathValues = require(72);\nModel.prototype._setPathMaps = require(71);\nModel.prototype._setJSONGs = require(70);\nModel.prototype._setCache = require(71);\n\nModel.prototype._invalidatePathValues = require(39);\nModel.prototype._invalidatePathMaps = require(38);\n\n},{\"113\":113,\"130\":130,\"134\":134,\"17\":17,\"18\":18,\"20\":20,\"22\":22,\"23\":23,\"28\":28,\"3\":3,\"38\":38,\"39\":39,\"4\":4,\"40\":40,\"44\":44,\"5\":5,\"50\":50,\"51\":51,\"52\":52,\"57\":57,\"58\":58,\"59\":59,\"6\":6,\"61\":61,\"63\":63,\"67\":67,\"68\":68,\"69\":69,\"7\":7,\"70\":70,\"71\":71,\"72\":72,\"73\":73,\"74\":74,\"75\":75,\"79\":79,\"85\":85,\"95\":95,\"96\":96,\"97\":97,\"99\":99}],3:[function(require,module,exports){\nfunction ModelDataSourceAdapter(model) {\n    this._model = model._materialize().treatErrorsAsValues();\n}\n\nModelDataSourceAdapter.prototype.get = function get(pathSets) {\n    return this._model.get.apply(this._model, pathSets)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.set = function set(jsongResponse) {\n    return this._model.set(jsongResponse)._toJSONG();\n};\n\nModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {\n    var params = [path, args, suffixes].concat(paths);\n    return this._model.call.apply(this._model, params)._toJSONG();\n};\n\nmodule.exports = ModelDataSourceAdapter;\n\n},{}],4:[function(require,module,exports){\nvar isFunction = require(93);\nvar hasOwn = require(88);\nvar ImmediateScheduler = require(68);\n\nfunction ModelRoot(o) {\n\n    var options = o || {};\n\n    this.syncRefCount = 0;\n    this.expired = options.expired || [];\n    this.unsafeMode = options.unsafeMode || false;\n    this.collectionScheduler = options.collectionScheduler || new ImmediateScheduler();\n    this.cache = {};\n    this._pathObservers = [];\n\n    if (isFunction(options.comparator)) {\n        this.comparator = options.comparator;\n    }\n\n    if (isFunction(options.errorSelector)) {\n        this.errorSelector = options.errorSelector;\n    }\n\n    if (isFunction(options.onChange)) {\n        this.onChange = options.onChange;\n    }\n}\n\nModelRoot.prototype.errorSelector = function errorSelector(x, y) {\n    return y;\n};\nModelRoot.prototype.comparator = function comparator(cacheNode, messageNode) {\n    if (hasOwn(cacheNode, \"value\") && hasOwn(messageNode, \"value\")) {\n        // They are the same only if the following fields are the same.\n        return cacheNode.value === messageNode.value &&\n            cacheNode.$type === messageNode.$type &&\n            cacheNode.$expires === messageNode.$expires;\n    }\n    return cacheNode === messageNode;\n};\n\nModelRoot.prototype.onObserve = function(affectedPaths, affectedPathMap) {\n    this._pathObservers.forEach(function(pathObserver) {\n        if (pathMapsIntersect(pathObserver.pathMap, affectedPathMap)) {\n            pathObserver.observer.onNext(affectedPaths);\n        }\n    });\n};\n\nModelRoot.prototype.hasObservers = function() {\n    return this._pathObservers.length > 0;\n};\n\nfunction pathMapsIntersect(left, right) {\n    if (left === null && right === null) {\n        return true;\n    }\n    if (typeof left !== \"object\" || typeof right !== \"object\") {\n        return false;\n    }\n    var leftKeys = Object.keys(left);\n    var key;\n    for (var i = 0; i < leftKeys.length; i++) {\n        key = leftKeys[i];\n        if (pathMapsIntersect(left[key], right[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nmodule.exports = ModelRoot;\n\n},{\"68\":68,\"88\":88,\"93\":93}],5:[function(require,module,exports){\nmodule.exports = function fromWhenceYeCame() {\n    var reference = this._referenceContainer;\n\n    // Always true when this mode is false.\n    if (!this._allowFromWhenceYouCame) {\n        return true;\n    }\n\n    // If fromWhenceYouCame is true and the first set of keys did not have\n    // a reference, this case can happen.  They are always valid.\n    if (reference === true) {\n        return true;\n    }\n\n    // was invalid before even derefing.\n    if (reference === false) {\n        return false;\n    }\n\n    // Its been disconnected (set over or collected) from the graph.\n    // eslint-disable-next-line camelcase\n    if (reference && reference.$_parent === undefined) {\n        return false;\n    }\n\n    // The reference has expired but has not been collected from the graph.\n    // eslint-disable-next-line camelcase\n    if (reference && reference.$_invalidated) {\n        return false;\n    }\n\n    return true;\n};\n\n},{}],6:[function(require,module,exports){\nvar InvalidDerefInputError = require(9);\nvar getCachePosition = require(19);\nvar CONTAINER_DOES_NOT_EXIST = \"e\";\nvar $ref = require(118);\n\nmodule.exports = function deref(boundJSONArg) {\n\n    var absolutePath = boundJSONArg && boundJSONArg.$__path;\n    var refPath = boundJSONArg && boundJSONArg.$__refPath;\n    var toReference = boundJSONArg && boundJSONArg.$__toReference;\n    var referenceContainer;\n\n    // We deref and then ensure that the reference container is attached to\n    // the model.\n    if (absolutePath) {\n        var validContainer = CONTAINER_DOES_NOT_EXIST;\n\n        if (toReference) {\n            validContainer = false;\n            referenceContainer = getCachePosition(this, toReference);\n\n            // If the reference container is still a sentinel value then compare\n            // the reference value with refPath.  If they are the same, then the\n            // model is still valid.\n            if (refPath && referenceContainer &&\n                referenceContainer.$type === $ref) {\n\n                var containerPath = referenceContainer.value;\n                var i = 0;\n                var len = refPath.length;\n\n                validContainer = true;\n                for (; validContainer && i < len; ++i) {\n                    if (containerPath[i] !== refPath[i]) {\n                        validContainer = false;\n                    }\n                }\n            }\n        }\n\n        // Signal to the deref'd model that it has been disconnected from the\n        // graph or there is no _fromWhenceYouCame\n        if (!validContainer) {\n            referenceContainer = false;\n        }\n\n        // The container did not exist, therefore there is no reference\n        // container and fromWhenceYouCame should always return true.\n        else if (validContainer === CONTAINER_DOES_NOT_EXIST) {\n            referenceContainer = true;\n        }\n\n        return this._clone({\n            _path: absolutePath,\n            _referenceContainer: referenceContainer\n        });\n    }\n\n    throw new InvalidDerefInputError();\n};\n\n},{\"118\":118,\"19\":19,\"9\":9}],7:[function(require,module,exports){\nvar pathSyntax = require(134);\nvar getBoundValue = require(17);\nvar InvalidModelError = require(10);\n\nmodule.exports = function derefSync(boundPathArg) {\n\n    var boundPath = pathSyntax.fromPath(boundPathArg);\n\n    if (!Array.isArray(boundPath)) {\n        throw new Error(\"Model#derefSync must be called with an Array path.\");\n    }\n\n    var boundValue = getBoundValue(this, this._path.concat(boundPath), false);\n\n    var path = boundValue.path;\n    var node = boundValue.value;\n    var found = boundValue.found;\n\n    // If the node is not found or the node is found but undefined is returned,\n    // this happens when a reference is expired.\n    if (!found || node === undefined) {\n        return undefined;\n    }\n\n    if (node.$type) {\n        throw new InvalidModelError(path, path);\n    }\n\n    return this._clone({ _path: path });\n};\n\n},{\"10\":10,\"134\":134,\"17\":17}],8:[function(require,module,exports){\nvar applyErrorPrototype = require(14);\n\n/**\n * When a bound model attempts to retrieve JSONGraph it should throw an\n * error.\n *\n * @private\n */\nfunction BoundJSONGraphModelError() {\n    var instance = new Error(\"It is not legal to use the JSON Graph \" +\n    \"format from a bound Model. JSON Graph format\" +\n    \" can only be used from a root model.\");\n\n    instance.name = \"BoundJSONGraphModelError\";\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, BoundJSONGraphModelError);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype(BoundJSONGraphModelError);\n\nmodule.exports = BoundJSONGraphModelError;\n\n},{\"14\":14}],9:[function(require,module,exports){\nvar applyErrorPrototype = require(14);\n\n/**\n * An invalid deref input is when deref is used with input that is not generated\n * from a get, set, or a call.\n *\n * @private\n */\nfunction InvalidDerefInputError() {\n    var instance = new Error(\"Deref can only be used with a non-primitive object from get, set, or call.\");\n\n    instance.name = \"InvalidDerefInputError\";\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, InvalidDerefInputError);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype(InvalidDerefInputError);\n\nmodule.exports = InvalidDerefInputError;\n\n},{\"14\":14}],10:[function(require,module,exports){\nvar applyErrorPrototype = require(14);\n\n/**\n * An InvalidModelError can only happen when a user binds, whether sync\n * or async to shorted value.  See the unit tests for examples.\n *\n * @param {*} boundPath\n * @param {*} shortedPath\n *\n * @private\n */\nfunction InvalidModelError(boundPath, shortedPath) {\n    var instance = new Error(\"The boundPath of the model is not valid since a value or error was found before the path end.\");\n\n    instance.name = \"InvalidModelError\";\n    instance.boundPath = boundPath;\n    instance.shortedPath = shortedPath;\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, InvalidModelError);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype(InvalidModelError);\n\nmodule.exports = InvalidModelError;\n\n},{\"14\":14}],11:[function(require,module,exports){\nvar applyErrorPrototype = require(14);\n\n/**\n * InvalidSourceError happens when a dataSource syncronously throws\n * an exception during a get/set/call operation.\n *\n * @param {Error} error - The error that was thrown.\n *\n * @private\n */\nfunction InvalidSourceError(error) {\n    var instance = new Error(\"An exception was thrown when making a request.\");\n\n    instance.name = \"InvalidSourceError\";\n    instance.innerError = error;\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, InvalidSourceError);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype(InvalidSourceError);\n\nmodule.exports = InvalidSourceError;\n\n},{\"14\":14}],12:[function(require,module,exports){\nvar applyErrorPrototype = require(14);\n\n/**\n * A request can only be retried up to a specified limit.  Once that\n * limit is exceeded, then an error will be thrown.\n *\n * @param {*} missingOptimizedPaths\n *\n * @private\n */\nfunction MaxRetryExceededError(missingOptimizedPaths) {\n    var instance = new Error(\"The allowed number of retries have been exceeded.\");\n\n    instance.name = \"MaxRetryExceededError\";\n    instance.missingOptimizedPaths = missingOptimizedPaths || [];\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, MaxRetryExceededError);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype(MaxRetryExceededError);\n\nMaxRetryExceededError.is = function(e) {\n    return e && e.name === \"MaxRetryExceededError\";\n};\n\nmodule.exports = MaxRetryExceededError;\n\n},{\"14\":14}],13:[function(require,module,exports){\nvar applyErrorPrototype = require(14);\n\n/**\n * Does not allow null in path\n *\n * @private\n */\nfunction NullInPathError() {\n    var instance = new Error(\"`null` is not allowed in branch key positions.\");\n\n    instance.name = \"NullInPathError\";\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    }\n\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(instance, NullInPathError);\n    }\n\n    return instance;\n}\n\napplyErrorPrototype(NullInPathError);\n\nmodule.exports = NullInPathError;\n\n},{\"14\":14}],14:[function(require,module,exports){\nfunction applyErrorPrototype(errorType) {\n    errorType.prototype = Object.create(Error.prototype, {\n        constructor: {\n        value: Error,\n        enumerable: false,\n        writable: true,\n        configurable: true\n        }\n    });\n\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(errorType, Error);\n    } else {\n        // eslint-disable-next-line\n        errorType.__proto__ = Error;\n    }\n}\n\nmodule.exports = applyErrorPrototype;\n\n},{}],15:[function(require,module,exports){\nvar createHardlink = require(81);\nvar onValue = require(26);\nvar isExpired = require(30);\nvar $ref = require(118);\nvar promote = require(41);\n\n/* eslint-disable no-constant-condition */\nfunction followReference(model, root, nodeArg, referenceContainerArg,\n                         referenceArg, seed, isJSONG) {\n\n    var node = nodeArg;\n    var reference = referenceArg;\n    var referenceContainer = referenceContainerArg;\n    var depth = 0;\n    var k, next;\n\n    while (true) {\n        if (depth === 0 && referenceContainer.$_context) {\n            depth = reference.length;\n            next = referenceContainer.$_context;\n        } else {\n            k = reference[depth++];\n            next = node[k];\n        }\n        if (next) {\n            var type = next.$type;\n            var value = type && next.value || next;\n\n            if (depth < reference.length) {\n                if (type) {\n                    node = next;\n                    break;\n                }\n\n                node = next;\n                continue;\n            }\n\n            // We need to report a value or follow another reference.\n            else {\n\n                node = next;\n\n                if (type && isExpired(next)) {\n                    break;\n                }\n\n                if (!referenceContainer.$_context) {\n                    createHardlink(referenceContainer, next);\n                }\n\n                // Restart the reference follower.\n                if (type === $ref) {\n\n                    // Nulls out the depth, outerResults,\n                    if (isJSONG) {\n                        onValue(model, next, seed, null, null, null, null,\n                                reference, reference.length, isJSONG);\n                    } else {\n                        promote(model._root, next);\n                    }\n\n                    depth = 0;\n                    reference = value;\n                    referenceContainer = next;\n                    node = root;\n                    continue;\n                }\n\n                break;\n            }\n        } else {\n            node = void 0;\n        }\n        break;\n    }\n\n\n    if (depth < reference.length && node !== void 0) {\n        var ref = [];\n        for (var i = 0; i < depth; i++) {\n            ref[i] = reference[i];\n        }\n        reference = ref;\n    }\n\n    return [node, reference, referenceContainer];\n}\n/* eslint-enable */\n\nmodule.exports = followReference;\n\n},{\"118\":118,\"26\":26,\"30\":30,\"41\":41,\"81\":81}],16:[function(require,module,exports){\nvar getCachePosition = require(19);\nvar InvalidModelError = require(10);\nvar BoundJSONGraphModelError = require(8);\n\nfunction mergeInto(target, obj) {\n    /* eslint guard-for-in: 0 */\n    if (target === obj) {\n        return;\n    }\n    if (target === null || typeof target !== \"object\" || target.$type) {\n        return;\n    }\n    if (obj === null || typeof obj !== \"object\" || obj.$type) {\n        return;\n    }\n\n    for (var key in obj) {\n        // When merging over a temporary branch structure (for example, as produced by an error selector)\n        // with references, we don't want to mutate the path, particularly because it's also $_absolutePath\n        // on cache nodes\n        if (key === \"$__path\") {\n            continue;\n        }\n\n        var targetValue = target[key];\n        if (targetValue === undefined) {\n            target[key] = obj[key];\n        } else {\n            mergeInto(targetValue, obj[key]);\n        }\n    }\n}\n\nfunction defaultEnvelope(isJSONG) {\n    return isJSONG ? {jsonGraph: {}, paths: []} : {json: {}};\n}\n\nmodule.exports = function get(walk, isJSONG) {\n    return function innerGet(model, paths, seed) {\n        // Result valueNode not immutable for isJSONG.\n        var nextSeed = isJSONG ? seed : [{}];\n        var valueNode = nextSeed[0];\n        var results = {\n            values: nextSeed,\n            optimizedPaths: []\n        };\n        var cache = model._root.cache;\n        var boundPath = model._path;\n        var currentCachePosition = cache;\n        var optimizedPath, optimizedLength;\n        var i, len;\n        var requestedPath = [];\n        var derefInfo = [];\n        var referenceContainer;\n\n        // If the model is bound, then get that cache position.\n        if (boundPath.length) {\n\n            // JSONGraph output cannot ever be bound or else it will\n            // throw an error.\n            if (isJSONG) {\n                return {\n                    criticalError: new BoundJSONGraphModelError()\n                };\n            }\n\n            // using _getOptimizedPath because that's a point of extension\n            // for polyfilling legacy falcor\n            optimizedPath = model._getOptimizedBoundPath();\n            optimizedLength = optimizedPath.length;\n\n            // We need to get the new cache position path.\n            currentCachePosition = getCachePosition(model, optimizedPath);\n\n            // If there was a short, then we 'throw an error' to the outside\n            // calling function which will onError the observer.\n            if (currentCachePosition && currentCachePosition.$type) {\n                return {\n                    criticalError: new InvalidModelError(boundPath, optimizedPath)\n                };\n            }\n\n            referenceContainer = model._referenceContainer;\n        }\n\n        // Update the optimized path if we\n        else {\n            optimizedPath = [];\n            optimizedLength = 0;\n        }\n\n        for (i = 0, len = paths.length; i < len; i++) {\n            walk(model, cache, currentCachePosition, paths[i], 0,\n                 valueNode, results, derefInfo, requestedPath, optimizedPath,\n                 optimizedLength, isJSONG, false, referenceContainer);\n        }\n\n        // Merge in existing results.\n        // Default to empty envelope if no results were emitted\n        mergeInto(valueNode, paths.length ? seed[0] : defaultEnvelope(isJSONG));\n\n        return results;\n    };\n};\n\n},{\"10\":10,\"19\":19,\"8\":8}],17:[function(require,module,exports){\nvar getValueSync = require(21);\nvar InvalidModelError = require(10);\n\nmodule.exports = function getBoundValue(model, pathArg, materialized) {\n\n    var path = pathArg;\n    var boundPath = pathArg;\n    var boxed, treatErrorsAsValues,\n        value, shorted, found;\n\n    boxed = model._boxed;\n    materialized = model._materialized;\n    treatErrorsAsValues = model._treatErrorsAsValues;\n\n    model._boxed = true;\n    model._materialized = materialized === undefined || materialized;\n    model._treatErrorsAsValues = true;\n\n    value = getValueSync(model, path.concat(null), true);\n\n    model._boxed = boxed;\n    model._materialized = materialized;\n    model._treatErrorsAsValues = treatErrorsAsValues;\n\n    path = value.optimizedPath;\n    shorted = value.shorted;\n    found = value.found;\n    value = value.value;\n\n    while (path.length && path[path.length - 1] === null) {\n        path.pop();\n    }\n\n    if (found && shorted) {\n        throw new InvalidModelError(boundPath, path);\n    }\n\n    return {\n        path: path,\n        value: value,\n        shorted: shorted,\n        found: found\n    };\n};\n\n},{\"10\":10,\"21\":21}],18:[function(require,module,exports){\nvar isInternalKey = require(94);\n\n/**\n * decends and copies the cache.\n */\nmodule.exports = function getCache(cache) {\n    var out = {};\n    _copyCache(cache, out);\n\n    return out;\n};\n\nfunction cloneBoxedValue(boxedValue) {\n    var clonedValue = {};\n\n    var keys = Object.keys(boxedValue);\n    var key;\n    var i;\n    var l;\n\n    for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n\n        if (!isInternalKey(key)) {\n            clonedValue[key] = boxedValue[key];\n        }\n    }\n\n    return clonedValue;\n}\n\nfunction _copyCache(node, out, fromKey) {\n    // copy and return\n\n    Object.\n        keys(node).\n        filter(function(k) {\n            // Its not an internal key and the node has a value.  In the cache\n            // there are 3 possibilities for values.\n            // 1: A branch node.\n            // 2: A $type-value node.\n            // 3: undefined\n            // We will strip out 3\n            return !isInternalKey(k) && node[k] !== undefined;\n        }).\n        forEach(function(key) {\n            var cacheNext = node[key];\n            var outNext = out[key];\n\n            if (!outNext) {\n                outNext = out[key] = {};\n            }\n\n            // Paste the node into the out cache.\n            if (cacheNext.$type) {\n                var isObject = cacheNext.value && typeof cacheNext.value === \"object\";\n                var isUserCreatedcacheNext = !cacheNext.$_modelCreated;\n                var value;\n                if (isObject || isUserCreatedcacheNext) {\n                    value = cloneBoxedValue(cacheNext);\n                } else {\n                    value = cacheNext.value;\n                }\n\n                out[key] = value;\n                return;\n            }\n\n            _copyCache(cacheNext, outNext, key);\n        });\n}\n\n},{\"94\":94}],19:[function(require,module,exports){\n/**\n * getCachePosition makes a fast walk to the bound value since all bound\n * paths are the most possible optimized path.\n *\n * @param {Model} model -\n * @param {Array} path -\n * @returns {Mixed} - undefined if there is nothing in this position.\n * @private\n */\nmodule.exports = function getCachePosition(model, path) {\n    var currentCachePosition = model._root.cache;\n    var depth = -1;\n    var maxDepth = path.length;\n\n    // The loop is simple now, we follow the current cache position until\n    //\n    while (++depth < maxDepth &&\n           currentCachePosition && !currentCachePosition.$type) {\n\n        currentCachePosition = currentCachePosition[path[depth]];\n    }\n\n    return currentCachePosition;\n};\n\n},{}],20:[function(require,module,exports){\nvar ModelResponse = require(52);\nvar pathSyntax = require(134);\n\nmodule.exports = function getValue(path) {\n    var parsedPath = pathSyntax.fromPath(path);\n    var pathIdx = 0;\n    var pathLen = parsedPath.length;\n    while (++pathIdx < pathLen) {\n        if (typeof parsedPath[pathIdx] === \"object\") {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Paths must be simple paths\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.get(parsedPath).subscribe(function(data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = parsedPath.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[parsedPath[depth]];\n            }\n            obs.onNext(curr);\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n\n},{\"134\":134,\"52\":52}],21:[function(require,module,exports){\nvar followReference = require(15);\nvar clone = require(29);\nvar isExpired = require(30);\nvar promote = require(41);\nvar $ref = require(118);\nvar $atom = require(116);\nvar $error = require(117);\n\nmodule.exports = function getValueSync(model, simplePath, noClone) {\n    var root = model._root.cache;\n    var len = simplePath.length;\n    var optimizedPath = [];\n    var shorted = false, shouldShort = false;\n    var depth = 0;\n    var key, i, next = root, curr = root, out = root, type, ref, refNode;\n    var found = true;\n    var expired = false;\n\n    while (next && depth < len) {\n        key = simplePath[depth++];\n        if (key !== null) {\n            next = curr[key];\n            optimizedPath[optimizedPath.length] = key;\n        }\n\n        if (!next) {\n            out = undefined;\n            shorted = true;\n            found = false;\n            break;\n        }\n\n        type = next.$type;\n\n        // A materialized item.  There is nothing to deref to.\n        if (type === $atom && next.value === undefined) {\n            out = undefined;\n            found = false;\n            shorted = depth < len;\n            break;\n        }\n\n        // Up to the last key we follow references, ensure that they are not\n        // expired either.\n        if (depth < len) {\n            if (type === $ref) {\n\n                // If the reference is expired then we need to set expired to\n                // true.\n                if (isExpired(next)) {\n                    expired = true;\n                    out = undefined;\n                    break;\n                }\n\n                ref = followReference(model, root, root, next, next.value);\n                refNode = ref[0];\n\n                // The next node is also set to undefined because nothing\n                // could be found, this reference points to nothing, so\n                // nothing must be returned.\n                if (!refNode) {\n                    out = void 0;\n                    next = void 0;\n                    found = false;\n                    break;\n                }\n                type = refNode.$type;\n                next = refNode;\n                optimizedPath = ref[1].slice(0);\n            }\n\n            if (type) {\n                break;\n            }\n        }\n        // If there is a value, then we have great success, else, report an undefined.\n        else {\n            out = next;\n        }\n        curr = next;\n    }\n\n    if (depth < len && !expired) {\n        // Unfortunately, if all that follows are nulls, then we have not shorted.\n        for (i = depth; i < len; ++i) {\n            if (simplePath[depth] !== null) {\n                shouldShort = true;\n                break;\n            }\n        }\n        // if we should short or report value.  Values are reported on nulls.\n        if (shouldShort) {\n            shorted = true;\n            out = void 0;\n        } else {\n            out = next;\n        }\n\n        for (i = depth; i < len; ++i) {\n            if (simplePath[i] !== null) {\n                optimizedPath[optimizedPath.length] = simplePath[i];\n            }\n        }\n    }\n\n    // promotes if not expired\n    if (out && type) {\n        if (isExpired(out)) {\n            out = void 0;\n        } else {\n            promote(model._root, out);\n        }\n    }\n\n    // if (out && out.$type === $error && !model._treatErrorsAsValues) {\n    if (out && type === $error && !model._treatErrorsAsValues) {\n        /* eslint-disable no-throw-literal */\n        throw {\n            path: depth === len ? simplePath : simplePath.slice(0, depth),\n            value: out.value\n        };\n        /* eslint-enable no-throw-literal */\n    } else if (out && model._boxed) {\n        out = Boolean(type) && !noClone ? clone(out) : out;\n    } else if (!out && model._materialized) {\n        out = {$type: $atom};\n    } else if (out) {\n        out = out.value;\n    }\n\n    return {\n        value: out,\n        shorted: shorted,\n        optimizedPath: optimizedPath,\n        found: found\n    };\n};\n\n},{\"116\":116,\"117\":117,\"118\":118,\"15\":15,\"29\":29,\"30\":30,\"41\":41}],22:[function(require,module,exports){\nvar getValueSync = require(21);\n\nmodule.exports = function _getVersion(model, path) {\n    // ultra fast clone for boxed values.\n    var gen = getValueSync({\n        _boxed: true,\n        _root: model._root,\n        _treatErrorsAsValues: model._treatErrorsAsValues\n    }, path, true).value;\n    var version = gen && gen.$_version;\n    return (version == null) ? -1 : version;\n};\n\n},{\"21\":21}],23:[function(require,module,exports){\nvar get = require(16);\nvar walkPath = require(33);\n\nvar getWithPathsAsPathMap = get(walkPath, false);\nvar getWithPathsAsJSONGraph = get(walkPath, true);\n\nmodule.exports = {\n    getValueSync: require(21),\n    getBoundValue: require(17),\n    getWithPathsAsPathMap: getWithPathsAsPathMap,\n    getWithPathsAsJSONGraph: getWithPathsAsJSONGraph\n};\n\n},{\"16\":16,\"17\":17,\"21\":21,\"33\":33}],24:[function(require,module,exports){\nvar promote = require(41);\nvar clone = require(29);\n\nmodule.exports = function onError(model, node, depth,\n                                  requestedPath, outerResults) {\n    var value = node.value;\n    if (!outerResults.errors) {\n        outerResults.errors = [];\n    }\n\n    if (model._boxed) {\n        value = clone(node);\n    }\n    outerResults.errors.push({\n        path: requestedPath.slice(0, depth),\n        value: value\n    });\n    promote(model._root, node);\n};\n\n},{\"29\":29,\"41\":41}],25:[function(require,module,exports){\nvar support = require(32);\nvar fastCopy = support.fastCopy;\nvar fastCat = support.fastCat;\nvar arraySlice = require(79);\n\nmodule.exports = function onMissing(model, path, depth,\n                                    outerResults, requestedPath,\n                                    optimizedPath, optimizedLength) {\n    var pathSlice;\n    if (!outerResults.requestedMissingPaths) {\n        outerResults.requestedMissingPaths = [];\n        outerResults.optimizedMissingPaths = [];\n        outerResults.depthDifferences = [];\n    }\n\n    if (depth < path.length) {\n        // If part of path has not been traversed, we need to ensure that there\n        // are no empty paths (range(1, 0) or empyt array)\n        var isEmpty = false;\n        for (var i = depth; i < path.length && !isEmpty; ++i) {\n            if (isEmptyAtom(path[i])) {\n                return;\n            }\n        }\n\n        pathSlice = fastCopy(path, depth);\n    } else {\n        pathSlice = [];\n    }\n\n    concatAndInsertMissing(model, pathSlice, depth, requestedPath,\n                           optimizedPath, optimizedLength, outerResults);\n};\n\nfunction concatAndInsertMissing(model, remainingPath, depth, requestedPath,\n                                optimizedPath, optimizedLength, results) {\n    results.requestedMissingPaths[results.requestedMissingPaths.length] =\n        fastCat(arraySlice(requestedPath, 0, depth), remainingPath);\n\n    results.optimizedMissingPaths[results.optimizedMissingPaths.length] =\n        fastCat(arraySlice(optimizedPath, 0, optimizedLength), remainingPath);\n\n    results.depthDifferences[results.depthDifferences.length] = depth - optimizedLength;\n}\n\nfunction isEmptyAtom(atom) {\n    if (atom === null || typeof atom !== \"object\") {\n        return false;\n    }\n\n    var isArray = Array.isArray(atom);\n    if (isArray && atom.length) {\n        return false;\n    }\n\n    // Empty array\n    else if (isArray) {\n        return true;\n    }\n\n    var from = atom.from;\n    var to = atom.to;\n    if (from === undefined || from <= to) {\n        return false;\n    }\n\n    return true;\n}\n\n},{\"32\":32,\"79\":79}],26:[function(require,module,exports){\nvar promote = require(41);\nvar clone = require(29);\nvar $ref = require(118);\nvar $atom = require(116);\nvar $error = require(117);\n\nmodule.exports = function onValue(model, node, seed, depth, outerResults,\n                                  branchInfo, requestedPath, optimizedPath,\n                                  optimizedLength, isJSONG) {\n    // Promote first.  Even if no output is produced we should still promote.\n    if (node) {\n        promote(model._root, node);\n    }\n\n    // Preload\n    if (!seed) {\n        return;\n    }\n\n    var i, len, k, key, curr, prev = null, prevK;\n    var materialized = false, valueNode, nodeType = node && node.$type, nodeValue = node && node.value;\n\n    if (!node || node.value === undefined) {\n        materialized = model._materialized;\n    }\n\n    // materialized\n    if (materialized) {\n        valueNode = {$type: $atom};\n    }\n\n    // Boxed Mode will clone the node.\n    else if (model._boxed) {\n        valueNode = clone(node);\n    }\n\n    // We don't want to emit references in json output\n    else if (!isJSONG && nodeType === $ref) {\n        valueNode = undefined;\n    }\n\n    // JSONG always clones the node.\n    else if (nodeType === $ref || nodeType === $error) {\n        if (isJSONG) {\n            valueNode = clone(node);\n        } else {\n            valueNode = nodeValue;\n        }\n    }\n\n    else if (isJSONG) {\n        var isObject = nodeValue && typeof nodeValue === \"object\";\n        var isUserCreatedNode = !node || !node.$_modelCreated;\n        if (isObject || isUserCreatedNode) {\n            valueNode = clone(node);\n        } else {\n            valueNode = nodeValue;\n        }\n    }\n\n    else {\n        valueNode = nodeValue;\n    }\n\n    var hasValues = false;\n\n    if (isJSONG) {\n        curr = seed.jsonGraph;\n        if (!curr) {\n            hasValues = true;\n            curr = seed.jsonGraph = {};\n            seed.paths = [];\n        }\n        for (i = 0, len = optimizedLength - 1; i < len; i++) {\n            key = optimizedPath[i];\n\n            if (!curr[key]) {\n                hasValues = true;\n                curr[key] = {};\n            }\n            curr = curr[key];\n        }\n\n        // assign the last\n        key = optimizedPath[i];\n\n        // TODO: Special case? do string comparisons make big difference?\n        curr[key] = materialized ? {$type: $atom} : valueNode;\n        if (requestedPath) {\n            seed.paths.push(requestedPath.slice(0, depth));\n        }\n    }\n\n    // The output is pathMap and the depth is 0.  It is just a\n    // value report it as the found JSON\n    else if (depth === 0) {\n        hasValues = true;\n        seed.json = valueNode;\n    }\n\n    // The output is pathMap but we need to build the pathMap before\n    // reporting the value.\n    else {\n        curr = seed.json;\n        if (!curr) {\n            hasValues = true;\n            curr = seed.json = {};\n        }\n        for (i = 0; i < depth - 1; i++) {\n            k = requestedPath[i];\n\n            // The branch info is already generated output from the walk algo\n            // with the required __path information on it.\n            if (!curr[k]) {\n                hasValues = true;\n                curr[k] = branchInfo[i];\n            }\n\n            prev = curr;\n            prevK = k;\n            curr = curr[k];\n        }\n        k = requestedPath[i];\n        if (valueNode !== undefined) {\n          if (k !== null) {\n              hasValues = true;\n              curr[k] = valueNode;\n          } else {\n              // We are protected from reaching here when depth is 1 and prev is\n              // undefined by the InvalidModelError and NullInPathError checks.\n              prev[prevK] = valueNode;\n          }\n        }\n    }\n\n    outerResults.hasValues = hasValues;\n};\n\n},{\"116\":116,\"117\":117,\"118\":118,\"29\":29,\"41\":41}],27:[function(require,module,exports){\nvar isExpired = require(30);\nvar $error = require(117);\nvar onError = require(24);\nvar onValue = require(26);\nvar onMissing = require(25);\nvar isMaterialized = require(31);\nvar expireNode = require(83);\nvar currentCacheVersion = require(82);\n\n\n/**\n * When we land on a valueType (or nothing) then we need to report it out to\n * the outerResults through errors, missing, or values.\n *\n * @private\n */\nmodule.exports = function onValueType(\n    model, node, path, depth, seed, outerResults, branchInfo,\n    requestedPath, optimizedPath, optimizedLength, isJSONG, fromReference) {\n\n    var currType = node && node.$type;\n\n    // There are is nothing here, ether report value, or report the value\n    // that is missing.  If there is no type then report the missing value.\n    if (!node || !currType) {\n        var materialized = isMaterialized(model);\n        if (materialized || !isJSONG) {\n            onValue(model, node, seed, depth, outerResults, branchInfo,\n                    requestedPath, optimizedPath, optimizedLength,\n                    isJSONG);\n        }\n\n        if (!materialized) {\n            onMissing(model, path, depth,\n                      outerResults, requestedPath,\n                      optimizedPath, optimizedLength);\n        }\n        return;\n    }\n\n    // If there are expired value, then report it as missing\n    else if (isExpired(node) &&\n        !(node.$_version === currentCacheVersion.getVersion() &&\n            node.$expires === 0)) {\n        if (!node.$_invalidated) {\n            expireNode(node, model._root.expired, model._root);\n        }\n        onMissing(model, path, depth,\n                  outerResults, requestedPath,\n                  optimizedPath, optimizedLength);\n    }\n\n    // If there is an error, then report it as a value if\n    else if (currType === $error) {\n        if (fromReference) {\n            requestedPath[depth] = null;\n            depth += 1;\n        }\n        if (isJSONG || model._treatErrorsAsValues) {\n            onValue(model, node, seed, depth, outerResults, branchInfo,\n                    requestedPath, optimizedPath, optimizedLength,\n                    isJSONG);\n        } else {\n            onValue(model, undefined, seed, depth, outerResults, branchInfo,\n                    requestedPath, optimizedPath, optimizedLength,\n                    isJSONG);\n            onError(model, node, depth, requestedPath, outerResults);\n        }\n    }\n\n    // Report the value\n    else {\n        if (fromReference) {\n            requestedPath[depth] = null;\n            depth += 1;\n        }\n        onValue(model, node, seed, depth, outerResults, branchInfo,\n                requestedPath, optimizedPath, optimizedLength, isJSONG);\n    }\n};\n\n},{\"117\":117,\"24\":24,\"25\":25,\"26\":26,\"30\":30,\"31\":31,\"82\":82,\"83\":83}],28:[function(require,module,exports){\nvar pathSyntax = require(134);\nvar getValueSync = require(21);\n\nmodule.exports = function _getValueSync(pathArg) {\n    var path = pathSyntax.fromPath(pathArg);\n    if (Array.isArray(path) === false) {\n        throw new Error(\"Model#_getValueSync must be called with an Array path.\");\n    }\n    if (this._path.length) {\n        path = this._path.concat(path);\n    }\n    this._syncCheck(\"getValueSync\");\n    return getValueSync(this, path).value;\n};\n\n},{\"134\":134,\"21\":21}],29:[function(require,module,exports){\n// Copies the node\nvar privatePrefix = require(35);\n\nmodule.exports = function clone(node) {\n    if (node === undefined) {\n        return node;\n    }\n\n    var outValue, i, len;\n    var keys = Object.keys(node);\n    outValue = {};\n    for (i = 0, len = keys.length; i < len; i++) {\n        var k = keys[i];\n        var k0 = k.substr(0, 2);\n        if (k0 === privatePrefix) {\n            continue;\n        }\n        outValue[k] = node[k];\n    }\n    return outValue;\n};\n\n},{\"35\":35}],30:[function(require,module,exports){\nmodule.exports = require(92);\n\n},{\"92\":92}],31:[function(require,module,exports){\nmodule.exports = function isMaterialized(model) {\n    return model._materialized && !model._source;\n};\n\n},{}],32:[function(require,module,exports){\nfunction fastCopy(arr, iArg) {\n    var a = [], len, j, i;\n    for (j = 0, i = iArg || 0, len = arr.length; i < len; j++, i++) {\n        a[j] = arr[i];\n    }\n    return a;\n}\n\n\nfunction fastCat(arr1, arr2) {\n    var a = [], i, len, j;\n    for (i = 0, len = arr1.length; i < len; i++) {\n        a[i] = arr1[i];\n    }\n    for (j = 0, len = arr2.length; j < len; j++) {\n        a[i++] = arr2[j];\n    }\n    return a;\n}\n\n\n\nmodule.exports = {\n    fastCat: fastCat,\n    fastCopy: fastCopy\n};\n\n},{}],33:[function(require,module,exports){\nvar followReference = require(15);\nvar onValueType = require(27);\nvar onValue = require(26);\nvar isExpired = require(30);\nvar iterateKeySet = require(145).iterateKeySet;\nvar $ref = require(118);\nvar NullInPathError = require(13);\nvar promote = require(41);\n\nmodule.exports = function walkPath(model, root, curr, path, depth, seed,\n                                   outerResults, branchInfo, requestedPath,\n                                   optimizedPathArg, optimizedLength, isJSONG,\n                                   fromReferenceArg, referenceContainerArg) {\n\n    var fromReference = fromReferenceArg;\n    var optimizedPath = optimizedPathArg;\n    var referenceContainer = referenceContainerArg;\n\n    // If there is not a value in the current cache position or its a\n    // value type, then we are at the end of the getWalk.\n    if ((!curr || curr && curr.$type) || depth === path.length) {\n        onValueType(model, curr, path, depth, seed, outerResults, branchInfo,\n                requestedPath, optimizedPath, optimizedLength,\n                isJSONG, fromReference);\n        return;\n    }\n\n    var i;\n    var keySet = path[depth];\n    var isKeySet = typeof keySet === \"object\";\n    var nextDepth = depth + 1;\n    var iteratorNote = false;\n    var key = keySet;\n    var allowFromWhenceYouCame = model._allowFromWhenceYouCame;\n\n    if (isKeySet) {\n        iteratorNote = {};\n        key = iterateKeySet(keySet, iteratorNote);\n    }\n\n    // loop over every key over the keySet\n    var optimizedLengthPlus1 = optimizedLength + 1;\n    var refPath;\n    do {\n        fromReference = false;\n\n        var next;\n\n        // There are two cases when it comes to a null key.  In path vs at the\n        // end of a path.\n        if (key === null) {\n            // If the key is null and we are not at the end of a path, then\n            // throw an error.\n            if (depth < path.length) {\n                throw new NullInPathError();\n            }\n\n            // Else, we are at the end of a path, then just say next is current.\n            else {\n                next = curr;\n            }\n        }\n\n        // The standard case, do the depth search into the cache.\n        else {\n            next = curr[key];\n            optimizedPath[optimizedLength] = key;\n            requestedPath[depth] = key;\n        }\n\n        var nextOptimizedPath = optimizedPath;\n        var nextOptimizedLength = optimizedLengthPlus1;\n\n        // If there is the next position we need to consider references.\n        if (next) {\n            var nType = next.$type;\n            var value = nType && next.value || next;\n\n            // If next is a reference follow it.  If we are in JSONG mode,\n            // report that value into the seed without passing the requested\n            // path.  If a requested path is passed to onValueType then it\n            // will add that path to the JSONGraph envelope under `paths`\n            if (nextDepth < path.length && nType &&\n                nType === $ref && !isExpired(next)) {\n\n                // promote the node so that the references don't get cleaned up.\n                promote(model._root, next);\n\n                if (isJSONG) {\n                    onValue(model, next, seed, nextDepth, outerResults, null,\n                            null, optimizedPath, nextOptimizedLength, isJSONG);\n                }\n\n                var ref = followReference(model, root, root, next,\n                                          value, seed, isJSONG);\n                fromReference = true;\n                next = ref[0];\n                refPath = ref[1];\n                referenceContainer = ref[2];\n                nextOptimizedPath = [];\n                nextOptimizedLength = refPath.length;\n                for (i = 0; i < nextOptimizedLength; ++i) {\n                    nextOptimizedPath[i] = refPath[i];\n                }\n            }\n\n            // The next can be set to undefined by following a reference that\n            // does not exist.\n            if (next) {\n                var obj;\n\n                // There was a reference container.\n                if (referenceContainer && allowFromWhenceYouCame) {\n                    obj = {\n                        // eslint-disable-next-line camelcase\n                        $__path: next.$_absolutePath,\n                        // eslint-disable-next-line camelcase\n                        $__refPath: referenceContainer.value,\n                        // eslint-disable-next-line camelcase\n                        $__toReference: referenceContainer.$_absolutePath\n                    };\n                }\n\n                // There is no reference container meaning this request was\n                // neither from a model and/or the first n (depth) keys do not\n                // contain references.\n                else {\n                    obj = {\n                        // eslint-disable-next-line camelcase\n                        $__path: next.$_absolutePath\n                    };\n                }\n\n                branchInfo[depth] = obj;\n            }\n        }\n\n        // Recurse to the next level.\n        walkPath(model, root, next, path, nextDepth, seed, outerResults,\n                 branchInfo, requestedPath, nextOptimizedPath,\n                 nextOptimizedLength, isJSONG,\n                 fromReference, referenceContainer);\n\n        // If the iteratorNote is not done, get the next key.\n        if (iteratorNote && !iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n\n    } while (iteratorNote && !iteratorNote.done);\n};\n\n},{\"118\":118,\"13\":13,\"145\":145,\"15\":15,\"26\":26,\"27\":27,\"30\":30,\"41\":41}],34:[function(require,module,exports){\n\"use strict\";\n\nfunction falcor(opts) {\n    return new falcor.Model(opts);\n}\n\n/**\n * A filtering method for keys from a falcor json response.  The only gotcha\n * to this method is when the incoming json is undefined, then undefined will\n * be returned.\n *\n * @public\n * @param {Object} json - The json response from a falcor model.\n * @returns {Array} - the keys that are in the model response minus the deref\n * _private_ meta data.\n */\nfalcor.keys = function getJSONKeys(json) {\n    if (!json) {\n        return undefined;\n    }\n\n    return Object.\n        keys(json).\n        filter(function(key) {\n            return key !== \"$__path\";\n        });\n};\n\nmodule.exports = falcor;\n\nfalcor.Model = require(2);\n\n},{\"2\":2}],35:[function(require,module,exports){\nvar reservedPrefix = require(37);\n\nmodule.exports = reservedPrefix + \"_\";\n\n},{\"37\":37}],36:[function(require,module,exports){\nmodule.exports = require(35) + \"ref\";\n\n},{\"35\":35}],37:[function(require,module,exports){\nmodule.exports = \"$\";\n\n},{}],38:[function(require,module,exports){\nvar pathUtils = require(145);\nvar toTree = pathUtils.toTree;\nvar toPaths = pathUtils.toPaths;\n\nvar createHardlink = require(81);\nvar __prefix = require(37);\n\nvar $ref = require(118);\n\nvar getBoundValue = require(17);\n\nvar promote = require(41);\nvar getSize = require(85);\nvar hasOwn = require(88);\nvar isObject = require(97);\nvar isExpired = require(92);\nvar isFunction = require(93);\nvar isPrimitive = require(99);\nvar expireNode = require(83);\nvar incrementVersion = require(89);\nvar updateNodeAncestors = require(112);\nvar removeNodeAndDescendants = require(106);\n\n/**\n * Sets a list of PathMaps into a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.\n */\n\nmodule.exports = function invalidatePathMaps(model, pathMapEnvelopes) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var comparator = modelRoot._comparator;\n    var errorSelector = modelRoot._errorSelector;\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    var parent = node.$_parent || cache;\n    var initialVersion = cache.$_version;\n\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n\n        invalidatePathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    if (modelRoot.hasObservers()) {\n        var affectedPaths = pathMapEnvelopes.reduce(function(allPaths, envelope) {\n            return allPaths.concat(toPaths(envelope.json));\n        }, []);\n        var affectedPathMap = toTree(affectedPaths);\n        modelRoot.onObserve(affectedPaths, affectedPathMap);\n    }\n\n    var newVersion = cache.$_version;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n};\n\nfunction invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, errorSelector) {\n\n    if (isPrimitive(pathMap) || pathMap.$type) {\n        return;\n    }\n\n    for (var key in pathMap) {\n        if (key[0] !== __prefix && hasOwn(pathMap, key)) {\n            var child = pathMap[key];\n            var branch = isObject(child) && !child.$type;\n            var results = invalidateNode(\n                root, parent, node,\n                key, child, branch, false,\n                version, expired, lru, comparator, errorSelector\n            );\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    invalidatePathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        version, expired, lru, comparator, errorSelector\n                    );\n                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {\n                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n                }\n            }\n        }\n    }\n}\n\nfunction invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector) {\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    node = node.$_context;\n\n    if (node != null) {\n        parent = node.$_parent || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(\n                root, parent, node,\n                key, value, branch, true,\n                version, expired, lru, comparator, errorSelector\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        if (container.$_context !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, value, branch, reference,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node.$_key;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n},{\"106\":106,\"112\":112,\"118\":118,\"145\":145,\"17\":17,\"37\":37,\"41\":41,\"81\":81,\"83\":83,\"85\":85,\"88\":88,\"89\":89,\"92\":92,\"93\":93,\"97\":97,\"99\":99}],39:[function(require,module,exports){\nvar toTree = require(145).toTree;\n\nvar __ref = require(36);\nvar $ref = require(118);\n\nvar getBoundValue = require(17);\nvar promote = require(41);\nvar getSize = require(85);\nvar isExpired = require(92);\nvar isFunction = require(93);\nvar isPrimitive = require(99);\nvar expireNode = require(83);\nvar iterateKeySet = require(145).iterateKeySet;\nvar incrementVersion = require(89);\nvar updateNodeAncestors = require(112);\nvar removeNodeAndDescendants = require(106);\n\n/**\n * Invalidates a list of Paths in a JSON Graph.\n * @function\n * @param {Object} model - the Model for which to insert the PathValues.\n * @param {Array.<PathValue>} paths - the PathValues to set.\n */\n\nmodule.exports = function invalidatePathSets(model, paths) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    // eslint-disable-next-line camelcase\n    var parent = node.$_parent || cache;\n    // eslint-disable-next-line camelcase\n    var initialVersion = cache.$_version;\n\n    var pathIndex = -1;\n    var pathCount = paths.length;\n\n    while (++pathIndex < pathCount) {\n\n        var path = paths[pathIndex];\n\n        invalidatePathSet(\n            path, 0, cache, parent, node,\n            version, expired, lru\n        );\n    }\n\n    if (modelRoot.hasObservers()) {\n        modelRoot.onObserve(paths, toTree(paths));\n    }\n\n    // eslint-disable-next-line camelcase\n    var newVersion = cache.$_version;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n};\n\nfunction invalidatePathSet(\n    path, depth, root, parent, node,\n    version, expired, lru) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n\n    do {\n        var results = invalidateNode(\n            root, parent, node,\n            key, branch, false,\n            version, expired, lru\n        );\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                invalidatePathSet(\n                    path, depth + 1,\n                    root, nextParent, nextNode,\n                    version, expired, lru\n                );\n            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru, undefined)) {\n                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);\n            }\n        }\n        key = iterateKeySet(keySet, note);\n    } while (!note.done);\n}\n\nfunction invalidateReference(root, node, version, expired, lru) {\n\n    if (isExpired(node)) {\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    promote(lru, node);\n\n    var container = node;\n    var reference = node.value;\n    var parent = root;\n\n    // eslint-disable-next-line camelcase\n    node = node.$_context;\n\n    if (node != null) {\n        // eslint-disable-next-line camelcase\n        parent = node.$_parent || root;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = invalidateNode(\n                root, parent, node,\n                key, branch, true,\n                version, expired, lru\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        // eslint-disable-next-line camelcase\n        if (container.$_context !== node) {\n            // eslint-disable-next-line camelcase\n            var backRefs = node.$_refsLength || 0;\n            // eslint-disable-next-line camelcase\n            node.$_refsLength = backRefs + 1;\n            node[__ref + backRefs] = container;\n            // eslint-disable-next-line camelcase\n            container.$_context = node;\n            // eslint-disable-next-line camelcase\n            container.$_refIndex = backRefs;\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction invalidateNode(\n    root, parent, node,\n    key, branch, reference,\n    version, expired, lru) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = invalidateReference(root, node, version, expired, lru);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new Error(\"`null` is not allowed in branch key positions.\");\n        } else if (node) {\n            key = node.$_key;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    return [node, parent];\n}\n\n},{\"106\":106,\"112\":112,\"118\":118,\"145\":145,\"17\":17,\"36\":36,\"41\":41,\"83\":83,\"85\":85,\"89\":89,\"92\":92,\"93\":93,\"99\":99}],40:[function(require,module,exports){\nvar removeNode = require(105);\nvar updateNodeAncestors = require(112);\n\nmodule.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {\n\n    var total = totalArg;\n    var ratio = ratioArg;\n\n    if (typeof ratio !== \"number\") {\n        ratio = 0.75;\n    }\n\n    var shouldUpdate = typeof version === \"number\";\n    var targetSize = max * ratio;\n    var parent, node, size;\n\n    node = expired.pop();\n\n    while (node) {\n        size = node.$size || 0;\n        total -= size;\n        if (shouldUpdate === true) {\n            updateNodeAncestors(node, size, lru, version);\n            // eslint-disable-next-line camelcase\n        } else if (parent = node.$_parent) { // eslint-disable-line no-cond-assign\n            // eslint-disable-next-line camelcase\n            removeNode(node, parent, node.$_key, lru);\n        }\n        node = expired.pop();\n    }\n\n    if (total >= max) {\n        // eslint-disable-next-line camelcase\n        var prev = lru.$_tail;\n        node = prev;\n        while ((total >= targetSize) && node) {\n            // eslint-disable-next-line camelcase\n            prev = prev.$_prev;\n            size = node.$size || 0;\n            total -= size;\n            if (shouldUpdate === true) {\n                updateNodeAncestors(node, size, lru, version);\n            }\n            node = prev;\n        }\n\n        // eslint-disable-next-line camelcase\n        lru.$_tail = lru.$_prev = node;\n        if (node == null) {\n            // eslint-disable-next-line camelcase\n            lru.$_head = lru.$_next = undefined;\n        } else {\n            // eslint-disable-next-line camelcase\n            node.$_next = undefined;\n        }\n    }\n};\n\n},{\"105\":105,\"112\":112}],41:[function(require,module,exports){\nvar EXPIRES_NEVER = require(119);\n\n// [H] -> Next -> ... -> [T]\n// [T] -> Prev -> ... -> [H]\nmodule.exports = function lruPromote(root, object) {\n    // Never promote node.$expires === 1.  They cannot expire.\n    if (object.$expires === EXPIRES_NEVER) {\n        return;\n    }\n\n    // eslint-disable-next-line camelcase\n    var head = root.$_head;\n\n    // Nothing is in the cache.\n    if (!head) {\n        // eslint-disable-next-line camelcase\n        root.$_head = root.$_tail = object;\n        return;\n    }\n\n    if (head === object) {\n        return;\n    }\n\n    // The item always exist in the cache since to get anything in the\n    // cache it first must go through set.\n    // eslint-disable-next-line camelcase\n    var prev = object.$_prev;\n    // eslint-disable-next-line camelcase\n    var next = object.$_next;\n    if (next) {\n        // eslint-disable-next-line camelcase\n        next.$_prev = prev;\n    }\n    if (prev) {\n        // eslint-disable-next-line camelcase\n        prev.$_next = next;\n    }\n    // eslint-disable-next-line camelcase\n    object.$_prev = undefined;\n\n    // Insert into head position\n    // eslint-disable-next-line camelcase\n    root.$_head = object;\n    // eslint-disable-next-line camelcase\n    object.$_next = head;\n    // eslint-disable-next-line camelcase\n    head.$_prev = object;\n\n    // If the item we promoted was the tail, then set prev to tail.\n    // eslint-disable-next-line camelcase\n    if (object === root.$_tail) {\n        // eslint-disable-next-line camelcase\n        root.$_tail = prev;\n    }\n};\n\n},{\"119\":119}],42:[function(require,module,exports){\nmodule.exports = function lruSplice(root, object) {\n\n    // Its in the cache.  Splice out.\n    // eslint-disable-next-line camelcase\n    var prev = object.$_prev;\n    // eslint-disable-next-line camelcase\n    var next = object.$_next;\n    if (next) {\n        // eslint-disable-next-line camelcase\n        next.$_prev = prev;\n    }\n    if (prev) {\n        // eslint-disable-next-line camelcase\n        prev.$_next = next;\n    }\n    // eslint-disable-next-line camelcase\n    object.$_prev = object.$_next = undefined;\n\n    // eslint-disable-next-line camelcase\n    if (object === root.$_head) {\n        // eslint-disable-next-line camelcase\n        root.$_head = next;\n    }\n    // eslint-disable-next-line camelcase\n    if (object === root.$_tail) {\n        // eslint-disable-next-line camelcase\n        root.$_tail = prev;\n    }\n};\n\n},{}],43:[function(require,module,exports){\nvar complement = require(46);\nvar flushGetRequest = require(47);\nvar incrementVersion = require(89);\nvar currentCacheVersion = require(82);\n\nvar REQUEST_ID = 0;\nvar GetRequestType = require(45).GetRequest;\nvar setJSONGraphs = require(70);\nvar setPathValues = require(72);\nvar $error = require(117);\nvar emptyArray = [];\nvar InvalidSourceError = require(11);\n\n/**\n * Creates a new GetRequest.  This GetRequest takes a scheduler and\n * the request queue.  Once the scheduler fires, all batched requests\n * will be sent to the server.  Upon request completion, the data is\n * merged back into the cache and all callbacks are notified.\n *\n * @param {Scheduler} scheduler -\n * @param {RequestQueueV2} requestQueue -\n */\nvar GetRequestV2 = function(scheduler, requestQueue) {\n    this.sent = false;\n    this.scheduled = false;\n    this.requestQueue = requestQueue;\n    this.id = ++REQUEST_ID;\n    this.type = GetRequestType;\n\n    this._scheduler = scheduler;\n    this._pathMap = {};\n    this._optimizedPaths = [];\n    this._requestedPaths = [];\n    this._callbacks = [];\n    this._count = 0;\n    this._disposable = null;\n    this._collapsed = null;\n    this._disposed = false;\n};\n\nGetRequestV2.prototype = {\n    /**\n     * batches the paths that are passed in.  Once the request is complete,\n     * all callbacks will be called and the request will be removed from\n     * parent queue.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} callback -\n     */\n    batch: function(requestedPaths, optimizedPaths, callback) {\n        var self = this;\n        var oPaths = self._optimizedPaths;\n        var rPaths = self._requestedPaths;\n        var callbacks = self._callbacks;\n        var idx = oPaths.length;\n\n        // If its not sent, simply add it to the requested paths\n        // and callbacks.\n        oPaths[idx] = optimizedPaths;\n        rPaths[idx] = requestedPaths;\n        callbacks[idx] = callback;\n        ++self._count;\n\n        // If it has not been scheduled, then schedule the action\n        if (!self.scheduled) {\n            self.scheduled = true;\n\n            var flushedDisposable;\n            var scheduleDisposable = self._scheduler.schedule(function() {\n                flushedDisposable = flushGetRequest(self, oPaths, function(err, data) {\n                    var i, fn, len;\n                    var model = self.requestQueue.model;\n                    self.requestQueue.removeRequest(self);\n                    self._disposed = true;\n\n                    if (model._treatDataSourceErrorsAsJSONGraphErrors ? err instanceof InvalidSourceError : !!err) {\n                        for (i = 0, len = callbacks.length; i < len; ++i) {\n                            fn = callbacks[i];\n                            if (fn) {\n                                fn(err);\n                            }\n                        }\n                        return;\n                    }\n\n                    // If there is at least one callback remaining, then\n                    // callback the callbacks.\n                    if (self._count) {\n                        // currentVersion will get added to each inserted\n                        // node as node.$_version inside of self._merge.\n                        //\n                        // atom values just downloaded with $expires: 0\n                        // (now-expired) will get assigned $_version equal\n                        // to currentVersion, and checkCacheAndReport will\n                        // later consider those nodes to not have expired\n                        // for the duration of current event loop tick\n                        //\n                        // we unset currentCacheVersion after all callbacks\n                        // have been called, to ensure that only these\n                        // particular callbacks and any synchronous model.get\n                        // callbacks inside of these, get the now-expired\n                        // values\n                        var currentVersion = incrementVersion.getCurrentVersion();\n                        currentCacheVersion.setVersion(currentVersion);\n                        var mergeContext = {hasInvalidatedResult : false};\n\n                        var pathsErr = model._useServerPaths && data && data.paths === undefined ?\n                            new Error(\"Server responses must include a 'paths' field when Model._useServerPaths === true\") : undefined;\n\n                        if (!pathsErr) {\n                            self._merge(rPaths, err, data, mergeContext);\n                        }\n\n                        // Call the callbacks.  The first one inserts all\n                        // the data so that the rest do not have consider\n                        // if their data is present or not.\n                        for (i = 0, len = callbacks.length; i < len; ++i) {\n                            fn = callbacks[i];\n                            if (fn) {\n                                fn(pathsErr || err, data, mergeContext.hasInvalidatedResult);\n                            }\n                        }\n                        currentCacheVersion.setVersion(null);\n                    }\n                });\n                self._disposable = flushedDisposable;\n            });\n\n            // If the scheduler is sync then `flushedDisposable` will be\n            // defined, and we want to use it, because that's what aborts an\n            // in-flight XHR request, for example.\n            // But if the scheduler is async, then `flushedDisposable` won't be\n            // defined yet, and so we must use the scheduler's disposable until\n            // `flushedDisposable` is defined. Since we want to still use\n            // `flushedDisposable` once it is defined (to be able to abort in-\n            // flight XHR requests), hence the reassignment of `_disposable`\n            // above.\n            self._disposable = flushedDisposable || scheduleDisposable;\n        }\n\n        // Disposes this batched request.  This does not mean that the\n        // entire request has been disposed, but just the local one, if all\n        // requests are disposed, then the outer disposable will be removed.\n        return createDisposable(self, idx);\n    },\n\n    /**\n     * Attempts to add paths to the outgoing request.  If there are added\n     * paths then the request callback will be added to the callback list.\n     * Handles adding partial paths as well\n     *\n     * @returns {Array} - whether new requested paths were inserted in this\n     *                    request, the remaining paths that could not be added,\n     *                    and disposable for the inserted requested paths.\n     */\n    add: function(requested, optimized, depthDifferences, callback) {\n        // uses the length tree complement calculator.\n        var self = this;\n        var complementTuple = complement(requested, optimized, depthDifferences, self._pathMap);\n        var optimizedComplement;\n        var requestedComplement;\n\n        if (complementTuple) {\n            requestedComplement = complementTuple[2];\n            optimizedComplement = complementTuple[1];\n        } else {\n            requestedComplement = requested;\n            optimizedComplement = optimized;\n        }\n\n        var inserted = false;\n        var disposable = false;\n\n        // If we found an intersection, then just add new callback\n        // as one of the dependents of that request\n        if (complementTuple && complementTuple[0].length) {\n            inserted = true;\n            var idx = self._callbacks.length;\n            self._callbacks[idx] = callback;\n            self._requestedPaths[idx] = complementTuple[0];\n            self._optimizedPaths[idx] = [];\n            ++self._count;\n\n            disposable = createDisposable(self, idx);\n        }\n\n        return [inserted, requestedComplement, optimizedComplement, disposable];\n    },\n\n    /**\n     * merges the response into the model\"s cache.\n     */\n    _merge: function(requested, err, data, mergeContext) {\n        var self = this;\n        var model = self.requestQueue.model;\n        var modelRoot = model._root;\n        var errorSelector = modelRoot.errorSelector;\n        var comparator = modelRoot.comparator;\n        var boundPath = model._path;\n\n        model._path = emptyArray;\n\n        // flatten all the requested paths, adds them to the\n        var nextPaths = model._useServerPaths ? data.paths : flattenRequestedPaths(requested);\n\n        // Insert errors in every requested position.\n        if (err && model._treatDataSourceErrorsAsJSONGraphErrors) {\n            var error = err;\n\n            // Converts errors to objects, a more friendly storage\n            // of errors.\n            if (error instanceof Error) {\n                error = {\n                    message: error.message\n                };\n            }\n\n            // Not all errors are value $types.\n            if (!error.$type) {\n                error = {\n                    $type: $error,\n                    value: error\n                };\n            }\n\n            var pathValues = nextPaths.map(function(x) {\n                return {\n                    path: x,\n                    value: error\n                };\n            });\n            setPathValues(model, pathValues, null, errorSelector, comparator, mergeContext);\n        }\n\n        // Insert the jsonGraph from the dataSource.\n        else {\n            setJSONGraphs(model, [{\n                paths: nextPaths,\n                jsonGraph: data.jsonGraph\n            }], null, errorSelector, comparator, mergeContext);\n        }\n\n        // return the model\"s boundPath\n        model._path = boundPath;\n    }\n};\n\n// Creates a more efficient closure of the things that are\n// needed.  So the request and the idx.  Also prevents code\n// duplication.\nfunction createDisposable(request, idx) {\n    var disposed = false;\n    return function() {\n        if (disposed || request._disposed) {\n            return;\n        }\n\n        disposed = true;\n        request._callbacks[idx] = null;\n        request._optimizedPaths[idx] = [];\n        request._requestedPaths[idx] = [];\n\n        // If there are no more requests, then dispose all of the request.\n        var count = --request._count;\n        var disposable = request._disposable;\n        if (count === 0) {\n            // looking for unsubscribe here to support more data sources (Rx)\n            if (disposable.unsubscribe) {\n                disposable.unsubscribe();\n            } else {\n                disposable.dispose();\n            }\n            request.requestQueue.removeRequest(request);\n        }\n    };\n}\n\nfunction flattenRequestedPaths(requested) {\n    var out = [];\n    var outLen = -1;\n    for (var i = 0, len = requested.length; i < len; ++i) {\n        var paths = requested[i];\n        for (var j = 0, innerLen = paths.length; j < innerLen; ++j) {\n            out[++outLen] = paths[j];\n        }\n    }\n    return out;\n}\n\nmodule.exports = GetRequestV2;\n\n},{\"11\":11,\"117\":117,\"45\":45,\"46\":46,\"47\":47,\"70\":70,\"72\":72,\"82\":82,\"89\":89}],44:[function(require,module,exports){\nvar RequestTypes = require(45);\nvar sendSetRequest = require(48);\nvar GetRequest = require(43);\nvar falcorPathUtils = require(145);\n\n/**\n * The request queue is responsible for queuing the operations to\n * the model\"s dataSource.\n *\n * @param {Model} model -\n * @param {Scheduler} scheduler -\n */\nfunction RequestQueueV2(model, scheduler) {\n    this.model = model;\n    this.scheduler = scheduler;\n    this.requests = this._requests = [];\n}\n\nRequestQueueV2.prototype = {\n    /**\n     * Sets the scheduler, but will not affect any current requests.\n     */\n    setScheduler: function(scheduler) {\n        this.scheduler = scheduler;\n    },\n\n    /**\n     * performs a set against the dataSource.  Sets, though are not batched\n     * currently could be batched potentially in the future.  Since no batching\n     * is required the setRequest action is simplified significantly.\n     *\n     * @param {JSONGraphEnvelope) jsonGraph -\n     */\n    set: function(jsonGraph, cb) {\n        jsonGraph.paths = falcorPathUtils.collapse(jsonGraph.paths);\n        return sendSetRequest(jsonGraph, this.model, cb);\n    },\n\n    /**\n     * Creates a get request to the dataSource.  Depending on the current\n     * scheduler is how the getRequest will be flushed.\n     * @param {Array} requestedPaths -\n     * @param {Array} optimizedPaths -\n     * @param {Function} cb -\n     */\n    get: function(requestedPaths, optimizedPaths, depthDifferences, cb) {\n        var self = this;\n        var disposables = [];\n        var count = 0;\n        var requests = self._requests;\n        var i, len;\n        var oRemainingPaths = optimizedPaths;\n        var rRemainingPaths = requestedPaths;\n        var disposed = false;\n        var request;\n\n        for (i = 0, len = requests.length; i < len; ++i) {\n            request = requests[i];\n            if (request.type !== RequestTypes.GetRequest) {\n                continue;\n            }\n\n            // The request has been sent, attempt to jump on the request\n            // if possible.\n            if (request.sent) {\n                var results = request.add(\n                    rRemainingPaths, oRemainingPaths, depthDifferences, refCountCallback);\n\n                // Checks to see if the results were successfully inserted\n                // into the outgoing results.  Then our paths will be reduced\n                // to the complement.\n                if (results[0]) {\n                    rRemainingPaths = results[1];\n                    oRemainingPaths = results[2];\n                    disposables[disposables.length] = results[3];\n                    ++count;\n                }\n            }\n\n            // If there is a non sent request, then we can batch and leave.\n            else {\n                request.batch(\n                    rRemainingPaths, oRemainingPaths, refCountCallback);\n                oRemainingPaths = [];\n                rRemainingPaths = [];\n                ++count;\n            }\n\n            // If there are no more remaining paths then exit the loop.\n            if (!oRemainingPaths.length) {\n                break;\n            }\n        }\n\n        // After going through all the available requests if there are more\n        // paths to process then a new request must be made.\n        if (oRemainingPaths.length) {\n            request = new GetRequest(self.scheduler, self);\n            requests[requests.length] = request;\n            ++count;\n            var disposable = request.batch(\n                rRemainingPaths, oRemainingPaths, refCountCallback);\n            disposables[disposables.length] = disposable;\n        }\n\n        // This is a simple refCount callback.\n        function refCountCallback(err, data, hasInvalidatedResult) {\n            if (disposed) {\n                return;\n            }\n\n            --count;\n\n            // If the count becomes 0, then its time to notify the\n            // listener that the request is done.\n            if (count === 0) {\n                cb(err, data, hasInvalidatedResult);\n            }\n        }\n\n        // When disposing the request all of the outbound requests will be\n        // disposed of.\n        return function() {\n            if (disposed || count === 0) {\n                return;\n            }\n\n            disposed = true;\n            var length = disposables.length;\n            for (var idx = 0; idx < length; ++idx) {\n                disposables[idx]();\n            }\n        };\n    },\n\n    /**\n     * Removes the request from the request\n     */\n    removeRequest: function(request) {\n        var requests = this._requests;\n        var i = requests.length;\n        while (--i >= 0) {\n            if (requests[i].id === request.id) {\n                requests.splice(i, 1);\n                break;\n            }\n        }\n    }\n};\n\nmodule.exports = RequestQueueV2;\n\n},{\"145\":145,\"43\":43,\"45\":45,\"48\":48}],45:[function(require,module,exports){\nmodule.exports = {\n    GetRequest: \"GET\"\n};\n\n},{}],46:[function(require,module,exports){\nvar hasIntersection = require(145).hasIntersection;\nvar arraySlice = require(79);\nvar arrayConcat = require(76);\nvar iterateKeySet = require(145).iterateKeySet;\n\n/**\n * Figures out what paths in requested pathsets can be\n * deduped based on existing optimized path tree provided.\n *\n * ## no deduping possible:\n *\n * if no existing requested sub tree at all for path,\n * just add the entire path to complement.\n *\n * ## fully deduped:\n *\n * if required path is a complete subset of given sub tree,\n * just add the entire path to intersection\n *\n * ## partial deduping:\n *\n * if some part of path, when ranges are expanded, is a subset\n * of given sub tree, then add only that part to intersection,\n * and all other parts of this path to complement\n *\n * To keep `depth` argument be a valid index for optimized path (`oPath`),\n * either requested or optimized path is sent in pre-initialized with\n * some items so that their remaining length matches exactly, keeping\n * remaining ranges in those pathsets 1:1 in correspondence\n *\n * Note that positive `depthDiff` value means that requested path is\n * longer than optimized path, and we need to pre-initialize current\n * requested path with that many offset items, so that their remaining\n * length matches. Similarly, negative `depthDiff` value means that\n * optimized path is longer, and we pre-initialize optimized path with\n * those many items. Note that because of the way requested and\n * optimized paths are accumulated from what user requested in model.get\n * (see onMissing.js), it is not possible for the pre-initialized paths\n * to have any ranges in them.\n *\n * `intersectionData` is:\n * [ requestedIntersection, optimizedComplement, requestedComplement ]\n * where `requestedIntersection` is matched requested paths that can be\n * deduped, `optimizedComplement` is missing optimized paths, and\n * `requestedComplement` is requested counterparts of those missing\n * optimized paths\n */\nmodule.exports = function complement(requested, optimized, depthDifferences, tree) {\n    var optimizedComplement = [];\n    var requestedComplement = [];\n    var requestedIntersection = [];\n    var intersectionLength = -1, complementLength = -1;\n\n    for (var i = 0, len = optimized.length; i < len; ++i) {\n        var oPath = optimized[i];\n        var rPath = requested[i];\n        var depthDiff = depthDifferences[i];\n        var subTree = tree[oPath.length];\n\n        // no deduping possible\n        if (!subTree) {\n            optimizedComplement[++complementLength] = oPath;\n            requestedComplement[complementLength] = rPath;\n            continue;\n        }\n        // fully deduped\n        if (hasIntersection(subTree, oPath, 0)) {\n            requestedIntersection[++intersectionLength] = rPath;\n            continue;\n        }\n\n        // partial deduping\n        var intersectionData = findPartialIntersections(\n            rPath,\n            oPath,\n            subTree,\n            depthDiff < 0 ? -depthDiff : 0,\n            depthDiff > 0 ? arraySlice(rPath, 0, depthDiff) : [],\n            depthDiff < 0 ? arraySlice(oPath, 0, -depthDiff) : [],\n            depthDiff);\n        for (var j = 0, jLen = intersectionData[0].length; j < jLen; ++j) {\n            requestedIntersection[++intersectionLength] = intersectionData[0][j];\n        }\n        for (var k = 0, kLen = intersectionData[1].length; k < kLen; ++k) {\n            optimizedComplement[++complementLength] = intersectionData[1][k];\n            requestedComplement[complementLength] = intersectionData[2][k];\n        }\n    }\n\n    if (!requestedIntersection.length) {\n        return null;\n    }\n    return [requestedIntersection, optimizedComplement, requestedComplement];\n};\n\n/**\n * Recursive function to calculate intersection and complement paths in 2 given\n * pathsets at a given depth\n * Parameters:\n *  - `requestedPath`: full requested path (can include ranges)\n *  - `optimizedPath`: corresponding optimized path (can include ranges)\n *  - `currentTree`: path map for in-flight request, against which to dedupe\n *  - `depth`: index of optimized path that we are trying to match with `currentTree`\n *  - `rCurrentPath`: current accumulated requested path by previous recursive\n *                    iterations. Could also have been pre-initialized as stated\n *                    above.\n *                    This path cannot contain ranges, instead contains a key\n *                    from the range, representing one of the individual paths\n *                    in `requestedPath` pathset\n *  - `oCurrentPath`: corresponding accumulated optimized path, to be matched\n *                    with `currentTree`. Could have been pre-initialized.\n *                    Cannot contain ranges, instead contains a key from the\n *                    range at given `depth` in `optimizedPath`\n *  - `depthDiff`: difference in length between `requestedPath` and `optimizedPath`\n *\n *  Example scenario:\n *      - requestedPath: ['lolomo', 0, 0, 'tags', { from: 0, to: 2 }]\n *      - optimizedPath: ['videosById', 11, 'tags', { from: 0, to: 2 }]\n *      - currentTree: { videosById: 11: { tags: { 0: null, 1: null }}}\n *      // since requested path is longer, optimized path index starts from depth 0\n *      // and accumulated requested path starts pre-initialized (rCurrentPath)\n *      - depth: 0\n *      - rCurrentPath: ['lolomo']\n *      - oCurrentPath: []\n *      - depthDiff: 1\n */\nfunction findPartialIntersections(requestedPath, optimizedPath, currentTree, depth, rCurrentPath, oCurrentPath, depthDiff) {\n    var intersections = [];\n    var rComplementPaths = [];\n    var oComplementPaths = [];\n    // iterate over optimized path, looking for deduping opportunities\n    for (; depth < optimizedPath.length; ++depth) {\n        var key = optimizedPath[depth];\n        var keyType = typeof key;\n\n        // if range key is found, start inner loop to iterate over all keys in range\n        // and add intersections and complements from each iteration separately.\n        // range keys branch-out like this, providing individual deduping\n        // opportunities for each inner key\n        if (key && keyType === \"object\") {\n            var note = {};\n            var innerKey = iterateKeySet(key, note);\n\n            while (!note.done) {\n                var nextTree = currentTree[innerKey];\n                if (nextTree === undefined) {\n                    // if no next sub tree exists for an inner key, it's a dead-end\n                    // and we can add this to complement paths\n                    var oPath = oCurrentPath.concat(\n                        innerKey,\n                        arraySlice(\n                            optimizedPath,\n                            depth + 1));\n                    oComplementPaths[oComplementPaths.length] = oPath;\n                    var rPath = rCurrentPath.concat(\n                        innerKey,\n                        arraySlice(\n                            requestedPath,\n                            depth + 1 + depthDiff));\n                    rComplementPaths[rComplementPaths.length] = rPath;\n                } else if (depth === optimizedPath.length - 1) {\n                    // reaching the end of optimized path means that we found a\n                    // corresponding node in the path map tree every time,\n                    // so add current path to successful intersections\n                    intersections[intersections.length] = arrayConcat(rCurrentPath, [innerKey]);\n                } else {\n                    // otherwise keep trying to find further partial deduping\n                    // opportunities in the remaining path!\n                    var intersectionData = findPartialIntersections(\n                        requestedPath,\n                        optimizedPath,\n                        nextTree,\n                        depth + 1,\n                        arrayConcat(rCurrentPath, [innerKey]),\n                        arrayConcat(oCurrentPath, [innerKey]),\n                        depthDiff);\n                    for (var j = 0, jLen = intersectionData[0].length; j < jLen; ++j) {\n                        intersections[intersections.length] = intersectionData[0][j];\n                    }\n                    for (var k = 0, kLen = intersectionData[1].length; k < kLen; ++k) {\n                        oComplementPaths[oComplementPaths.length] = intersectionData[1][k];\n                        rComplementPaths[rComplementPaths.length] = intersectionData[2][k];\n                    }\n                }\n                innerKey = iterateKeySet(key, note);\n            }\n            break;\n        }\n\n        // for simple keys, we don't need to branch out. looping over `depth`\n        // here instead of recursion, for performance\n        currentTree = currentTree[key];\n        oCurrentPath[oCurrentPath.length] = optimizedPath[depth];\n        rCurrentPath[rCurrentPath.length] = requestedPath[depth + depthDiff];\n\n        if (currentTree === undefined) {\n            // if dead-end, add this to complements\n            oComplementPaths[oComplementPaths.length] =\n                arrayConcat(oCurrentPath, arraySlice(optimizedPath, depth + 1));\n            rComplementPaths[rComplementPaths.length] =\n                arrayConcat(rCurrentPath, arraySlice(requestedPath, depth + depthDiff + 1));\n            break;\n        } else if (depth === optimizedPath.length - 1) {\n            // if reach end of optimized path successfully, add to intersections\n            intersections[intersections.length] = rCurrentPath;\n        }\n        // otherwise keep going\n    }\n\n    // return accumulated intersection and complement pathsets\n    return [intersections, oComplementPaths, rComplementPaths];\n}\n\n\n},{\"145\":145,\"76\":76,\"79\":79}],47:[function(require,module,exports){\nvar pathUtils = require(145);\nvar toTree = pathUtils.toTree;\nvar toPaths = pathUtils.toPaths;\nvar InvalidSourceError = require(11);\n\n/**\n * Flushes the current set of requests.  This will send the paths to the\n * dataSource.  * The results of the dataSource will be sent to callback which\n * should perform the zip of all callbacks.\n * @param {GetRequest} request -\n * @param {Array} listOfPaths -\n * @param {Function} callback -\n * @private\n */\nmodule.exports = function flushGetRequest(request, listOfPaths, callback) {\n    if (request._count === 0) {\n        request.requestQueue.removeRequest(request);\n        return null;\n    }\n\n    request.sent = true;\n    request.scheduled = false;\n\n    // TODO: Move this to the collapse algorithm,\n    // TODO: we should have a collapse that returns the paths and\n    // TODO: the trees.\n\n    // Take all the paths and add them to the pathMap by length.\n    // Since its a list of paths\n    var pathMap = request._pathMap;\n    var listKeys = Object.keys(listOfPaths);\n    var listIdx = 0, listLen = listKeys.length;\n    for (; listIdx < listLen; ++listIdx) {\n        var paths = listOfPaths[listIdx];\n        for (var j = 0, pathLen = paths.length; j < pathLen; ++j) {\n            var pathSet = paths[j];\n            var len = pathSet.length;\n\n            if (!pathMap[len]) {\n                pathMap[len] = [pathSet];\n            } else {\n                var pathSetsByLength = pathMap[len];\n                pathSetsByLength[pathSetsByLength.length] = pathSet;\n            }\n        }\n    }\n\n    // now that we have them all by length, convert each to a tree.\n    var pathMapKeys = Object.keys(pathMap);\n    var pathMapIdx = 0, pathMapLen = pathMapKeys.length;\n    for (; pathMapIdx < pathMapLen; ++pathMapIdx) {\n        var pathMapKey = pathMapKeys[pathMapIdx];\n        pathMap[pathMapKey] = toTree(pathMap[pathMapKey]);\n    }\n\n    // Take the pathMapTree and create the collapsed paths and send those\n    // off to the server.\n    var collapsedPaths = request._collasped = toPaths(pathMap);\n    var jsonGraphData;\n\n    // Make the request.\n    // You are probably wondering why this is not cancellable.  If a request\n    // goes out, and all the requests are removed, the request should not be\n    // cancelled.  The reasoning is that another request could come in, after\n    // all callbacks have been removed and be deduped.  Might as well keep this\n    // around until it comes back.  If at that point there are no requests then\n    // we cancel at the callback above.\n    var getRequest;\n    try {\n        getRequest = request.\n            requestQueue.\n            model._source.\n            get(collapsedPaths);\n    } catch (e) {\n        callback(new InvalidSourceError());\n        return null;\n    }\n\n    // Ensures that the disposable is available for the outside to cancel.\n    var disposable = getRequest.\n        subscribe(function(data) {\n            jsonGraphData = data;\n        }, function(err) {\n            callback(err, jsonGraphData);\n        }, function() {\n            callback(null, jsonGraphData);\n        });\n\n    return disposable;\n};\n\n\n},{\"11\":11,\"145\":145}],48:[function(require,module,exports){\nvar arrayMap = require(78);\nvar setJSONGraphs = require(70);\nvar setPathValues = require(72);\nvar InvalidSourceError = require(11);\n\nvar emptyArray = [];\nvar emptyDisposable = {dispose: function() {}};\n\n/**\n * A set request is not an object like GetRequest.  It simply only needs to\n * close over a couple values and its never batched together (at least not now).\n *\n * @private\n * @param {JSONGraphEnvelope} jsonGraph -\n * @param {Model} model -\n * @param {Function} callback -\n */\nvar sendSetRequest = function(originalJsonGraph, model, callback) {\n    var paths = originalJsonGraph.paths;\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var comparator = modelRoot.comparator;\n    var boundPath = model._path;\n    var resultingJsonGraphEnvelope;\n\n    // This is analogous to GetRequest _merge / flushGetRequest\n    // SetRequests are just considerably simplier.\n    var setObservable;\n    try {\n        setObservable = model._source.\n            set(originalJsonGraph);\n    } catch (e) {\n        callback(new InvalidSourceError());\n        return emptyDisposable;\n    }\n\n    var disposable = setObservable.\n        subscribe(function onNext(jsonGraphEnvelope) {\n            // When disposed, no data is inserted into.  This can sync resolve\n            // and if thats the case then its undefined.\n            if (disposable && disposable.disposed) {\n                return;\n            }\n\n            // onNext will insert all data into the model then save the json\n            // envelope from the incoming result.\n            model._path = emptyArray;\n\n            var successfulPaths = setJSONGraphs(model, [{\n                paths: paths,\n                jsonGraph: jsonGraphEnvelope.jsonGraph\n            }], null, errorSelector, comparator);\n\n            jsonGraphEnvelope.paths = successfulPaths[1];\n\n            model._path = boundPath;\n            resultingJsonGraphEnvelope = jsonGraphEnvelope;\n        }, function onError(dataSourceError) {\n            if (disposable && disposable.disposed) {\n                return;\n            }\n            model._path = emptyArray;\n\n            setPathValues(model, arrayMap(paths, function(path) {\n                return {\n                    path: path,\n                    value: dataSourceError\n                };\n            }), null, errorSelector, comparator);\n\n            model._path = boundPath;\n\n            callback(dataSourceError);\n        }, function onCompleted() {\n            callback(null, resultingJsonGraphEnvelope);\n        });\n\n    return disposable;\n};\n\nmodule.exports = sendSetRequest;\n\n},{\"11\":11,\"70\":70,\"72\":72,\"78\":78}],49:[function(require,module,exports){\n/**\n * Will allow for state tracking of the current disposable.  Also fulfills the\n * disposable interface.\n * @private\n */\nvar AssignableDisposable = function AssignableDisposable(disosableCallback) {\n    this.disposed = false;\n    this.currentDisposable = disosableCallback;\n};\n\n\nAssignableDisposable.prototype = {\n\n    /**\n     * Disposes of the current disposable.  This would be the getRequestCycle\n     * disposable.\n     */\n    dispose: function dispose() {\n        if (this.disposed || !this.currentDisposable) {\n            return;\n        }\n        this.disposed = true;\n\n        // If the current disposable fulfills the disposable interface or just\n        // a disposable function.\n        var currentDisposable = this.currentDisposable;\n        if (currentDisposable.dispose) {\n            currentDisposable.dispose();\n        }\n\n        else {\n            currentDisposable();\n        }\n    }\n};\n\n\nmodule.exports = AssignableDisposable;\n\n},{}],50:[function(require,module,exports){\nvar ModelResponse = require(52);\nvar InvalidSourceError = require(11);\n\nvar pathSyntax = require(134);\n\n/**\n * @private\n * @augments ModelResponse\n */\nfunction CallResponse(model, callPath, args, suffix, paths) {\n    this.callPath = pathSyntax.fromPath(callPath);\n    this.args = args;\n\n    if (paths) {\n        this.paths = paths.map(pathSyntax.fromPath);\n    }\n    if (suffix) {\n        this.suffix = suffix.map(pathSyntax.fromPath);\n    }\n    this.model = model;\n}\n\nCallResponse.prototype = Object.create(ModelResponse.prototype);\nCallResponse.prototype._subscribe = function _subscribe(observer) {\n    var callPath = this.callPath;\n    var callArgs = this.args;\n    var suffixes = this.suffix;\n    var extraPaths = this.paths;\n    var model = this.model;\n    var rootModel = model._clone({\n        _path: []\n    });\n    var boundPath = model._path;\n    var boundCallPath = boundPath.concat(callPath);\n\n    /* eslint-disable consistent-return */\n    // Precisely the same error as the router when a call function does not\n    // exist.\n    if (!model._source) {\n        observer.onError(new Error(\"function does not exist\"));\n        return;\n    }\n\n\n    var response, obs;\n    try {\n        obs = model._source.\n            call(boundCallPath, callArgs, suffixes, extraPaths);\n    } catch (e) {\n        observer.onError(new InvalidSourceError(e));\n        return;\n    }\n\n    return obs.\n        subscribe(function(res) {\n            response = res;\n        }, function(err) {\n            observer.onError(err);\n        }, function() {\n\n            // Run the invalidations first then the follow up JSONGraph set.\n            var invalidations = response.invalidated;\n            if (invalidations && invalidations.length) {\n                rootModel.invalidate.apply(rootModel, invalidations);\n            }\n\n            // The set\n            rootModel.\n                withoutDataSource().\n                set(response).subscribe(function(x) {\n                    observer.onNext(x);\n                }, function(err) {\n                    observer.onError(err);\n                }, function() {\n                    observer.onCompleted();\n                });\n        });\n    /* eslint-enable consistent-return */\n};\n\nmodule.exports = CallResponse;\n\n},{\"11\":11,\"134\":134,\"52\":52}],51:[function(require,module,exports){\nvar isArray = Array.isArray;\nvar ModelResponse = require(52);\nvar isPathValue = require(98);\nvar isJSONEnvelope = require(95);\nvar empty = {dispose: function() {}};\n\nfunction InvalidateResponse(model, args) {\n    // TODO: This should be removed.  There should only be 1 type of arguments\n    // coming in, but we have strayed from documentation.\n    this._model = model;\n\n    var groups = [];\n    var group, groupType;\n    var argIndex = -1;\n    var argCount = args.length;\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray(arg)) {\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            argType = \"PathValues\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        } else {\n            throw new Error(\"Invalid Input\");\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this._groups = groups;\n}\n\nInvalidateResponse.prototype = Object.create(ModelResponse.prototype);\nInvalidateResponse.prototype.progressively = function progressively() {\n    return this;\n};\nInvalidateResponse.prototype._toJSONG = function _toJSONG() {\n    return this;\n};\n\nInvalidateResponse.prototype._subscribe = function _subscribe(observer) {\n\n    var model = this._model;\n    this._groups.forEach(function(group) {\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n        var operationName = \"_invalidate\" + inputType;\n        var operationFunc = model[operationName];\n        operationFunc(model, methodArgs);\n    });\n    observer.onCompleted();\n\n    return empty;\n};\n\nmodule.exports = InvalidateResponse;\n\n},{\"52\":52,\"95\":95,\"98\":98}],52:[function(require,module,exports){\n(function (Promise){\nvar ModelResponseObserver = require(53);\nvar $$observable = require(164).default;\nvar toEsObservable = require(115);\n\n/**\n * A ModelResponse is a container for the results of a get, set, or call operation performed on a Model. The ModelResponse provides methods which can be used to specify the output format of the data retrieved from a Model, as well as how that data is delivered.\n * @constructor ModelResponse\n * @augments Observable\n*/\nfunction ModelResponse(subscribe) {\n    this._subscribe = subscribe;\n}\n\nModelResponse.prototype[$$observable] = function SymbolObservable() {\n    return toEsObservable(this);\n};\n\nModelResponse.prototype._toJSONG = function toJSONG() {\n    return this;\n};\n\n/**\n * The progressively method breaks the response up into two parts: the data immediately available in the Model cache, and the data in the Model cache after the missing data has been retrieved from the DataSource.\n * The progressively method creates a ModelResponse that immediately returns the requested data that is available in the Model cache. If any requested paths are not available in the cache, the ModelResponse will send another JSON message with all of the requested data after it has been retrieved from the DataSource.\n * @name progressively\n * @memberof ModelResponse.prototype\n * @function\n * @return {ModelResponse.<JSONEnvelope>} the values found at the requested paths.\n * @example\nvar dataSource = (new falcor.Model({\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\",\n      age: 31\n    }\n  }\n})).asDataSource();\n\nvar model = new falcor.Model({\n  source: dataSource,\n  cache: {\n    user: {\n      name: \"Steve\",\n      surname: \"McGuire\"\n    }\n  }\n});\n\nmodel.\n  get([\"user\",[\"name\", \"surname\", \"age\"]]).\n  progressively().\n  // this callback will be invoked twice, once with the data in the\n  // Model cache, and again with the additional data retrieved from the DataSource.\n  subscribe(function(json){\n    console.log(JSON.stringify(json,null,4));\n  });\n\n// prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\"\n//         }\n//     }\n// }\n// ...and then prints...\n// {\n//     \"json\": {\n//         \"user\": {\n//             \"name\": \"Steve\",\n//             \"surname\": \"McGuire\",\n//             \"age\": 31\n//         }\n//     }\n// }\n*/\nModelResponse.prototype.progressively = function progressively() {\n    return this;\n};\n\nModelResponse.prototype.subscribe =\nModelResponse.prototype.forEach = function subscribe(a, b, c) {\n    var observer = new ModelResponseObserver(a,b,c);\n    var subscription = this._subscribe(observer);\n    switch (typeof subscription) {\n        case \"function\":\n            return {\n                dispose: function() {\n                    if (observer._closed) {\n                        return;\n                    }\n                    observer._closed = true;\n                    subscription();\n                }\n             };\n        case \"object\":\n            return {\n                dispose: function() {\n                    if (observer._closed) {\n                        return;\n                    }\n                    observer._closed = true;\n                    if (subscription !== null) {\n                        subscription.dispose();\n                    }\n                }\n             };\n        default:\n            return {\n                dispose: function() {\n                    observer._closed = true;\n                }\n             };\n    }\n};\n\nModelResponse.prototype.then = function then(onNext, onError) {\n    /* global Promise */\n    var self = this;\n    if (!self._promise) {\n        self._promise = new Promise(function(resolve, reject) {\n            var rejected = false;\n            var values = [];\n            self.subscribe(\n                function(value) {\n                    values[values.length] = value;\n                },\n                function(errors) {\n                    rejected = true;\n                    reject(errors);\n                },\n                function() {\n                    var value = values;\n                    if (values.length <= 1) {\n                        value = values[0];\n                    }\n\n                    if (rejected === false) {\n                        resolve(value);\n                    }\n                }\n            );\n        });\n    }\n    return self._promise.then(onNext, onError);\n};\n\nmodule.exports = ModelResponse;\n\n}).call(this,typeof Promise === \"function\" ? Promise : require(156))\n},{\"115\":115,\"156\":156,\"164\":164,\"53\":53}],53:[function(require,module,exports){\nvar noop = require(102);\n\n/**\n * A ModelResponseObserver conform to the Observable's Observer contract. It accepts either an Observer or three optional callbacks which correspond to the Observer methods onNext, onError, and onCompleted.\n * The ModelResponseObserver wraps an Observer to enforce a variety of different invariants including:\n * 1. onError callback is only called once.\n * 2. onCompleted callback is only called once.\n * @constructor ModelResponseObserver\n*/\nfunction ModelResponseObserver(\n    onNextOrObserver,\n    onErrorFn,\n    onCompletedFn\n) {\n    // if callbacks are passed, construct an Observer from them. Create a NOOP function for any missing callbacks.\n    if (!onNextOrObserver || typeof onNextOrObserver !== \"object\") {\n        this._observer = {\n            onNext: (\n                typeof onNextOrObserver === \"function\"\n                    ? onNextOrObserver\n                    : noop\n            ),\n            onError: (\n                typeof onErrorFn === \"function\"\n                    ? onErrorFn\n                    : noop\n            ),\n            onCompleted: (\n                typeof onCompletedFn === \"function\"\n                    ? onCompletedFn\n                    : noop\n            )\n        };\n    }\n    // if an Observer is passed\n    else {\n        this._observer = {\n            onNext: typeof onNextOrObserver.onNext === \"function\" ? function(value) { onNextOrObserver.onNext(value); } : noop,\n            onError: typeof onNextOrObserver.onError === \"function\" ? function(error) { onNextOrObserver.onError(error); } : noop,\n            onCompleted: (\n                typeof onNextOrObserver.onCompleted === \"function\"\n                    ? function() { onNextOrObserver.onCompleted(); }\n                    : noop\n            )\n        };\n    }\n}\n\nModelResponseObserver.prototype = {\n    onNext: function(v) {\n        if (!this._closed) {\n            this._observer.onNext(v);\n        }\n    },\n    onError: function(e) {\n        if (!this._closed) {\n            this._closed = true;\n            this._observer.onError(e);\n        }\n    },\n    onCompleted: function() {\n        if (!this._closed) {\n            this._closed = true;\n            this._observer.onCompleted();\n        }\n    }\n};\n\nmodule.exports = ModelResponseObserver;\n\n},{\"102\":102}],54:[function(require,module,exports){\nvar ModelResponse = require(52);\nvar checkCacheAndReport = require(55);\nvar getRequestCycle = require(56);\nvar empty = {dispose: function() {}};\nvar collectLru = require(40);\nvar getSize = require(85);\n\n/**\n * The get response.  It takes in a model and paths and starts\n * the request cycle.  It has been optimized for cache first requests\n * and closures.\n * @param {Model} model -\n * @param {Array} paths -\n * @augments ModelResponse\n * @private\n */\nvar GetResponse = module.exports = function GetResponse(model, paths,\n                                                        isJSONGraph,\n                                                        isProgressive,\n                                                        forceCollect) {\n    this.model = model;\n    this.currentRemainingPaths = paths;\n    this.isJSONGraph = isJSONGraph || false;\n    this.isProgressive = isProgressive || false;\n    this.forceCollect = forceCollect || false;\n};\n\nGetResponse.prototype = Object.create(ModelResponse.prototype);\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nGetResponse.prototype._toJSONG = function _toJSONGraph() {\n    return new GetResponse(this.model, this.currentRemainingPaths,\n                           true, this.isProgressive, this.forceCollect);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nGetResponse.prototype.progressively = function progressively() {\n    return new GetResponse(this.model, this.currentRemainingPaths,\n                           this.isJSONGraph, true, this.forceCollect);\n};\n\n/**\n * purely for the purposes of closure creation other than the initial\n * prototype created closure.\n *\n * @private\n */\nGetResponse.prototype._subscribe = function _subscribe(observer) {\n    var seed = [{}];\n    var errors = [];\n    var model = this.model;\n    var isJSONG = observer.isJSONG = this.isJSONGraph;\n    var isProgressive = this.isProgressive;\n    var results = checkCacheAndReport(model, this.currentRemainingPaths,\n                                      observer, isProgressive, isJSONG, seed,\n                                      errors);\n\n    // If there are no results, finish.\n    if (!results) {\n        if (this.forceCollect) {\n            var modelRoot = model._root;\n            var modelCache = modelRoot.cache;\n            var currentVersion = modelCache.$_version;\n\n            collectLru(modelRoot, modelRoot.expired, getSize(modelCache),\n                    model._maxSize, model._collectRatio, currentVersion);\n        }\n        return empty;\n    }\n\n    // Starts the async request cycle.\n    return getRequestCycle(this, model, results,\n                           observer, errors, 1);\n};\n\n},{\"40\":40,\"52\":52,\"55\":55,\"56\":56,\"85\":85}],55:[function(require,module,exports){\nvar gets = require(23);\nvar getWithPathsAsJSONGraph = gets.getWithPathsAsJSONGraph;\nvar getWithPathsAsPathMap = gets.getWithPathsAsPathMap;\n\n/**\n * Checks cache for the paths and reports if in progressive mode.  If\n * there are missing paths then return the cache hit results.\n *\n * Return value (`results`) stores missing path information as 3 index-linked arrays:\n * `requestedMissingPaths` holds requested paths that were not found in cache\n * `optimizedMissingPaths` holds optimized versions of requested paths\n * `depthDifferences` holds the difference in length of requested and optimized paths\n *\n * Note that requestedMissingPaths is not necessarily the list of paths requested by\n * user in model.get. It does not contain those paths that were found in\n * cache. It also breaks some path sets out into separate paths, those which\n * resolve to different optimized lengths after walking through any references in\n * cache.\n * This helps maintain a 1:1 correspondence between requested and optimized missing,\n * as well as their depth differences (or, length offsets).\n *\n * Example: Given cache: `{ lolomo: { 0: $ref('vid'), 1: $ref('a.b.c.d') }}`,\n * `model.get('lolomo[0..2].name').subscribe()` will result in the following\n * corresponding values:\n *    index   requestedMissingPaths   optimizedMissingPaths         depthDifferences\n *      0     ['lolomo', 0, 'name']   ['vid', 'name']                   1\n *      1     ['lolomo', 1, 'name']   ['a', 'b', 'c', 'd', 'name']     -2\n *      2     ['lolomo', 2, 'name']   ['lolomo', 2, 'name']             0\n *\n * @param {Model} model - The model that the request was made with.\n * @param {Array} requestedMissingPaths -\n * @param {Boolean} progressive -\n * @param {Boolean} isJSONG -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @param {Object} seed - The state of the output\n * @returns {Object} results -\n *\n * @private\n */\nmodule.exports = function checkCacheAndReport(model, requestedPaths, observer,\n                                              progressive, isJSONG, seed,\n                                              errors) {\n\n    // checks the cache for the data.\n    var results = isJSONG ? getWithPathsAsJSONGraph(model, requestedPaths, seed)\n                          : getWithPathsAsPathMap(model, requestedPaths, seed);\n\n    // We are done when there are no missing paths or the model does not\n    // have a dataSource to continue on fetching from.\n    var valueNode = results.values && results.values[0];\n\n    var completed = !results.requestedMissingPaths ||\n                    !results.requestedMissingPaths.length ||\n                    !model._source;\n\n    // Copy the errors into the total errors array.\n    if (results.errors) {\n        var errs = results.errors;\n        var errorsLength = errors.length;\n        for (var i = 0, len = errs.length; i < len; ++i, ++errorsLength) {\n            errors[errorsLength] = errs[i];\n        }\n    }\n\n    // If there are values to report, then report.\n    // Which are under two conditions:\n    // 1.  This request is progressive\n    //\n    // 2.  The request if finished and the json key off\n    // the valueNode has a value.\n    if (progressive || ((progressive && results.hasValues || !progressive) && completed && valueNode !== undefined)) {\n        try {\n            observer.onNext(valueNode);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    // We must communicate critical errors from get that are critical\n    // errors such as bound path is broken or this is a JSONGraph request\n    // with a bound path.\n    if (results.criticalError) {\n        observer.onError(results.criticalError);\n        return null;\n    }\n\n    // if there are missing paths, then lets return them.\n    if (completed) {\n        if (errors.length) {\n            observer.onError(errors);\n        } else {\n            observer.onCompleted();\n        }\n\n        return null;\n    }\n\n    // Return the results object.\n    return results;\n};\n\n},{\"23\":23}],56:[function(require,module,exports){\nvar checkCacheAndReport = require(55);\nvar MaxRetryExceededError = require(12);\nvar fastCat = require(32).fastCat;\nvar collectLru = require(40);\nvar getSize = require(85);\nvar AssignableDisposable = require(49);\nvar InvalidSourceError = require(11);\n\n/**\n * The get request cycle for checking the cache and reporting\n * values.  If there are missing paths then the async request cycle to\n * the data source is performed until all paths are resolved or max\n * requests are made.\n * @param {GetResponse} getResponse -\n * @param {Model} model - The model that the request was made with.\n * @param {Object} results -\n * @param {Function} onNext -\n * @param {Function} onError -\n * @param {Function} onCompleted -\n * @private\n */\nmodule.exports = function getRequestCycle(getResponse, model, results, observer,\n                                          errors, count) {\n    // we have exceeded the maximum retry limit.\n    if (count > model._maxRetries) {\n        observer.onError(new MaxRetryExceededError(results.optimizedMissingPaths));\n        return {\n            dispose: function() {}\n        };\n    }\n\n    var requestQueue = model._request;\n    var requestedMissingPaths = results.requestedMissingPaths;\n    var optimizedMissingPaths = results.optimizedMissingPaths;\n    var depthDifferences = results.depthDifferences;\n    var disposable = new AssignableDisposable();\n\n    // We need to prepend the bound path to all requested missing paths and\n    // pass those into the requestQueue.\n    var boundRequestedMissingPaths = [];\n    var boundPath = model._path;\n    var boundPathLength = boundPath.length;\n    if (boundPath.length) {\n        for (var i = 0, len = requestedMissingPaths.length; i < len; ++i) {\n            boundRequestedMissingPaths[i] =\n                fastCat(boundPath, requestedMissingPaths[i]);\n            depthDifferences[i] += boundPathLength;\n        }\n    }\n\n    // No bound path, no array copy and concat.\n    else {\n        boundRequestedMissingPaths = requestedMissingPaths;\n    }\n\n    var currentRequestDisposable = requestQueue.\n        get(boundRequestedMissingPaths, optimizedMissingPaths, depthDifferences, function(err, data, hasInvalidatedResult) {\n            if (model._treatDataSourceErrorsAsJSONGraphErrors ? err instanceof InvalidSourceError : !!err) {\n                if (results.hasValues) {\n                    observer.onNext(results.values && results.values[0]);\n                }\n                observer.onError(err);\n                return;\n            }\n\n            var nextRequestedMissingPaths;\n            var nextSeed;\n\n            // If merging over an existing branch structure with refs has invalidated our intermediate json,\n            // we want to start over and re-get all requested paths with a fresh seed\n            if (hasInvalidatedResult) {\n                nextRequestedMissingPaths = getResponse.currentRemainingPaths;\n                nextSeed = [{}];\n            } else {\n                nextRequestedMissingPaths = requestedMissingPaths;\n                nextSeed = results.values;\n            }\n\n             // Once the request queue finishes, check the cache and bail if\n             // we can.\n            var nextResults = checkCacheAndReport(model, nextRequestedMissingPaths,\n                                                  observer,\n                                                  getResponse.isProgressive,\n                                                  getResponse.isJSONGraph,\n                                                  nextSeed, errors);\n\n            // If there are missing paths coming back form checkCacheAndReport\n            // the its reported from the core cache check method.\n            if (nextResults) {\n\n                // update the which disposable to use.\n                disposable.currentDisposable =\n                    getRequestCycle(getResponse, model, nextResults, observer,\n                                    errors, count + 1);\n            }\n\n            // We have finished.  Since we went to the dataSource, we must\n            // collect on the cache.\n            else {\n\n                var modelRoot = model._root;\n                var modelCache = modelRoot.cache;\n                var currentVersion = modelCache.$_version;\n\n                collectLru(modelRoot, modelRoot.expired, getSize(modelCache),\n                        model._maxSize, model._collectRatio, currentVersion);\n            }\n\n        });\n    disposable.currentDisposable = currentRequestDisposable;\n    return disposable;\n};\n\n},{\"11\":11,\"12\":12,\"32\":32,\"40\":40,\"49\":49,\"55\":55,\"85\":85}],57:[function(require,module,exports){\nvar GetResponse = require(54);\n\n/**\n * Performs a get on the cache and if there are missing paths\n * then the request will be forwarded to the get request cycle.\n * @private\n */\nmodule.exports = function getWithPaths(paths) {\n    return new GetResponse(this, paths);\n};\n\n},{\"54\":54}],58:[function(require,module,exports){\nvar pathSyntax = require(134);\nvar ModelResponse = require(52);\nvar GET_VALID_INPUT = require(59);\nvar validateInput = require(113);\nvar GetResponse = require(54);\n\n/**\n * Performs a get on the cache and if there are missing paths\n * then the request will be forwarded to the get request cycle.\n * @private\n */\nmodule.exports = function get() {\n    // Validates the input.  If the input is not pathSets or strings then we\n    // will onError.\n    var out = validateInput(arguments, GET_VALID_INPUT, \"get\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n\n    var paths = pathSyntax.fromPathsOrPathValues(arguments);\n    return new GetResponse(this, paths);\n};\n\n},{\"113\":113,\"134\":134,\"52\":52,\"54\":54,\"59\":59}],59:[function(require,module,exports){\nmodule.exports = {\n    path: true,\n    pathSyntax: true\n};\n\n},{}],60:[function(require,module,exports){\nvar toTree = require(145).toTree;\nvar ModelResponse = require(52);\n\nfunction ObserveResponse(model, paths) {\n  this.model = model;\n  this.paths = paths;\n}\n\nObserveResponse.prototype = Object.create(ModelResponse.prototype);\n\nObserveResponse.prototype._subscribe = function _subscribe(observer) {\n  var observerId = uniqueId();\n  var pathObservers = this.model._root._pathObservers;\n  pathObservers.push({\n    id: observerId,\n    observer: observer,\n    paths: this.paths,\n    pathMap: toTree(this.paths)\n  });\n  return {\n    dispose: function dispose() {\n      var pathObs = pathObservers.find(function(po) {\n        return po.id === observerId;\n      });\n      if (!pathObs) {\n        return;\n      }\n      pathObservers.splice(pathObservers.indexOf(pathObs), 1);\n    }\n  };\n};\n\nvar autoIncrementingId = 0;\nfunction uniqueId() {\n  return autoIncrementingId++;\n}\n\nmodule.exports = ObserveResponse;\n\n},{\"145\":145,\"52\":52}],61:[function(require,module,exports){\nvar pathSyntax = require(134);\n\nvar validateInput = require(113);\nvar GET_VALID_INPUT = require(59);\nvar ObserveResponse = require(60);\nvar ModelResponse = require(52);\n\nmodule.exports = function observe() {\n    // Validates the input. If the input is not pathSets or strings then we\n    // will onError.\n    var out = validateInput(arguments, GET_VALID_INPUT, \"observe\");\n    if (out !== true) {\n            return new ModelResponse(function(o) {\n                    o.onError(out);\n            });\n    }\n\n    var paths = pathSyntax.fromPathsOrPathValues(arguments);\n    return new ObserveResponse(this, paths);\n};\n\n},{\"113\":113,\"134\":134,\"52\":52,\"59\":59,\"60\":60}],62:[function(require,module,exports){\nvar ModelResponse = require(52);\nvar pathSyntax = require(134);\nvar isArray = Array.isArray;\nvar isPathValue = require(98);\nvar isJSONGraphEnvelope = require(96);\nvar isJSONEnvelope = require(95);\nvar setRequestCycle = require(65);\n\n/**\n *  The set response is responsible for doing the request loop for the set\n * operation and subscribing to the follow up get.\n *\n * The constructors job is to parse out the arguments and put them in their\n * groups.  The following subscribe will do the actual cache set and dataSource\n * operation remoting.\n *\n * @param {Model} model -\n * @param {Array} args - The array of arguments that can be JSONGraph, JSON, or\n * pathValues.\n * @param {Boolean} isJSONGraph - if the request is a jsonGraph output format.\n * @param {Boolean} isProgressive - progressive output.\n * @augments ModelResponse\n * @private\n */\nvar SetResponse = module.exports = function SetResponse(model, args,\n                                                        isJSONGraph,\n                                                        isProgressive) {\n\n    // The response properties.\n    this._model = model;\n    this._isJSONGraph = isJSONGraph || false;\n    this._isProgressive = isProgressive || false;\n    this._initialArgs = args;\n    this._value = [{}];\n\n    var groups = [];\n    var group, groupType;\n    var argIndex = -1;\n    var argCount = args.length;\n\n    // Validation of arguments have been moved out of this function.\n    while (++argIndex < argCount) {\n        var arg = args[argIndex];\n        var argType;\n        if (isArray(arg) || typeof arg === \"string\") {\n            arg = pathSyntax.fromPath(arg);\n            argType = \"PathValues\";\n        } else if (isPathValue(arg)) {\n            arg.path = pathSyntax.fromPath(arg.path);\n            argType = \"PathValues\";\n        } else if (isJSONGraphEnvelope(arg)) {\n            argType = \"JSONGs\";\n        } else if (isJSONEnvelope(arg)) {\n            argType = \"PathMaps\";\n        }\n\n        if (groupType !== argType) {\n            groupType = argType;\n            group = {\n                inputType: argType,\n                arguments: []\n            };\n            groups.push(group);\n        }\n\n        group.arguments.push(arg);\n    }\n\n    this._groups = groups;\n};\n\nSetResponse.prototype = Object.create(ModelResponse.prototype);\n\n/**\n * The subscribe function will setup the remoting of the operation and cache\n * setting.\n *\n * @private\n */\nSetResponse.prototype._subscribe = function _subscribe(observer) {\n    var groups = this._groups;\n    var model = this._model;\n    var isJSONGraph = this._isJSONGraph;\n    var isProgressive = this._isProgressive;\n\n    // Starts the async request cycle.\n    return setRequestCycle(\n        model, observer, groups, isJSONGraph, isProgressive, 0);\n};\n\n/**\n * Makes the output of a get response JSONGraph instead of json.\n * @private\n */\nSetResponse.prototype._toJSONG = function _toJSONGraph() {\n    return new SetResponse(this._model, this._initialArgs,\n                           true, this._isProgressive);\n};\n\n/**\n * Progressively responding to data in the cache instead of once the whole\n * operation is complete.\n * @public\n */\nSetResponse.prototype.progressively = function progressively() {\n    return new SetResponse(this._model, this._initialArgs,\n                           this._isJSONGraph, true);\n};\n\n},{\"134\":134,\"52\":52,\"65\":65,\"95\":95,\"96\":96,\"98\":98}],63:[function(require,module,exports){\nvar setValidInput = require(66);\nvar validateInput = require(113);\nvar SetResponse = require(62);\nvar ModelResponse = require(52);\n\nmodule.exports = function set() {\n    var out = validateInput(arguments, setValidInput, \"set\");\n    if (out !== true) {\n        return new ModelResponse(function(o) {\n            o.onError(out);\n        });\n    }\n\n    var argsIdx = -1;\n    var argsLen = arguments.length;\n    var args = [];\n    while (++argsIdx < argsLen) {\n        args[argsIdx] = arguments[argsIdx];\n    }\n    return new SetResponse(this, args);\n};\n\n},{\"113\":113,\"52\":52,\"62\":62,\"66\":66}],64:[function(require,module,exports){\nvar arrayFlatMap = require(77);\n\n/**\n * Takes the groups that are created in the SetResponse constructor and sets\n * them into the cache.\n */\nmodule.exports = function setGroupsIntoCache(model, groups) {\n    var modelRoot = model._root;\n    var errorSelector = modelRoot.errorSelector;\n    var groupIndex = -1;\n    var groupCount = groups.length;\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var returnValue = {\n        requestedPaths: requestedPaths,\n        optimizedPaths: optimizedPaths\n    };\n\n    // Takes each of the groups and normalizes their input into\n    // requested paths and optimized paths.\n    while (++groupIndex < groupCount) {\n\n        var group = groups[groupIndex];\n        var inputType = group.inputType;\n        var methodArgs = group.arguments;\n\n        if (methodArgs.length > 0) {\n            var operationName = \"_set\" + inputType;\n            var operationFunc = model[operationName];\n            var successfulPaths = operationFunc(model, methodArgs, null, errorSelector);\n\n            optimizedPaths.push.apply(optimizedPaths, successfulPaths[1]);\n\n            if (inputType === \"PathValues\") {\n                requestedPaths.push.apply(requestedPaths, methodArgs.map(pluckPath));\n            } else if (inputType === \"JSONGs\") {\n                requestedPaths.push.apply(requestedPaths, arrayFlatMap(methodArgs, pluckEnvelopePaths));\n            } else {\n                requestedPaths.push.apply(requestedPaths, successfulPaths[0]);\n            }\n        }\n    }\n\n    return returnValue;\n};\n\nfunction pluckPath(pathValue) {\n    return pathValue.path;\n}\n\nfunction pluckEnvelopePaths(jsonGraphEnvelope) {\n    return jsonGraphEnvelope.paths;\n}\n\n},{\"77\":77}],65:[function(require,module,exports){\nvar emptyArray = [];\nvar AssignableDisposable = require(49);\nvar GetResponse = require(54);\nvar setGroupsIntoCache = require(64);\nvar getWithPathsAsPathMap = require(23).getWithPathsAsPathMap;\nvar InvalidSourceError = require(11);\nvar MaxRetryExceededError = require(12);\n\n/**\n * The request cycle for set.  This is responsible for requesting to dataSource\n * and allowing disposing inflight requests.\n */\nmodule.exports = function setRequestCycle(model, observer, groups,\n                                          isJSONGraph, isProgressive, count) {\n    var requestedAndOptimizedPaths = setGroupsIntoCache(model, groups);\n    var optimizedPaths = requestedAndOptimizedPaths.optimizedPaths;\n    var requestedPaths = requestedAndOptimizedPaths.requestedPaths;\n\n    // we have exceeded the maximum retry limit.\n    if (count === model._maxRetries) {\n        observer.onError(new MaxRetryExceededError(optimizedPaths));\n        return {\n            dispose: function() {}\n        };\n    }\n\n    var isMaster = model._source === undefined;\n\n    // Local set only.  We perform a follow up get.  If performance is ever\n    // a requirement simply requiring in checkCacheAndReport and use get request\n    // internals.  Figured this is more \"pure\".\n    if (isMaster) {\n        return subscribeToFollowupGet(model, observer, requestedPaths,\n                              isJSONGraph, isProgressive);\n    }\n\n\n    // Progressively output the data from the first set.\n    var prevVersion;\n    if (isProgressive) {\n        var results = getWithPathsAsPathMap(model, requestedPaths, [{}]);\n        if (results.criticalError) {\n            observer.onError(results.criticalError);\n            return null;\n        }\n        observer.onNext(results.values[0]);\n\n        prevVersion = model._root.cache.$_version;\n    }\n\n    var currentJSONGraph = getJSONGraph(model, optimizedPaths);\n    var disposable = new AssignableDisposable();\n\n    // Sends out the setRequest.  The Queue will call the callback with the\n    // JSONGraph envelope / error.\n    var requestDisposable = model._request.\n        // TODO: There is error handling that has not been addressed yet.\n\n        // If disposed before this point then the sendSetRequest will not\n        // further any callbacks.  Therefore, if we are at this spot, we are\n        // not disposed yet.\n        set(currentJSONGraph, function(error, jsonGraphEnv) {\n            if (error instanceof InvalidSourceError) {\n                observer.onError(error);\n                return;\n            }\n\n            // TODO: This seems like there are errors with this approach, but\n            // for sanity sake I am going to keep this logic in here until a\n            // rethink can be done.\n            var isCompleted = false;\n            if (error || optimizedPaths.length === jsonGraphEnv.paths.length) {\n                isCompleted = true;\n            }\n\n            // If we're in progressive mode and nothing changed in the meantime, we're done\n            if (isProgressive) {\n                var nextVersion = model._root.cache.$_version;\n                var versionChanged = nextVersion !== prevVersion;\n\n                if (!versionChanged) {\n                    observer.onCompleted();\n                    return;\n                }\n            }\n\n            // Happy case.  One request to the dataSource will fulfill the\n            // required paths.\n            if (isCompleted) {\n                disposable.currentDisposable =\n                    subscribeToFollowupGet(model, observer, requestedPaths,\n                                          isJSONGraph, isProgressive);\n            }\n\n            // TODO: The unhappy case.  I am unsure how this can even be\n            // achieved.\n            else {\n                // We need to restart the setRequestCycle.\n                setRequestCycle(model, observer, groups, isJSONGraph,\n                                isProgressive, count + 1);\n            }\n        });\n\n    // Sets the current disposable as the requestDisposable.\n    disposable.currentDisposable = requestDisposable;\n\n    return disposable;\n};\n\nfunction getJSONGraph(model, optimizedPaths) {\n    var boundPath = model._path;\n    var envelope = {};\n    model._path = emptyArray;\n    model._getPathValuesAsJSONG(model._materialize().withoutDataSource(), optimizedPaths, [envelope]);\n    model._path = boundPath;\n\n    return envelope;\n}\n\nfunction subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph,\n                               isProgressive) {\n\n    // Creates a new response and subscribes to it with the original observer.\n    // Also sets forceCollect to true, incase the operation is synchronous and\n    // exceeds the cache limit size\n    var response = new GetResponse(model, requestedPaths, isJSONGraph,\n                                   isProgressive, true);\n    return response.subscribe(observer);\n}\n\n},{\"11\":11,\"12\":12,\"23\":23,\"49\":49,\"54\":54,\"64\":64}],66:[function(require,module,exports){\nmodule.exports = {\n    pathValue: true,\n    pathSyntax: true,\n    json: true,\n    jsonGraph: true\n};\n\n\n},{}],67:[function(require,module,exports){\nvar asap = require(123);\nvar empty = {dispose: function() {}};\n\nfunction ASAPScheduler() {}\n\nASAPScheduler.prototype.schedule = function schedule(action) {\n    asap(action);\n    return empty;\n};\n\nASAPScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n    var self = this;\n    asap(function() {\n        action(self, state);\n    });\n    return empty;\n};\n\nmodule.exports = ASAPScheduler;\n\n},{\"123\":123}],68:[function(require,module,exports){\nvar empty = {dispose: function() {}};\n\nfunction ImmediateScheduler() {}\n\nImmediateScheduler.prototype.schedule = function schedule(action) {\n    action();\n    return empty;\n};\n\nImmediateScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n    action(this, state);\n    return empty;\n};\n\nmodule.exports = ImmediateScheduler;\n\n},{}],69:[function(require,module,exports){\nfunction TimeoutScheduler(delay) {\n    this.delay = delay;\n}\n\nvar TimerDisposable = function TimerDisposable(id) {\n    this.id = id;\n    this.disposed = false;\n};\n\nTimeoutScheduler.prototype.schedule = function schedule(action) {\n    var id = setTimeout(action, this.delay);\n    return new TimerDisposable(id);\n};\n\nTimeoutScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {\n    var self = this;\n    var id = setTimeout(function() {\n        action(self, state);\n    }, this.delay);\n    return new TimerDisposable(id);\n};\n\nTimerDisposable.prototype.dispose = function() {\n    if (this.disposed) {\n        return;\n    }\n\n    clearTimeout(this.id);\n    this.disposed = true;\n};\n\nmodule.exports = TimeoutScheduler;\n\n},{}],70:[function(require,module,exports){\nvar toTree = require(145).toTree;\n\nvar createHardlink = require(81);\nvar $ref = require(118);\n\nvar isExpired = require(91);\nvar isFunction = require(93);\nvar isPrimitive = require(99);\nvar expireNode = require(83);\nvar iterateKeySet = require(145).iterateKeySet;\nvar incrementVersion = require(89);\nvar mergeJSONGraphNode = require(100);\nvar NullInPathError = require(13);\n\n/**\n * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.\n * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setJSONGraphs(model, jsonGraphEnvelopes, x, errorSelector, comparator, replacedPaths) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var cache = modelRoot.cache;\n    var initialVersion = cache.$_version;\n\n    var requestedPath = [];\n    var optimizedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var jsonGraphEnvelopeIndex = -1;\n    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;\n\n    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {\n\n        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];\n        var paths = jsonGraphEnvelope.paths;\n        var jsonGraph = jsonGraphEnvelope.jsonGraph;\n\n        var pathIndex = -1;\n        var pathCount = paths.length;\n\n        while (++pathIndex < pathCount) {\n\n            var path = paths[pathIndex];\n            optimizedPath.index = 0;\n\n            setJSONGraphPathSet(\n                path, 0,\n                cache, cache, cache,\n                jsonGraph, jsonGraph, jsonGraph,\n                requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector, replacedPaths\n            );\n        }\n    }\n\n    if (modelRoot.hasObservers()) {\n        var affectedPaths = jsonGraphEnvelopes.reduce(function(allPaths, envelope) {\n            return allPaths.concat(envelope.paths);\n        }, []);\n        var affectedPathMap = toTree(affectedPaths);\n        modelRoot.onObserve(affectedPaths, affectedPathMap);\n    }\n\n    var newVersion = cache.$_version;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setJSONGraphPathSet(\n    path, depth, root, parent, node,\n    messageRoot, messageParent, message,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, false, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, replacedPaths\n        );\n\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n        optimizedPath[optimizedPath.index++] = key;\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                setJSONGraphPathSet(\n                    path, depth + 1, root, nextParent, nextNode,\n                    messageRoot, results[3], results[2],\n                    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                    version, expired, lru, comparator, errorSelector, replacedPaths\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    root, node, messageRoot, message, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var reference = node.value;\n    optimizedPath.splice(0, optimizedPath.length);\n    optimizedPath.push.apply(optimizedPath, reference);\n\n    if (isExpired(node)) {\n        optimizedPath.index = reference.length;\n        expireNode(node, expired, lru);\n        return [undefined, root, message, messageRoot];\n    }\n\n    var index = 0;\n    var container = node;\n    var count = reference.length - 1;\n    var parent = node = root;\n    var messageParent = message = messageRoot;\n\n    do {\n        var key = reference[index];\n        var branch = index < count;\n        optimizedPath.index = index;\n\n        var results = setNode(\n            root, parent, node, messageRoot, messageParent, message,\n            key, branch, true, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, replacedPaths\n        );\n        node = results[0];\n        if (isPrimitive(node)) {\n            optimizedPath.index = index;\n            return results;\n        }\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n    } while (index++ < count);\n\n    optimizedPath.index = index;\n\n    if (container.$_context !== node) {\n        createHardlink(container, node);\n    }\n\n    return [node, parent, message, messageParent];\n}\n\nfunction setNode(\n    root, parent, node, messageRoot, messageParent, message,\n    key, branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            root, node, messageRoot, message, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, replacedPaths\n        );\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        message = results[2];\n        messageParent = results[3];\n        type = node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent, message, messageParent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new NullInPathError();\n        } else if (node) {\n            key = node.$_key;\n        }\n    } else {\n        parent = node;\n        messageParent = message;\n        node = parent[key];\n        message = messageParent && messageParent[key];\n    }\n\n    node = mergeJSONGraphNode(\n        parent, node, message, key, requestedPath, optimizedPath,\n        version, expired, lru, comparator, errorSelector, replacedPaths\n    );\n\n    return [node, parent, message, messageParent];\n}\n\n},{\"100\":100,\"118\":118,\"13\":13,\"145\":145,\"81\":81,\"83\":83,\"89\":89,\"91\":91,\"93\":93,\"99\":99}],71:[function(require,module,exports){\nvar pathUtils = require(145);\nvar toTree = pathUtils.toTree;\nvar toPaths = pathUtils.toPaths;\n\nvar createHardlink = require(81);\nvar __prefix = require(37);\nvar $ref = require(118);\n\nvar getBoundValue = require(17);\n\nvar isArray = Array.isArray;\nvar hasOwn = require(88);\nvar isObject = require(97);\nvar isExpired = require(92);\nvar isFunction = require(93);\nvar isPrimitive = require(99);\nvar expireNode = require(83);\nvar incrementVersion = require(89);\nvar mergeValueOrInsertBranch = require(101);\nvar NullInPathError = require(13);\n\n/**\n * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the PathMaps.\n * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathMaps(model, pathMapEnvelopes, x, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    var parent = node.$_parent || cache;\n    var initialVersion = cache.$_version;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathMapIndex = -1;\n    var pathMapCount = pathMapEnvelopes.length;\n\n    while (++pathMapIndex < pathMapCount) {\n\n        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathMap(\n            pathMapEnvelope.json, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    if (modelRoot.hasObservers()) {\n        var affectedPaths = pathMapEnvelopes.reduce(function(allPaths, envelope) {\n            return allPaths.concat(toPaths(envelope.json));\n        }, []);\n        var affectedPathMap = toTree(affectedPaths);\n        modelRoot.onObserve(affectedPaths, affectedPathMap);\n    }\n\n    var newVersion = cache.$_version;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathMap(\n    pathMap, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var keys = getKeys(pathMap);\n\n    if (keys && keys.length) {\n\n        var keyIndex = 0;\n        var keyCount = keys.length;\n        var optimizedIndex = optimizedPath.index;\n\n        do {\n            var key = keys[keyIndex];\n            var child = pathMap[key];\n            var branch = isObject(child) && !child.$type;\n\n            requestedPath.depth = depth;\n\n            var results = setNode(\n                root, parent, node, key, child,\n                branch, false, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n\n            requestedPath[depth] = key;\n            requestedPath.index = depth;\n\n            optimizedPath[optimizedPath.index++] = key;\n            var nextNode = results[0];\n            var nextParent = results[1];\n            if (nextNode) {\n                if (branch) {\n                    setPathMap(\n                        child, depth + 1,\n                        root, nextParent, nextNode,\n                        requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                        version, expired, lru, comparator, errorSelector\n                    );\n                } else {\n                    requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                    optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n                }\n            }\n            if (++keyIndex >= keyCount) {\n                break;\n            }\n            optimizedPath.index = optimizedIndex;\n        } while (true);\n    }\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var reference = node.value;\n    optimizedPath.splice(0, optimizedPath.length);\n    optimizedPath.push.apply(optimizedPath, reference);\n\n    if (isExpired(node)) {\n        optimizedPath.index = reference.length;\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    var container = node;\n    var parent = root;\n\n    node = node.$_context;\n\n    if (node != null) {\n        parent = node.$_parent || root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n        optimizedPath.index = index;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            var results = setNode(\n                root, parent, node, key, value,\n                branch, true, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container.$_context !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector);\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node && node.$type;\n    }\n\n    if (type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new NullInPathError();\n        } else if (node) {\n            key = node.$_key;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    node = mergeValueOrInsertBranch(\n        parent, node, key, value,\n        branch, reference, requestedPath, optimizedPath,\n        version, expired, lru, comparator, errorSelector\n    );\n\n    return [node, parent];\n}\n\nfunction getKeys(pathMap) {\n\n    if (isObject(pathMap) && !pathMap.$type) {\n        var keys = [];\n        var itr = 0;\n        if (isArray(pathMap)) {\n            keys[itr++] = \"length\";\n        }\n        for (var key in pathMap) {\n            if (key[0] === __prefix || !hasOwn(pathMap, key)) {\n                continue;\n            }\n            keys[itr++] = key;\n        }\n        return keys;\n    }\n\n    return void 0;\n}\n\n},{\"101\":101,\"118\":118,\"13\":13,\"145\":145,\"17\":17,\"37\":37,\"81\":81,\"83\":83,\"88\":88,\"89\":89,\"92\":92,\"93\":93,\"97\":97,\"99\":99}],72:[function(require,module,exports){\nvar toTree = require(145).toTree;\n\nvar createHardlink = require(81);\nvar $ref = require(118);\n\nvar getBoundValue = require(17);\n\nvar isExpired = require(92);\nvar isFunction = require(93);\nvar isPrimitive = require(99);\nvar expireNode = require(83);\nvar iterateKeySet = require(145).iterateKeySet;\nvar incrementVersion = require(89);\nvar mergeValueOrInsertBranch = require(101);\nvar NullInPathError = require(13);\n\n/**\n * Sets a list of {@link PathValue}s into a {@link JSONGraph}.\n * @function\n * @param {Object} model - the Model for which to insert the {@link PathValue}s.\n * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.\n * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.\n */\n\nmodule.exports = function setPathValues(model, pathValues, x, errorSelector, comparator) {\n\n    var modelRoot = model._root;\n    var lru = modelRoot;\n    var expired = modelRoot.expired;\n    var version = incrementVersion();\n    var bound = model._path;\n    var cache = modelRoot.cache;\n    var node = bound.length ? getBoundValue(model, bound).value : cache;\n    var parent = node.$_parent || cache;\n    var initialVersion = cache.$_version;\n\n    var requestedPath = [];\n    var requestedPaths = [];\n    var optimizedPaths = [];\n    var optimizedIndex = bound.length;\n    var pathValueIndex = -1;\n    var pathValueCount = pathValues.length;\n\n    while (++pathValueIndex < pathValueCount) {\n\n        var pathValue = pathValues[pathValueIndex];\n        var path = pathValue.path;\n        var value = pathValue.value;\n        var optimizedPath = bound.slice(0);\n        optimizedPath.index = optimizedIndex;\n\n        setPathSet(\n            value, path, 0, cache, parent, node,\n            requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector\n        );\n    }\n\n    if (modelRoot.hasObservers()) {\n        var affectedPaths = pathValues.map(function(pv) {\n            return pv.path;\n        });\n        var affectedPathMap = toTree(affectedPaths);\n        modelRoot.onObserve(affectedPaths, affectedPathMap);\n    }\n\n    var newVersion = cache.$_version;\n    var rootChangeHandler = modelRoot.onChange;\n\n    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {\n        rootChangeHandler();\n    }\n\n    return [requestedPaths, optimizedPaths];\n};\n\n/* eslint-disable no-constant-condition */\nfunction setPathSet(\n    value, path, depth, root, parent, node,\n    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var note = {};\n    var branch = depth < path.length - 1;\n    var keySet = path[depth];\n    var key = iterateKeySet(keySet, note);\n    var optimizedIndex = optimizedPath.index;\n\n    do {\n\n        requestedPath.depth = depth;\n\n        var results = setNode(\n            root, parent, node, key, value,\n            branch, false, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, replacedPaths\n        );\n        requestedPath[depth] = key;\n        requestedPath.index = depth;\n        optimizedPath[optimizedPath.index++] = key;\n        var nextNode = results[0];\n        var nextParent = results[1];\n        if (nextNode) {\n            if (branch) {\n                setPathSet(\n                    value, path, depth + 1,\n                    root, nextParent, nextNode,\n                    requestedPaths, optimizedPaths, requestedPath, optimizedPath,\n                    version, expired, lru, comparator, errorSelector\n                );\n            } else {\n                requestedPaths.push(requestedPath.slice(0, requestedPath.index + 1));\n                optimizedPaths.push(optimizedPath.slice(0, optimizedPath.index));\n            }\n        }\n        key = iterateKeySet(keySet, note);\n        if (note.done) {\n            break;\n        }\n        optimizedPath.index = optimizedIndex;\n    } while (true);\n}\n/* eslint-enable */\n\nfunction setReference(\n    value, root, node, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var reference = node.value;\n    optimizedPath.splice(0, optimizedPath.length);\n    optimizedPath.push.apply(optimizedPath, reference);\n\n    if (isExpired(node)) {\n        optimizedPath.index = reference.length;\n        expireNode(node, expired, lru);\n        return [undefined, root];\n    }\n\n    var container = node;\n    var parent = root;\n\n    node = node.$_context;\n\n    if (node != null) {\n        parent = node.$_parent || root;\n        optimizedPath.index = reference.length;\n    } else {\n\n        var index = 0;\n        var count = reference.length - 1;\n\n        parent = node = root;\n\n        do {\n            var key = reference[index];\n            var branch = index < count;\n            optimizedPath.index = index;\n\n            var results = setNode(\n                root, parent, node, key, value,\n                branch, true, requestedPath, optimizedPath,\n                version, expired, lru, comparator, errorSelector, replacedPaths\n            );\n            node = results[0];\n            if (isPrimitive(node)) {\n                optimizedPath.index = index;\n                return results;\n            }\n            parent = results[1];\n        } while (index++ < count);\n\n        optimizedPath.index = index;\n\n        if (container.$_context !== node) {\n            createHardlink(container, node);\n        }\n    }\n\n    return [node, parent];\n}\n\nfunction setNode(\n    root, parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var type = node.$type;\n\n    while (type === $ref) {\n\n        var results = setReference(\n            value, root, node, requestedPath, optimizedPath,\n            version, expired, lru, comparator, errorSelector, replacedPaths\n        );\n\n        node = results[0];\n\n        if (isPrimitive(node)) {\n            return results;\n        }\n\n        parent = results[1];\n        type = node.$type;\n    }\n\n    if (branch && type !== void 0) {\n        return [node, parent];\n    }\n\n    if (key == null) {\n        if (branch) {\n            throw new NullInPathError();\n        } else if (node) {\n            key = node.$_key;\n        }\n    } else {\n        parent = node;\n        node = parent[key];\n    }\n\n    node = mergeValueOrInsertBranch(\n        parent, node, key, value,\n        branch, reference, requestedPath, optimizedPath,\n        version, expired, lru, comparator, errorSelector, replacedPaths\n    );\n\n    return [node, parent];\n}\n\n},{\"101\":101,\"118\":118,\"13\":13,\"145\":145,\"17\":17,\"81\":81,\"83\":83,\"89\":89,\"92\":92,\"93\":93,\"99\":99}],73:[function(require,module,exports){\nvar jsong = require(130);\nvar ModelResponse = require(52);\nvar isPathValue = require(98);\n\nmodule.exports = function setValue(pathArg, valueArg) {\n    var value = isPathValue(pathArg) ? pathArg : jsong.pathValue(pathArg, valueArg);\n    var pathIdx = 0;\n    var path = value.path;\n    var pathLen = path.length;\n    while (++pathIdx < pathLen) {\n        if (typeof path[pathIdx] === \"object\") {\n            /* eslint-disable no-loop-func */\n            return new ModelResponse(function(o) {\n                o.onError(new Error(\"Paths must be simple paths\"));\n            });\n            /* eslint-enable no-loop-func */\n        }\n    }\n    var self = this;\n    return new ModelResponse(function(obs) {\n        return self.set(value).subscribe(function(data) {\n            var curr = data.json;\n            var depth = -1;\n            var length = path.length;\n\n            while (curr && ++depth < length) {\n                curr = curr[path[depth]];\n            }\n            obs.onNext(curr);\n        }, function(err) {\n            obs.onError(err);\n        }, function() {\n            obs.onCompleted();\n        });\n    });\n};\n\n},{\"130\":130,\"52\":52,\"98\":98}],74:[function(require,module,exports){\nvar pathSyntax = require(134);\nvar isPathValue = require(98);\nvar setPathValues = require(72);\n\nmodule.exports = function setValueSync(pathArg, valueArg, errorSelectorArg, comparatorArg) {\n\n    var path = pathSyntax.fromPath(pathArg);\n    var value = valueArg;\n    var errorSelector = errorSelectorArg;\n    // XXX comparator is never used.\n    var comparator = comparatorArg;\n\n    if (isPathValue(path)) {\n        comparator = errorSelector;\n        errorSelector = value;\n        value = path;\n    } else {\n        value = {\n            path: path,\n            value: value\n        };\n    }\n\n    if (isPathValue(value) === false) {\n        throw new Error(\"Model#setValueSync must be called with an Array path.\");\n    }\n\n    if (typeof errorSelector !== \"function\") {\n        errorSelector = this._root._errorSelector;\n    }\n\n    if (typeof comparator !== \"function\") {\n        comparator = this._root._comparator;\n    }\n\n    this._syncCheck(\"setValueSync\");\n    setPathValues(this, [value]);\n    return this._getValueSync(value.path);\n};\n\n},{\"134\":134,\"72\":72,\"98\":98}],75:[function(require,module,exports){\nmodule.exports = function arrayClone(array) {\n    if (!array) {\n        return array;\n    }\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        array2[i] = array[i];\n    }\n    return array2;\n};\n\n},{}],76:[function(require,module,exports){\nmodule.exports = function arrayConcat(array, other) {\n    if (!array) {\n        return other;\n    }\n    var i = -1,\n        j = -1;\n    var n = array.length;\n    var m = other.length;\n    var array2 = new Array(n + m);\n    while (++i < n) {\n        array2[i] = array[i];\n    }\n    while (++j < m) {\n        array2[i++] = other[j];\n    }\n    return array2;\n};\n\n},{}],77:[function(require,module,exports){\nmodule.exports = function arrayFlatMap(array, selector) {\n    var index = -1;\n    var i = -1;\n    var n = array.length;\n    var array2 = [];\n    while (++i < n) {\n        var array3 = selector(array[i], i, array);\n        var j = -1;\n        var k = array3.length;\n        while (++j < k) {\n            array2[++index] = array3[j];\n        }\n    }\n    return array2;\n};\n\n},{}],78:[function(require,module,exports){\nmodule.exports = function arrayMap(array, selector) {\n    var i = -1;\n    var n = array.length;\n    var array2 = new Array(n);\n    while (++i < n) {\n        array2[i] = selector(array[i], i, array);\n    }\n    return array2;\n};\n\n},{}],79:[function(require,module,exports){\nmodule.exports = function arraySlice(array, indexArg, endArg) {\n    var index = indexArg || 0;\n    var i = -1;\n    var n = array.length - index;\n\n    if (n < 0) {\n        n = 0;\n    }\n\n    if (endArg > 0 && n > endArg) {\n        n = endArg;\n    }\n\n    var array2 = new Array(n);\n    while (++i < n) {\n        array2[i] = array[i + index];\n    }\n    return array2;\n};\n\n},{}],80:[function(require,module,exports){\nvar privatePrefix = require(35);\nvar hasOwn = require(88);\nvar isArray = Array.isArray;\nvar isObject = require(97);\n\nmodule.exports = function clone(value) {\n    var dest = value;\n    if (isObject(dest)) {\n        dest = isArray(value) ? [] : {};\n        var src = value;\n        for (var key in src) {\n            if (key.substr(0,2) === privatePrefix || !hasOwn(src, key)) {\n                continue;\n            }\n            dest[key] = src[key];\n        }\n    }\n    return dest;\n};\n\n},{\"35\":35,\"88\":88,\"97\":97}],81:[function(require,module,exports){\nvar __ref = require(36);\n\nmodule.exports = function createHardlink(from, to) {\n\n    // create a back reference\n    // eslint-disable-next-line camelcase\n    var backRefs = to.$_refsLength || 0;\n    to[__ref + backRefs] = from;\n    // eslint-disable-next-line camelcase\n    to.$_refsLength = backRefs + 1;\n\n    // create a hard reference\n    // eslint-disable-next-line camelcase\n    from.$_refIndex = backRefs;\n    // eslint-disable-next-line camelcase\n    from.$_context = to;\n};\n\n},{\"36\":36}],82:[function(require,module,exports){\nvar version = null;\nexports.setVersion = function setCacheVersion(newVersion) {\n    version = newVersion;\n};\nexports.getVersion = function getCacheVersion() {\n    return version;\n};\n\n\n},{}],83:[function(require,module,exports){\nvar splice = require(42);\n\nmodule.exports = function expireNode(node, expired, lru) {\n    // eslint-disable-next-line camelcase\n    if (!node.$_invalidated) {\n        // eslint-disable-next-line camelcase\n        node.$_invalidated = true;\n        expired.push(node);\n        splice(lru, node);\n    }\n    return node;\n};\n\n},{\"42\":42}],84:[function(require,module,exports){\nvar isObject = require(97);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$expires || undefined;\n};\n\n},{\"97\":97}],85:[function(require,module,exports){\nvar isObject = require(97);\nmodule.exports = function getSize(node) {\n    return isObject(node) && node.$size || 0;\n};\n\n},{\"97\":97}],86:[function(require,module,exports){\nvar isObject = require(97);\nmodule.exports = function getTimestamp(node) {\n    return isObject(node) && node.$timestamp || undefined;\n};\n\n},{\"97\":97}],87:[function(require,module,exports){\nvar isObject = require(97);\n\nmodule.exports = function getType(node, anyType) {\n    var type = isObject(node) && node.$type || void 0;\n    if (anyType && type) {\n        return \"branch\";\n    }\n    return type;\n};\n\n},{\"97\":97}],88:[function(require,module,exports){\nvar isObject = require(97);\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function(obj, prop) {\n  return isObject(obj) && hasOwn.call(obj, prop);\n};\n\n},{\"97\":97}],89:[function(require,module,exports){\nvar version = 1;\nmodule.exports = function incrementVersion() {\n    return version++;\n};\nmodule.exports.getCurrentVersion = function getCurrentVersion() {\n    return version;\n};\n\n},{}],90:[function(require,module,exports){\nmodule.exports = function insertNode(node, parent, key, version, optimizedPath) {\n    // eslint-disable-next-line camelcase\n    node.$_key = key;\n    // eslint-disable-next-line camelcase\n    node.$_parent = parent;\n\n    if (version !== undefined) {\n        // eslint-disable-next-line camelcase\n        node.$_version = version;\n    }\n    // eslint-disable-next-line camelcase\n    if (!node.$_absolutePath) {\n        // eslint-disable-next-line camelcase\n        node.$_absolutePath = optimizedPath.slice(0, optimizedPath.index).concat(key);\n    }\n\n    parent[key] = node;\n\n    return node;\n};\n\n},{}],91:[function(require,module,exports){\nvar now = require(103);\nvar $now = require(120);\nvar $never = require(119);\n\nmodule.exports = function isAlreadyExpired(node) {\n    var exp = node.$expires;\n    return (exp != null) && (\n        exp !== $never) && (\n        exp !== $now) && (\n        exp < now());\n};\n\n},{\"103\":103,\"119\":119,\"120\":120}],92:[function(require,module,exports){\nvar now = require(103);\nvar $now = require(120);\nvar $never = require(119);\n\nmodule.exports = function isExpired(node) {\n    var exp = node.$expires;\n    return (exp != null) && (\n        exp !== $never ) && (\n        exp === $now || exp < now());\n};\n\n},{\"103\":103,\"119\":119,\"120\":120}],93:[function(require,module,exports){\nvar functionTypeof = \"function\";\n\nmodule.exports = function isFunction(func) {\n    return Boolean(func) && typeof func === functionTypeof;\n};\n\n},{}],94:[function(require,module,exports){\nvar privatePrefix = require(35);\n\n/**\n * Determined if the key passed in is an internal key.\n *\n * @param {String} x The key\n * @private\n * @returns {Boolean}\n */\nmodule.exports = function isInternalKey(x) {\n    return x === \"$size\" ||\n        x.substr(0, 2) === privatePrefix;\n};\n\n},{\"35\":35}],95:[function(require,module,exports){\nvar isObject = require(97);\n\nmodule.exports = function isJSONEnvelope(envelope) {\n    return isObject(envelope) && (\"json\" in envelope);\n};\n\n},{\"97\":97}],96:[function(require,module,exports){\nvar isArray = Array.isArray;\nvar isObject = require(97);\n\nmodule.exports = function isJSONGraphEnvelope(envelope) {\n    return isObject(envelope) && isArray(envelope.paths) && (\n        isObject(envelope.jsonGraph) ||\n        isObject(envelope.jsong) ||\n        isObject(envelope.json) ||\n        isObject(envelope.values) ||\n        isObject(envelope.value)\n    );\n};\n\n},{\"97\":97}],97:[function(require,module,exports){\nvar objTypeof = \"object\";\nmodule.exports = function isObject(value) {\n    return value !== null && typeof value === objTypeof;\n};\n\n},{}],98:[function(require,module,exports){\nvar isArray = Array.isArray;\nvar isObject = require(97);\n\nmodule.exports = function isPathValue(pathValue) {\n    return isObject(pathValue) && (\n        isArray(pathValue.path) || (\n            typeof pathValue.path === \"string\"\n        ));\n};\n\n},{\"97\":97}],99:[function(require,module,exports){\nvar objTypeof = \"object\";\nmodule.exports = function isPrimitive(value) {\n    return value == null || typeof value !== objTypeof;\n};\n\n},{}],100:[function(require,module,exports){\nvar $ref = require(118);\nvar $error = require(117);\nvar getSize = require(85);\nvar getTimestamp = require(86);\nvar isObject = require(97);\nvar isExpired = require(92);\nvar isFunction = require(93);\n\nvar wrapNode = require(114);\nvar insertNode = require(90);\nvar expireNode = require(83);\nvar replaceNode = require(107);\nvar updateNodeAncestors = require(112);\nvar reconstructPath = require(104);\n\nmodule.exports = function mergeJSONGraphNode(\n    parent, node, message, key, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var sizeOffset;\n\n    var cType, mType,\n        cIsObject, mIsObject,\n        cTimestamp, mTimestamp;\n\n    var nodeValue = node && node.value !== undefined ? node.value : node;\n\n    // If the cache and message are the same, we can probably return early:\n    // - If they're both nullsy,\n    //   - If null then the node needs to be wrapped in an atom and inserted.\n    //     This happens from whole branch merging when a leaf is just a null value\n    //     instead of being wrapped in an atom.\n    //   - If undefined then return null (previous behavior).\n    // - If they're both branches, return the branch.\n    // - If they're both edges, continue below.\n    if (nodeValue === message) {\n        // There should not be undefined values.  Those should always be\n        // wrapped in an $atom\n        if (message === null) {\n            node = wrapNode(message, undefined, message);\n            parent = updateNodeAncestors(parent, -node.$size, lru, version);\n            node = insertNode(node, parent, key, undefined, optimizedPath);\n            return node;\n        }\n\n        // The messange and cache are both undefined, therefore return null.\n        else if (message === undefined) {\n            return message;\n        }\n\n        else {\n            cIsObject = isObject(node);\n            if (cIsObject) {\n                // Is the cache node a branch? If so, return the cache branch.\n                cType = node.$type;\n                if (cType == null) {\n                    // Has the branch been introduced to the cache yet? If not,\n                    // give it a parent, key, and absolute path.\n                    if (node.$_parent == null) {\n                        insertNode(node, parent, key, version, optimizedPath);\n                    }\n                    return node;\n                }\n            }\n        }\n    } else {\n        cIsObject = isObject(node);\n        if (cIsObject) {\n            cType = node.$type;\n        }\n    }\n\n    // If the cache isn't a reference, we might be able to return early.\n    if (cType !== $ref) {\n        mIsObject = isObject(message);\n        if (mIsObject) {\n            mType = message.$type;\n        }\n        if (cIsObject && !cType) {\n            // If the cache is a branch and the message is empty or\n            // also a branch, continue with the cache branch.\n            if (message == null || (mIsObject && !mType)) {\n                return node;\n            }\n        }\n    }\n    // If the cache is a reference, we might not need to replace it.\n    else {\n        // If the cache is a reference, but the message is empty, leave the cache alone...\n        if (message == null) {\n            // ...unless the cache is an expired reference. In that case, expire\n            // the cache node and return undefined.\n            if (isExpired(node)) {\n                expireNode(node, expired, lru);\n                return void 0;\n            }\n            return node;\n        }\n        mIsObject = isObject(message);\n        if (mIsObject) {\n            mType = message.$type;\n            // If the cache and the message are both references,\n            // check if we need to replace the cache reference.\n            if (mType === $ref) {\n                if (node === message) {\n                    // If the cache and message are the same reference,\n                    // we performed a whole-branch merge of one of the\n                    // grandparents. If we've previously graphed this\n                    // reference, break early. Otherwise, continue to\n                    // leaf insertion below.\n                    if (node.$_parent != null) {\n                        return node;\n                    }\n                } else {\n\n                    cTimestamp = node.$timestamp;\n                    mTimestamp = message.$timestamp;\n\n                    // - If either the cache or message reference is expired,\n                    //   replace the cache reference with the message.\n                    // - If neither of the references are expired, compare their\n                    //   timestamps. If either of them don't have a timestamp,\n                    //   or the message's timestamp is newer, replace the cache\n                    //   reference with the message reference.\n                    // - If the message reference is older than the cache\n                    //   reference, short-circuit.\n                    if (!isExpired(node) && !isExpired(message) && mTimestamp < cTimestamp) {\n                        return void 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.\n    if (cType && mIsObject && !mType) {\n        return insertNode(replaceNode(node, message, parent, key, lru, replacedPaths), parent, key, undefined, optimizedPath);\n    }\n    // If the message is a sentinel or primitive, insert it into the cache.\n    else if (mType || !mIsObject) {\n        // If the cache and the message are the same value, we branch-merged one\n        // of the message's ancestors. If this is the first time we've seen this\n        // leaf, give the message a $size and $type, attach its graph pointers,\n        // and update the cache sizes and versions.\n\n        if (mType === $error && isFunction(errorSelector)) {\n            message = errorSelector(reconstructPath(requestedPath, key), message);\n            mType = message.$type || mType;\n        }\n\n        if (mType && node === message) {\n            if (node.$_parent == null) {\n                node = wrapNode(node, mType, node.value);\n                parent = updateNodeAncestors(parent, -node.$size, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n        // If the cache and message are different, the cache value is expired,\n        // or the message is a primitive, replace the cache with the message value.\n        // If the message is a sentinel, clone and maintain its type.\n        // If the message is a primitive value, wrap it in an atom.\n        else {\n            var isDistinct = true;\n            // If the cache is a branch, but the message is a leaf, replace the\n            // cache branch with the message leaf.\n            if ((cType && !isExpired(node)) || !cIsObject) {\n                // Compare the current cache value with the new value. If either of\n                // them don't have a timestamp, or the message's timestamp is newer,\n                // replace the cache value with the message value. If a comparator\n                // is specified, the comparator takes precedence over timestamps.\n                //\n                // Comparing either Number or undefined to undefined always results in false.\n                isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n\n                // If at least one of the cache/message are sentinels, compare them.\n                if (isDistinct && (cType || mType) && isFunction(comparator)) {\n                    isDistinct = !comparator(nodeValue, message, optimizedPath.slice(0, optimizedPath.index));\n                }\n            }\n            if (isDistinct) {\n                message = wrapNode(message, mType, mType ? message.value : message);\n                sizeOffset = getSize(node) - getSize(message);\n                node = replaceNode(node, message, parent, key, lru, replacedPaths);\n                parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n                node = insertNode(node, parent, key, version, optimizedPath);\n            }\n        }\n\n        // Promote the message edge in the LRU.\n        if (isExpired(node)) {\n            expireNode(node, expired, lru);\n        }\n    }\n    else if (node == null) {\n        node = insertNode({}, parent, key, undefined, optimizedPath);\n    }\n\n    return node;\n};\n\n},{\"104\":104,\"107\":107,\"112\":112,\"114\":114,\"117\":117,\"118\":118,\"83\":83,\"85\":85,\"86\":86,\"90\":90,\"92\":92,\"93\":93,\"97\":97}],101:[function(require,module,exports){\nvar $ref = require(118);\nvar $error = require(117);\nvar getType = require(87);\nvar getSize = require(85);\nvar getTimestamp = require(86);\n\nvar isExpired = require(92);\nvar isPrimitive = require(99);\nvar isFunction = require(93);\n\nvar wrapNode = require(114);\nvar expireNode = require(83);\nvar insertNode = require(90);\nvar replaceNode = require(107);\nvar updateNodeAncestors = require(112);\nvar updateBackReferenceVersions = require(111);\nvar reconstructPath = require(104);\n\nmodule.exports = function mergeValueOrInsertBranch(\n    parent, node, key, value,\n    branch, reference, requestedPath, optimizedPath,\n    version, expired, lru, comparator, errorSelector, replacedPaths) {\n\n    var type = getType(node, reference);\n\n    if (branch || reference) {\n        if (type && isExpired(node)) {\n            type = \"expired\";\n            expireNode(node, expired, lru);\n        }\n        if ((type && type !== $ref) || isPrimitive(node)) {\n            node = replaceNode(node, {}, parent, key, lru, replacedPaths);\n            node = insertNode(node, parent, key, version, optimizedPath);\n            node = updateBackReferenceVersions(node, version);\n        }\n    } else {\n        var message = value;\n        var mType = getType(message);\n        // Compare the current cache value with the new value. If either of\n        // them don't have a timestamp, or the message's timestamp is newer,\n        // replace the cache value with the message value. If a comparator\n        // is specified, the comparator takes precedence over timestamps.\n        //\n        // Comparing either Number or undefined to undefined always results in false.\n        var isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;\n        // If at least one of the cache/message are sentinels, compare them.\n        if ((type || mType) && isFunction(comparator)) {\n            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPath.index));\n        }\n        if (isDistinct) {\n\n            if (mType === $error && isFunction(errorSelector)) {\n                message = errorSelector(reconstructPath(requestedPath, key), message);\n                mType = message.$type || mType;\n            }\n\n            message = wrapNode(message, mType, mType ? message.value : message);\n\n            var sizeOffset = getSize(node) - getSize(message);\n\n            node = replaceNode(node, message, parent, key, lru, replacedPaths);\n            parent = updateNodeAncestors(parent, sizeOffset, lru, version);\n            node = insertNode(node, parent, key, version, optimizedPath);\n        }\n    }\n\n    return node;\n};\n\n},{\"104\":104,\"107\":107,\"111\":111,\"112\":112,\"114\":114,\"117\":117,\"118\":118,\"83\":83,\"85\":85,\"86\":86,\"87\":87,\"90\":90,\"92\":92,\"93\":93,\"99\":99}],102:[function(require,module,exports){\nmodule.exports = function noop() {};\n\n},{}],103:[function(require,module,exports){\nmodule.exports = Date.now;\n\n},{}],104:[function(require,module,exports){\n/**\n * Reconstructs the path for the current key, from currentPath (requestedPath)\n * state maintained during set/merge walk operations.\n *\n * During the walk, since the requestedPath array is updated after we attempt to\n * merge/insert nodes during a walk (it reflects the inserted node's parent branch)\n * we need to reconstitute a path from it.\n *\n * @param  {Array} currentPath The current requestedPath state, during the walk\n * @param  {String} key        The current key value, during the walk\n * @return {Array} A new array, with the path which represents the node we're about\n * to insert\n */\nmodule.exports = function reconstructPath(currentPath, key) {\n\n    var path = currentPath.slice(0, currentPath.depth);\n    path[path.length] = key;\n\n    return path;\n};\n\n},{}],105:[function(require,module,exports){\nvar $ref = require(118);\nvar splice = require(42);\nvar isObject = require(97);\nvar unlinkBackReferences = require(109);\nvar unlinkForwardReference = require(110);\n\nmodule.exports = function removeNode(node, parent, key, lru) {\n    if (isObject(node)) {\n        var type = node.$type;\n        if (type) {\n            if (type === $ref) {\n                unlinkForwardReference(node);\n            }\n            splice(lru, node);\n        }\n        unlinkBackReferences(node);\n        // eslint-disable-next-line camelcase\n        parent[key] = node.$_parent = void 0;\n        return true;\n    }\n    return false;\n};\n\n},{\"109\":109,\"110\":110,\"118\":118,\"42\":42,\"97\":97}],106:[function(require,module,exports){\nvar hasOwn = require(88);\nvar prefix = require(37);\nvar removeNode = require(105);\n\nmodule.exports = function removeNodeAndDescendants(node, parent, key, lru, mergeContext) {\n    if (removeNode(node, parent, key, lru)) {\n        if (node.$type !== undefined && mergeContext && node.$_absolutePath) {\n            mergeContext.hasInvalidatedResult = true;\n        }\n\n        if (node.$type == null) {\n            for (var key2 in node) {\n                if (key2[0] !== prefix && hasOwn(node, key2)) {\n                    removeNodeAndDescendants(node[key2], node, key2, lru, mergeContext);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n},{\"105\":105,\"37\":37,\"88\":88}],107:[function(require,module,exports){\nvar isObject = require(97);\nvar transferBackReferences = require(108);\nvar removeNodeAndDescendants = require(106);\n\nmodule.exports = function replaceNode(node, replacement, parent, key, lru, mergeContext) {\n    if (node === replacement) {\n        return node;\n    } else if (isObject(node)) {\n        transferBackReferences(node, replacement);\n        removeNodeAndDescendants(node, parent, key, lru, mergeContext);\n    }\n\n    parent[key] = replacement;\n    return replacement;\n};\n\n},{\"106\":106,\"108\":108,\"97\":97}],108:[function(require,module,exports){\nvar __ref = require(36);\n\nmodule.exports = function transferBackReferences(fromNode, destNode) {\n    // eslint-disable-next-line camelcase\n    var fromNodeRefsLength = fromNode.$_refsLength || 0,\n        // eslint-disable-next-line camelcase\n        destNodeRefsLength = destNode.$_refsLength || 0,\n        i = -1;\n    while (++i < fromNodeRefsLength) {\n        var ref = fromNode[__ref + i];\n        if (ref !== void 0) {\n            // eslint-disable-next-line camelcase\n            ref.$_context = destNode;\n            destNode[__ref + (destNodeRefsLength + i)] = ref;\n            fromNode[__ref + i] = void 0;\n        }\n    }\n    // eslint-disable-next-line camelcase\n    destNode.$_refsLength = fromNodeRefsLength + destNodeRefsLength;\n    // eslint-disable-next-line camelcase\n    fromNode.$_refsLength = void 0;\n    return destNode;\n};\n\n},{\"36\":36}],109:[function(require,module,exports){\nvar __ref = require(36);\n\nmodule.exports = function unlinkBackReferences(node) {\n    // eslint-disable-next-line camelcase\n    var i = -1, n = node.$_refsLength || 0;\n    while (++i < n) {\n        var ref = node[__ref + i];\n        if (ref != null) {\n            // eslint-disable-next-line camelcase\n            ref.$_context = ref.$_refIndex = node[__ref + i] = void 0;\n        }\n    }\n    // eslint-disable-next-line camelcase\n    node.$_refsLength = void 0;\n    return node;\n};\n\n},{\"36\":36}],110:[function(require,module,exports){\nvar __ref = require(36);\n\nmodule.exports = function unlinkForwardReference(reference) {\n    // eslint-disable-next-line camelcase\n    var destination = reference.$_context;\n    if (destination) {\n        // eslint-disable-next-line camelcase\n        var i = (reference.$_refIndex || 0) - 1,\n            // eslint-disable-next-line camelcase\n            n = (destination.$_refsLength || 0) - 1;\n        while (++i <= n) {\n            destination[__ref + i] = destination[__ref + (i + 1)];\n        }\n        // eslint-disable-next-line camelcase\n        destination.$_refsLength = n;\n        // eslint-disable-next-line camelcase\n        reference.$_refIndex = reference.$_context = destination = void 0;\n    }\n    return reference;\n};\n\n},{\"36\":36}],111:[function(require,module,exports){\nvar __ref = require(36);\n\nmodule.exports = function updateBackReferenceVersions(nodeArg, version) {\n    var stack = [nodeArg];\n    var count = 0;\n    do {\n        var node = stack[count];\n        // eslint-disable-next-line camelcase\n        if (node && node.$_version !== version) {\n            // eslint-disable-next-line camelcase\n            node.$_version = version;\n            // eslint-disable-next-line camelcase\n            stack[count++] = node.$_parent;\n            var i = -1;\n            // eslint-disable-next-line camelcase\n            var n = node.$_refsLength || 0;\n            while (++i < n) {\n                stack[count++] = node[__ref + i];\n            }\n        }\n    } while (--count > -1);\n    return nodeArg;\n};\n\n},{\"36\":36}],112:[function(require,module,exports){\nvar removeNode = require(105);\nvar updateBackReferenceVersions = require(111);\n\nmodule.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {\n    var child = nodeArg;\n    do {\n        var node = child.$_parent;\n        var size = child.$size = (child.$size || 0) - offset;\n        if (size <= 0 && node != null) {\n            removeNode(child, node, child.$_key, lru);\n        } else if (child.$_version !== version) {\n            updateBackReferenceVersions(child, version);\n        }\n        child = node;\n    } while (child);\n    return nodeArg;\n};\n\n},{\"105\":105,\"111\":111}],113:[function(require,module,exports){\nvar isArray = Array.isArray;\nvar isPathValue = require(98);\nvar isJSONGraphEnvelope = require(96);\nvar isJSONEnvelope = require(95);\nvar pathSyntax = require(134);\n\n/**\n *\n * @param {Object} allowedInput - allowedInput is a map of input styles\n * that are allowed\n * @private\n */\nmodule.exports = function validateInput(args, allowedInput, method) {\n    for (var i = 0, len = args.length; i < len; ++i) {\n        var arg = args[i];\n        var valid = false;\n\n        // Path\n        if (isArray(arg) && allowedInput.path) {\n            valid = true;\n        }\n\n        // Path Syntax\n        else if (typeof arg === \"string\" && allowedInput.pathSyntax) {\n            valid = true;\n        }\n\n        // Path Value\n        else if (isPathValue(arg) && allowedInput.pathValue) {\n            arg.path = pathSyntax.fromPath(arg.path);\n            valid = true;\n        }\n\n        // jsonGraph {jsonGraph: { ... }, paths: [ ... ]}\n        else if (isJSONGraphEnvelope(arg) && allowedInput.jsonGraph) {\n            valid = true;\n        }\n\n        // json env {json: {...}}\n        else if (isJSONEnvelope(arg) && allowedInput.json) {\n            valid = true;\n        }\n\n        // selector functions\n        else if (typeof arg === \"function\" &&\n                 i + 1 === len &&\n                 allowedInput.selector) {\n            valid = true;\n        }\n\n        if (!valid) {\n            return new Error(\"Unrecognized argument \" + (typeof arg) + \" [\" + String(arg) + \"] \" + \"to Model#\" + method + \"\");\n        }\n    }\n    return true;\n};\n\n},{\"134\":134,\"95\":95,\"96\":96,\"98\":98}],114:[function(require,module,exports){\nvar now = require(103);\nvar expiresNow = require(120);\n\nvar atomSize = 50;\n\nvar clone = require(80);\nvar isArray = Array.isArray;\nvar getSize = require(85);\nvar getExpires = require(84);\nvar atomType = require(116);\n\nmodule.exports = function wrapNode(nodeArg, typeArg, value) {\n\n    var size = 0;\n    var node = nodeArg;\n    var type = typeArg;\n\n    if (type) {\n        var modelCreated = node.$_modelCreated;\n        node = clone(node);\n        size = getSize(node);\n        node.$type = type;\n        // eslint-disable-next-line camelcase\n        node.$_prev = undefined;\n        // eslint-disable-next-line camelcase\n        node.$_next = undefined;\n        // eslint-disable-next-line camelcase\n        node.$_modelCreated = modelCreated || false;\n    } else {\n        node = {\n            $type: atomType,\n            value: value,\n            // eslint-disable-next-line camelcase\n            $_prev: undefined,\n            // eslint-disable-next-line camelcase\n            $_next: undefined,\n            // eslint-disable-next-line camelcase\n            $_modelCreated: true\n        };\n    }\n\n    if (value == null) {\n        size = atomSize + 1;\n    } else if (size == null || size <= 0) {\n        switch (typeof value) {\n            case \"object\":\n                if (isArray(value)) {\n                    size = atomSize + value.length;\n                } else {\n                    size = atomSize + 1;\n                }\n                break;\n            case \"string\":\n                size = atomSize + value.length;\n                break;\n            default:\n                size = atomSize + 1;\n                break;\n        }\n    }\n\n    var expires = getExpires(node);\n\n    if (typeof expires === \"number\" && expires < expiresNow) {\n        node.$expires = now() + (expires * -1);\n    }\n\n    node.$size = size;\n\n    return node;\n};\n\n},{\"103\":103,\"116\":116,\"120\":120,\"80\":80,\"84\":84,\"85\":85}],115:[function(require,module,exports){\n/**\n * FromEsObserverAdapter is an adpater from an ES Observer to an Rx 2 Observer\n * @constructor FromEsObserverAdapter\n*/\nfunction FromEsObserverAdapter(esObserver) {\n    this.esObserver = esObserver;\n}\n\nFromEsObserverAdapter.prototype = {\n    onNext: function onNext(value) {\n        if (typeof this.esObserver.next === \"function\") {\n            this.esObserver.next(value);\n        }\n    },\n    onError: function onError(error) {\n        if (typeof this.esObserver.error === \"function\") {\n            this.esObserver.error(error);\n        }\n    },\n    onCompleted: function onCompleted() {\n        if (typeof this.esObserver.complete === \"function\") {\n            this.esObserver.complete();\n        }\n    }\n};\n\n/**\n * ToEsSubscriptionAdapter is an adpater from the Rx 2 subscription to the ES subscription\n * @constructor ToEsSubscriptionAdapter\n*/\nfunction ToEsSubscriptionAdapter(subscription) {\n    this.subscription = subscription;\n}\n\nToEsSubscriptionAdapter.prototype.unsubscribe = function unsubscribe() {\n    this.subscription.dispose();\n};\n\n\nfunction toEsObservable(_self) {\n    return {\n        subscribe: function subscribe(observer) {\n            return new ToEsSubscriptionAdapter(_self.subscribe(new FromEsObserverAdapter(observer)));\n        }\n    };\n}\n\nmodule.exports = toEsObservable;\n\n},{}],116:[function(require,module,exports){\nmodule.exports = \"atom\";\n\n},{}],117:[function(require,module,exports){\nmodule.exports = \"error\";\n\n},{}],118:[function(require,module,exports){\nmodule.exports = \"ref\";\n\n},{}],119:[function(require,module,exports){\nmodule.exports = 1;\n\n},{}],120:[function(require,module,exports){\nmodule.exports = 0;\n\n},{}],121:[function(require,module,exports){\n\"use strict\";\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = require(122);\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n\n},{\"122\":122}],122:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\nvar BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],123:[function(require,module,exports){\n\"use strict\";\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = require(124);\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n\n},{\"124\":124}],124:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],125:[function(require,module,exports){\n'use strict';\nvar request = require(129);\nvar buildQueryObject = require(126);\nvar isArray = Array.isArray;\n\nfunction simpleExtend(obj, obj2) {\n  var prop;\n  for (prop in obj2) {\n    obj[prop] = obj2[prop];\n  }\n  return obj;\n}\n\nfunction XMLHttpSource(jsongUrl, config) {\n  this._jsongUrl = jsongUrl;\n  if (typeof config === 'number') {\n    var newConfig = {\n      timeout: config\n    };\n    config = newConfig;\n  }\n  this._config = simpleExtend({\n    timeout: 15000,\n    headers: {}\n  }, config || {});\n}\n\nXMLHttpSource.prototype = {\n  // because javascript\n  constructor: XMLHttpSource,\n  /**\n   * buildQueryObject helper\n   */\n  buildQueryObject: buildQueryObject,\n\n  /**\n   * @inheritDoc DataSource#get\n   */\n  get: function httpSourceGet(pathSet) {\n    var method = 'GET';\n    var queryObject = this.buildQueryObject(this._jsongUrl, method, {\n      paths: pathSet,\n      method: 'get'\n    });\n    var config = simpleExtend(queryObject, this._config);\n    // pass context for onBeforeRequest callback\n    var context = this;\n    return request(method, config, context);\n  },\n\n  /**\n   * @inheritDoc DataSource#set\n   */\n  set: function httpSourceSet(jsongEnv) {\n    var method = 'POST';\n    var queryObject = this.buildQueryObject(this._jsongUrl, method, {\n      jsonGraph: jsongEnv,\n      method: 'set'\n    });\n    var config = simpleExtend(queryObject, this._config);\n    config.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n    \n    // pass context for onBeforeRequest callback\n    var context = this;\n    return request(method, config, context);\n\n  },\n\n  /**\n   * @inheritDoc DataSource#call\n   */\n  call: function httpSourceCall(callPath, args, pathSuffix, paths) {\n    // arguments defaults\n    args = args || [];\n    pathSuffix = pathSuffix || [];\n    paths = paths || [];\n\n    var method = 'POST';\n    var queryData = [];\n    queryData.push('method=call');\n    queryData.push('callPath=' + encodeURIComponent(JSON.stringify(callPath)));\n    queryData.push('arguments=' + encodeURIComponent(JSON.stringify(args)));\n    queryData.push('pathSuffixes=' + encodeURIComponent(JSON.stringify(pathSuffix)));\n    queryData.push('paths=' + encodeURIComponent(JSON.stringify(paths)));\n\n    var queryObject = this.buildQueryObject(this._jsongUrl, method, queryData.join('&'));\n    var config = simpleExtend(queryObject, this._config);\n    config.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n    \n    // pass context for onBeforeRequest callback\n    var context = this;\n    return request(method, config, context);\n  }\n};\n// ES6 modules\nXMLHttpSource.XMLHttpSource = XMLHttpSource;\nXMLHttpSource['default'] = XMLHttpSource;\n// commonjs\nmodule.exports = XMLHttpSource;\n\n},{\"126\":126,\"129\":129}],126:[function(require,module,exports){\n'use strict';\nmodule.exports = function buildQueryObject(url, method, queryData) {\n  var qData = [];\n  var keys;\n  var data = {url: url};\n  var isQueryParamUrl = url.indexOf('?') !== -1;\n  var startUrl = (isQueryParamUrl) ? '&' : '?';\n\n  if (typeof queryData === 'string') {\n    qData.push(queryData);\n  } else {\n\n    keys = Object.keys(queryData);\n    keys.forEach(function (k) {\n      var value = (typeof queryData[k] === 'object') ? JSON.stringify(queryData[k]) : queryData[k];\n      qData.push(k + '=' + encodeURIComponent(value));\n    });\n  }\n\n  if (method === 'GET') {\n    data.url += startUrl + qData.join('&');\n  } else {\n    data.data = qData.join('&');\n  }\n\n  return data;\n};\n\n},{}],127:[function(require,module,exports){\n(function (global){\n'use strict';\n// Get CORS support even for older IE\nmodule.exports = function getCORSRequest() {\n    var xhr = new global.XMLHttpRequest();\n    if ('withCredentials' in xhr) {\n        return xhr;\n    } else if (!!global.XDomainRequest) {\n        return new XDomainRequest();\n    } else {\n        throw new Error('CORS is not supported by your browser');\n    }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],128:[function(require,module,exports){\n(function (global){\n'use strict';\nmodule.exports = function getXMLHttpRequest() {\n  var progId,\n    progIds,\n    i;\n  if (global.XMLHttpRequest) {\n    return new global.XMLHttpRequest();\n  } else {\n    try {\n    progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n    for (i = 0; i < 3; i++) {\n      try {\n        progId = progIds[i];\n        if (new global.ActiveXObject(progId)) {\n          break;\n        }\n      } catch(e) { }\n    }\n    return new global.ActiveXObject(progId);\n    } catch (e) {\n    throw new Error('XMLHttpRequest is not supported by your browser');\n    }\n  }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],129:[function(require,module,exports){\n'use strict';\nvar getXMLHttpRequest = require(128);\nvar getCORSRequest = require(127);\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar noop = function() {};\n\nfunction Observable() {}\n\nObservable.create = function(subscribe) {\n  var o = new Observable();\n\n  o.subscribe = function(onNext, onError, onCompleted) {\n\n    var observer;\n    var disposable;\n\n    if (typeof onNext === 'function') {\n        observer = {\n            onNext: onNext,\n            onError: (onError || noop),\n            onCompleted: (onCompleted || noop)\n        };\n    } else {\n        observer = onNext;\n    }\n\n    disposable = subscribe(observer);\n\n    if (typeof disposable === 'function') {\n      return {\n        dispose: disposable\n      };\n    } else {\n      return disposable;\n    }\n  };\n\n  return o;\n};\n\nfunction request(method, options, context) {\n  return Observable.create(function requestObserver(observer) {\n\n    var config = {\n      method: method || 'GET',\n      crossDomain: false,\n      async: true,\n      headers: {},\n      responseType: 'json'\n    };\n\n    var xhr,\n      isDone,\n      headers,\n      header,\n      prop;\n\n    for (prop in options) {\n      if (hasOwnProp.call(options, prop)) {\n        config[prop] = options[prop];\n      }\n    }\n\n    // Add request with Headers\n    if (!config.crossDomain && !config.headers['X-Requested-With']) {\n      config.headers['X-Requested-With'] = 'XMLHttpRequest';\n    }\n\n    // allow the user to mutate the config open\n    if (context.onBeforeRequest != null) {\n      context.onBeforeRequest(config);\n    }\n\n    // create xhr\n    try {\n      xhr = config.crossDomain ? getCORSRequest() : getXMLHttpRequest();\n    } catch (err) {\n      observer.onError(err);\n    }\n    try {\n      // Takes the url and opens the connection\n      if (config.user) {\n        xhr.open(config.method, config.url, config.async, config.user, config.password);\n      } else {\n        xhr.open(config.method, config.url, config.async);\n      }\n\n      // Sets timeout information\n      xhr.timeout = config.timeout;\n\n      // Anything but explicit false results in true.\n      xhr.withCredentials = config.withCredentials !== false;\n\n      // Fills the request headers\n      headers = config.headers;\n      for (header in headers) {\n        if (hasOwnProp.call(headers, header)) {\n          xhr.setRequestHeader(header, headers[header]);\n        }\n      }\n\n      if (config.responseType) {\n        try {\n          xhr.responseType = config.responseType;\n        } catch (e) {\n          // WebKit added support for the json responseType value on 09/03/2013\n          // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are\n          // known to throw when setting the value \"json\" as the response type. Other older\n          // browsers implementing the responseType\n          //\n          // The json response type can be ignored if not supported, because JSON payloads are\n          // parsed on the client-side regardless.\n          if (config.responseType !== 'json') {\n            throw e;\n          }\n        }\n      }\n\n      xhr.onreadystatechange = function onreadystatechange(e) {\n        // Complete\n        if (xhr.readyState === 4) {\n          if (!isDone) {\n            isDone = true;\n            onXhrLoad(observer, xhr, e);\n          }\n        }\n      };\n\n      // Timeout\n      xhr.ontimeout = function ontimeout(e) {\n        if (!isDone) {\n          isDone = true;\n          onXhrError(observer, xhr, 'timeout error', e);\n        }\n      };\n\n      // Send Request\n      xhr.send(config.data);\n\n    } catch (e) {\n      observer.onError(e);\n    }\n    // Dispose\n    return function dispose() {\n      // Doesn't work in IE9\n      if (!isDone && xhr.readyState !== 4) {\n        isDone = true;\n        xhr.abort();\n      }\n    };//Dispose\n  });\n}\n\n/*\n * General handling of ultimate failure (after appropriate retries)\n */\nfunction _handleXhrError(observer, textStatus, errorThrown) {\n  // IE9: cross-domain request may be considered errors\n  if (!errorThrown) {\n    errorThrown = new Error(textStatus);\n  }\n\n  observer.onError(errorThrown);\n}\n\nfunction onXhrLoad(observer, xhr, e) {\n  var responseData,\n    responseObject,\n    responseType;\n\n  // If there's no observer, the request has been (or is being) cancelled.\n  if (xhr && observer) {\n    responseType = xhr.responseType;\n    // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n    // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)\n    responseData = ('response' in xhr) ? xhr.response : xhr.responseText;\n\n    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n    var status = (xhr.status === 1223) ? 204 : xhr.status;\n\n    if (status >= 200 && status <= 399) {\n      try {\n        if (responseType !== 'json') {\n          responseData = JSON.parse(responseData || '');\n        }\n        if (typeof responseData === 'string') {\n          responseData = JSON.parse(responseData || '');\n        }\n      } catch (e) {\n        _handleXhrError(observer, 'invalid json', e);\n      }\n      observer.onNext(responseData);\n      observer.onCompleted();\n      return;\n\n    } else if (status === 401 || status === 403 || status === 407) {\n\n      return _handleXhrError(observer, responseData);\n\n    } else if (status === 410) {\n      // TODO: Retry ?\n      return _handleXhrError(observer, responseData);\n\n    } else if (status === 408 || status === 504) {\n      // TODO: Retry ?\n      return _handleXhrError(observer, responseData);\n\n    } else {\n\n      return _handleXhrError(observer, responseData || ('Response code ' + status));\n\n    }//if\n  }//if\n}//onXhrLoad\n\nfunction onXhrError(observer, xhr, status, e) {\n  _handleXhrError(observer, status || xhr.statusText || 'request error', e);\n}\n\nmodule.exports = request;\n\n},{\"127\":127,\"128\":128}],130:[function(require,module,exports){\nvar pathSyntax = require(134);\n\nfunction sentinel(type, value, props) {\n    var copy = Object.create(null);\n    if (props != null) {\n        for(var key in props) {\n            copy[key] = props[key];\n        }\n        \n        copy[\"$type\"] = type;\n        copy.value = value;\n        return copy;\n    }\n    else {\n        return { $type: type, value: value };\n    }    \n}\n\nmodule.exports = {\n    ref: function ref(path, props) {\n        return sentinel(\"ref\", pathSyntax.fromPath(path), props);\n    },\n    atom: function atom(value, props) {\n        return sentinel(\"atom\", value, props);        \n    },\n    undefined: function() {\n        return sentinel(\"atom\");\n    },    \n    error: function error(errorValue, props) {\n        return sentinel(\"error\", errorValue, props);        \n    },\n    pathValue: function pathValue(path, value) {\n        return { path: pathSyntax.fromPath(path), value: value };\n    },\n    pathInvalidation: function pathInvalidation(path) {\n        return { path: pathSyntax.fromPath(path), invalidated: true };\n    }    \n};\n\n},{\"134\":134}],131:[function(require,module,exports){\nmodule.exports = {\n    integers: 'integers',\n    ranges: 'ranges',\n    keys: 'keys'\n};\n\n},{}],132:[function(require,module,exports){\nvar TokenTypes = {\n    token: 'token',\n    dotSeparator: '.',\n    commaSeparator: ',',\n    openingBracket: '[',\n    closingBracket: ']',\n    openingBrace: '{',\n    closingBrace: '}',\n    escape: '\\\\',\n    space: ' ',\n    colon: ':',\n    quote: 'quote',\n    unknown: 'unknown'\n};\n\nmodule.exports = TokenTypes;\n\n},{}],133:[function(require,module,exports){\nmodule.exports = {\n    indexer: {\n        nested: 'Indexers cannot be nested.',\n        needQuotes: 'unquoted indexers must be numeric.',\n        empty: 'cannot have empty indexers.',\n        leadingDot: 'Indexers cannot have leading dots.',\n        leadingComma: 'Indexers cannot have leading comma.',\n        requiresComma: 'Indexers require commas between indexer args.',\n        routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'\n    },\n    range: {\n        precedingNaN: 'ranges must be preceded by numbers.',\n        suceedingNaN: 'ranges must be suceeded by numbers.'\n    },\n    routed: {\n        invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'\n    },\n    quote: {\n        empty: 'cannot have empty quoted keys.',\n        illegalEscape: 'Invalid escape character.  Only quotes are escapable.'\n    },\n    unexpectedToken: 'Unexpected token.',\n    invalidIdentifier: 'Invalid Identifier.',\n    invalidPath: 'Please provide a valid path.',\n    throwError: function(err, tokenizer, token) {\n        if (token) {\n            throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;\n        }\n        throw err + ' -- ' + tokenizer.parseString;\n    }\n};\n\n\n},{}],134:[function(require,module,exports){\nvar Tokenizer = require(140);\nvar head = require(135);\nvar RoutedTokens = require(131);\n\nvar parser = function parser(string, extendedRules) {\n    return head(new Tokenizer(string, extendedRules));\n};\n\nmodule.exports = parser;\n\n// Constructs the paths from paths / pathValues that have strings.\n// If it does not have a string, just moves the value into the return\n// results.\nparser.fromPathsOrPathValues = function(paths, ext) {\n    if (!paths) {\n        return [];\n    }\n\n    var out = [];\n    for (var i = 0, len = paths.length; i < len; i++) {\n\n        // Is the path a string\n        if (typeof paths[i] === 'string') {\n            out[i] = parser(paths[i], ext);\n        }\n\n        // is the path a path value with a string value.\n        else if (typeof paths[i].path === 'string') {\n            out[i] = {\n                path: parser(paths[i].path, ext), value: paths[i].value\n            };\n        }\n\n        // just copy it over.\n        else {\n            out[i] = paths[i];\n        }\n    }\n\n    return out;\n};\n\n// If the argument is a string, this with convert, else just return\n// the path provided.\nparser.fromPath = function(path, ext) {\n    if (!path) {\n        return [];\n    }\n\n    if (typeof path === 'string') {\n        return parser(path, ext);\n    }\n\n    return path;\n};\n\n// Potential routed tokens.\nparser.RoutedTokens = RoutedTokens;\n\n},{\"131\":131,\"135\":135,\"140\":140}],135:[function(require,module,exports){\nvar TokenTypes = require(132);\nvar E = require(133);\nvar indexer = require(136);\n\n/**\n * The top level of the parse tree.  This returns the generated path\n * from the tokenizer.\n */\nmodule.exports = function head(tokenizer) {\n    var token = tokenizer.next();\n    var state = {};\n    var out = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n                var first = +token.token[0];\n                if (!isNaN(first)) {\n                    E.throwError(E.invalidIdentifier, tokenizer);\n                }\n                out[out.length] = token.token;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (out.length === 0) {\n                    E.throwError(E.unexpectedToken, tokenizer);\n                }\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes.space:\n                // NOTE: Spaces at the top level are allowed.\n                // titlesById  .summary is a valid path.\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes.openingBracket:\n                indexer(tokenizer, token, state, out);\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (out.length === 0) {\n        E.throwError(E.invalidPath, tokenizer);\n    }\n\n    return out;\n};\n\n\n},{\"132\":132,\"133\":133,\"136\":136}],136:[function(require,module,exports){\nvar TokenTypes = require(132);\nvar E = require(133);\nvar idxE = E.indexer;\nvar range = require(138);\nvar quote = require(137);\nvar routed = require(139);\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nmodule.exports = function indexer(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var done = false;\n    var allowedMaxLength = 1;\n    var routedIndexer = false;\n\n    // State variables\n    state.indexer = [];\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n            case TokenTypes.quote:\n\n                // ensures that token adders are properly delimited.\n                if (state.indexer.length === allowedMaxLength) {\n                    E.throwError(idxE.requiresComma, tokenizer);\n                }\n                break;\n        }\n\n        switch (token.type) {\n            // Extended syntax case\n            case TokenTypes.openingBrace:\n                routedIndexer = true;\n                routed(tokenizer, token, state, out);\n                break;\n\n\n            case TokenTypes.token:\n                var t = +token.token;\n                if (isNaN(t)) {\n                    E.throwError(idxE.needQuotes, tokenizer);\n                }\n                state.indexer[state.indexer.length] = t;\n                break;\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (!state.indexer.length) {\n                    E.throwError(idxE.leadingDot, tokenizer);\n                }\n                range(tokenizer, token, state, out);\n                break;\n\n            // Spaces do nothing.\n            case TokenTypes.space:\n                break;\n\n            case TokenTypes.closingBracket:\n                done = true;\n                break;\n\n\n            // The quotes require their own tree due to what can be in it.\n            case TokenTypes.quote:\n                quote(tokenizer, token, state, out);\n                break;\n\n\n            // Its time to decend the parse tree.\n            case TokenTypes.openingBracket:\n                E.throwError(idxE.nested, tokenizer);\n                break;\n\n            case TokenTypes.commaSeparator:\n                ++allowedMaxLength;\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n                break;\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (state.indexer.length === 0) {\n        E.throwError(idxE.empty, tokenizer);\n    }\n\n    if (state.indexer.length > 1 && routedIndexer) {\n        E.throwError(idxE.routedTokens, tokenizer);\n    }\n\n    // Remember, if an array of 1, keySets will be generated.\n    if (state.indexer.length === 1) {\n        state.indexer = state.indexer[0];\n    }\n\n    out[out.length] = state.indexer;\n\n    // Clean state.\n    state.indexer = undefined;\n};\n\n\n},{\"132\":132,\"133\":133,\"137\":137,\"138\":138,\"139\":139}],137:[function(require,module,exports){\nvar TokenTypes = require(132);\nvar E = require(133);\nvar quoteE = E.quote;\n\n/**\n * quote is all the parse tree in between quotes.  This includes the only\n * escaping logic.\n *\n * parse-tree:\n * <opening-quote>(.|(<escape><opening-quote>))*<opening-quote>\n */\nmodule.exports = function quote(tokenizer, openingToken, state, out) {\n    var token = tokenizer.next();\n    var innerToken = '';\n    var openingQuote = openingToken.token;\n    var escaping = false;\n    var done = false;\n\n    while (!token.done) {\n\n        switch (token.type) {\n            case TokenTypes.token:\n            case TokenTypes.space:\n\n            case TokenTypes.dotSeparator:\n            case TokenTypes.commaSeparator:\n\n            case TokenTypes.openingBracket:\n            case TokenTypes.closingBracket:\n            case TokenTypes.openingBrace:\n            case TokenTypes.closingBrace:\n                if (escaping) {\n                    E.throwError(quoteE.illegalEscape, tokenizer);\n                }\n\n                innerToken += token.token;\n                break;\n\n\n            case TokenTypes.quote:\n                // the simple case.  We are escaping\n                if (escaping) {\n                    innerToken += token.token;\n                    escaping = false;\n                }\n\n                // its not a quote that is the opening quote\n                else if (token.token !== openingQuote) {\n                    innerToken += token.token;\n                }\n\n                // last thing left.  Its a quote that is the opening quote\n                // therefore we must produce the inner token of the indexer.\n                else {\n                    done = true;\n                }\n\n                break;\n            case TokenTypes.escape:\n                escaping = true;\n                break;\n\n            default:\n                E.throwError(E.unexpectedToken, tokenizer);\n        }\n\n        // If done, leave loop\n        if (done) {\n            break;\n        }\n\n        // Keep cycling through the tokenizer.\n        token = tokenizer.next();\n    }\n\n    if (innerToken.length === 0) {\n        E.throwError(quoteE.empty, tokenizer);\n    }\n\n    state.indexer[state.indexer.length] = innerToken;\n};\n\n\n},{\"132\":132,\"133\":133}],138:[function(require,module,exports){\nvar Tokenizer = require(140);\nvar TokenTypes = require(132);\nvar E = require(133);\n\n/**\n * The indexer is all the logic that happens in between\n * the '[', opening bracket, and ']' closing bracket.\n */\nmodule.exports = function range(tokenizer, openingToken, state, out) {\n    var token = tokenizer.peek();\n    var dotCount = 1;\n    var done = false;\n    var inclusive = true;\n\n    // Grab the last token off the stack.  Must be an integer.\n    var idx = state.indexer.length - 1;\n    var from = Tokenizer.toNumber(state.indexer[idx]);\n    var to;\n\n    if (isNaN(from)) {\n        E.throwError(E.range.precedingNaN, tokenizer);\n    }\n\n    // Why is number checking so difficult in javascript.\n\n    while (!done && !token.done) {\n\n        switch (token.type) {\n\n            // dotSeparators at the top level have no meaning\n            case TokenTypes.dotSeparator:\n                if (dotCount === 3) {\n                    E.throwError(E.unexpectedToken, tokenizer);\n                }\n                ++dotCount;\n\n                if (dotCount === 3) {\n                    inclusive = false;\n                }\n                break;\n\n            case TokenTypes.token:\n                // move the tokenizer forward and save to.\n                to = Tokenizer.toNumber(tokenizer.next().token);\n\n                // throw potential error.\n                if (isNaN(to)) {\n                    E.throwError(E.range.suceedingNaN, tokenizer);\n                }\n\n                done = true;\n                break;\n\n            default:\n                done = true;\n                break;\n        }\n\n        // Keep cycling through the tokenizer.  But ranges have to peek\n        // before they go to the next token since there is no 'terminating'\n        // character.\n        if (!done) {\n            tokenizer.next();\n\n            // go to the next token without consuming.\n            token = tokenizer.peek();\n        }\n\n        // break and remove state information.\n        else {\n            break;\n        }\n    }\n\n    state.indexer[idx] = {from: from, to: inclusive ? to : to - 1};\n};\n\n\n},{\"132\":132,\"133\":133,\"140\":140}],139:[function(require,module,exports){\nvar TokenTypes = require(132);\nvar RoutedTokens = require(131);\nvar E = require(133);\nvar routedE = E.routed;\n\n/**\n * The routing logic.\n *\n * parse-tree:\n * <opening-brace><routed-token>(:<token>)<closing-brace>\n */\nmodule.exports = function routed(tokenizer, openingToken, state, out) {\n    var routeToken = tokenizer.next();\n    var named = false;\n    var name = '';\n\n    // ensure the routed token is a valid ident.\n    switch (routeToken.token) {\n        case RoutedTokens.integers:\n        case RoutedTokens.ranges:\n        case RoutedTokens.keys:\n            //valid\n            break;\n        default:\n            E.throwError(routedE.invalid, tokenizer);\n            break;\n    }\n\n    // Now its time for colon or ending brace.\n    var next = tokenizer.next();\n\n    // we are parsing a named identifier.\n    if (next.type === TokenTypes.colon) {\n        named = true;\n\n        // Get the token name.\n        next = tokenizer.next();\n        if (next.type !== TokenTypes.token) {\n            E.throwError(routedE.invalid, tokenizer);\n        }\n        name = next.token;\n\n        // move to the closing brace.\n        next = tokenizer.next();\n    }\n\n    // must close with a brace.\n\n    if (next.type === TokenTypes.closingBrace) {\n        var outputToken = {\n            type: routeToken.token,\n            named: named,\n            name: name\n        };\n        state.indexer[state.indexer.length] = outputToken;\n    }\n\n    // closing brace expected\n    else {\n        E.throwError(routedE.invalid, tokenizer);\n    }\n\n};\n\n\n},{\"131\":131,\"132\":132,\"133\":133}],140:[function(require,module,exports){\nvar TokenTypes = require(132);\nvar DOT_SEPARATOR = '.';\nvar COMMA_SEPARATOR = ',';\nvar OPENING_BRACKET = '[';\nvar CLOSING_BRACKET = ']';\nvar OPENING_BRACE = '{';\nvar CLOSING_BRACE = '}';\nvar COLON = ':';\nvar ESCAPE = '\\\\';\nvar DOUBLE_OUOTES = '\"';\nvar SINGE_OUOTES = \"'\";\nvar SPACE = \" \";\nvar SPECIAL_CHARACTERS = '\\\\\\'\"[]., ';\nvar EXT_SPECIAL_CHARACTERS = '\\\\{}\\'\"[]., :';\n\nvar Tokenizer = module.exports = function(string, ext) {\n    this._string = string;\n    this._idx = -1;\n    this._extended = ext;\n    this.parseString = '';\n};\n\nTokenizer.prototype = {\n    /**\n     * grabs the next token either from the peek operation or generates the\n     * next token.\n     */\n    next: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n\n        this._idx = nextToken.idx;\n        this._nextToken = false;\n        this.parseString += nextToken.token.token;\n\n        return nextToken.token;\n    },\n\n    /**\n     * will peak but not increment the tokenizer\n     */\n    peek: function() {\n        var nextToken = this._nextToken ?\n            this._nextToken : getNext(this._string, this._idx, this._extended);\n        this._nextToken = nextToken;\n\n        return nextToken.token;\n    }\n};\n\nTokenizer.toNumber = function toNumber(x) {\n    if (!isNaN(+x)) {\n        return +x;\n    }\n    return NaN;\n};\n\nfunction toOutput(token, type, done) {\n    return {\n        token: token,\n        done: done,\n        type: type\n    };\n}\n\nfunction getNext(string, idx, ext) {\n    var output = false;\n    var token = '';\n    var specialChars = ext ?\n        EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;\n    var done;\n\n    do {\n\n        done = idx + 1 >= string.length;\n        if (done) {\n            break;\n        }\n\n        // we have to peek at the next token\n        var character = string[idx + 1];\n\n        if (character !== undefined &&\n            specialChars.indexOf(character) === -1) {\n\n            token += character;\n            ++idx;\n            continue;\n        }\n\n        // The token to delimiting character transition.\n        else if (token.length) {\n            break;\n        }\n\n        ++idx;\n        var type;\n        switch (character) {\n            case DOT_SEPARATOR:\n                type = TokenTypes.dotSeparator;\n                break;\n            case COMMA_SEPARATOR:\n                type = TokenTypes.commaSeparator;\n                break;\n            case OPENING_BRACKET:\n                type = TokenTypes.openingBracket;\n                break;\n            case CLOSING_BRACKET:\n                type = TokenTypes.closingBracket;\n                break;\n            case OPENING_BRACE:\n                type = TokenTypes.openingBrace;\n                break;\n            case CLOSING_BRACE:\n                type = TokenTypes.closingBrace;\n                break;\n            case SPACE:\n                type = TokenTypes.space;\n                break;\n            case DOUBLE_OUOTES:\n            case SINGE_OUOTES:\n                type = TokenTypes.quote;\n                break;\n            case ESCAPE:\n                type = TokenTypes.escape;\n                break;\n            case COLON:\n                type = TokenTypes.colon;\n                break;\n            default:\n                type = TokenTypes.unknown;\n                break;\n        }\n        output = toOutput(character, type, false);\n        break;\n    } while (!done);\n\n    if (!output && token.length) {\n        output = toOutput(token, TokenTypes.token, false);\n    }\n\n    if (!output) {\n        output = {done: true};\n    }\n\n    return {\n        token: output,\n        idx: idx\n    };\n}\n\n\n\n},{\"132\":132}],141:[function(require,module,exports){\nvar toPaths = require(154);\nvar toTree = require(155);\n\nmodule.exports = function collapse(paths) {\n    var collapseMap = paths.\n        reduce(function(acc, path) {\n            var len = path.length;\n            if (!acc[len]) {\n                acc[len] = [];\n            }\n            acc[len].push(path);\n            return acc;\n        }, {});\n\n    Object.\n        keys(collapseMap).\n        forEach(function(collapseKey) {\n            collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);\n        });\n\n    return toPaths(collapseMap);\n};\n\n},{\"154\":154,\"155\":155}],142:[function(require,module,exports){\n/*eslint-disable*/\nmodule.exports = {\n    innerReferences: 'References with inner references are not allowed.',\n    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'\n};\n\n\n},{}],143:[function(require,module,exports){\nvar cloneArray = require(152);\nvar $ref = require(153).$ref;\nvar errors = require(142);\n\n/**\n * performs the simplified cache reference follow.  This\n * differs from get as there is just following and reporting,\n * not much else.\n *\n * @param {Object} cacheRoot\n * @param {Array} ref\n */\nmodule.exports = function followReference(cacheRoot, ref, maxRefFollow) {\n    var current = cacheRoot;\n    var refPath = ref;\n    var depth = -1;\n    var length = refPath.length;\n    var key, next, type;\n    var referenceCount = 0;\n\n    while (++depth < length) {\n        key = refPath[depth];\n        next = current[key];\n        type = next && next.$type;\n\n        if (!next || type && type !== $ref) {\n            current = next;\n            break;\n        }\n\n        // Show stopper exception.  This route is malformed.\n        if (type && type === $ref && depth + 1 < length) {\n            var err = new Error(errors.innerReferences);\n            err.throwToNext = true;\n            throw err;\n        }\n\n        // potentially follow reference\n        if (depth + 1 === length) {\n            if (type === $ref) {\n                depth = -1;\n                refPath = next.value;\n                length = refPath.length;\n                next = cacheRoot;\n                referenceCount++;\n            }\n\n            if (referenceCount > maxRefFollow) {\n                throw new Error(errors.circularReference);\n            }\n        }\n        current = next;\n    }\n\n    return [current, cloneArray(refPath)];\n};\n\n\n},{\"142\":142,\"152\":152,\"153\":153}],144:[function(require,module,exports){\nvar iterateKeySet = require(146);\n\n/**\n * Tests to see if the intersection should be stripped from the\n * total paths.  The only way this happens currently is if the entirety\n * of the path is contained in the tree.\n * @private\n */\nmodule.exports = function hasIntersection(tree, path, depth) {\n    var current = tree;\n    var intersects = true;\n\n    // Continue iteratively going down a path until a complex key is\n    // encountered, then recurse.\n    for (;intersects && depth < path.length; ++depth) {\n        var key = path[depth];\n        var keyType = typeof key;\n\n        // We have to iterate key set\n        if (key && keyType === 'object') {\n            var note = {};\n            var innerKey = iterateKeySet(key, note);\n            var nextDepth = depth + 1;\n\n            // Loop through the innerKeys setting the intersects flag\n            // to each result.  Break out on false.\n            do {\n                var next = current[innerKey];\n                intersects = next !== undefined;\n\n                if (intersects) {\n                    intersects = hasIntersection(next, path, nextDepth);\n                }\n                innerKey = iterateKeySet(key, note);\n            } while (intersects && !note.done);\n\n            // Since we recursed, we shall not pass any further!\n            break;\n        }\n\n        // Its a simple key, just move forward with the testing.\n        current = current[key];\n        intersects = current !== undefined;\n    }\n\n    return intersects;\n};\n\n},{\"146\":146}],145:[function(require,module,exports){\nmodule.exports = {\n    iterateKeySet: require(146),\n    toTree: require(155),\n    pathsComplementFromTree: require(150),\n    pathsComplementFromLengthTree: require(149),\n    hasIntersection: require(144),\n    toPaths: require(154),\n    collapse: require(141),\n    optimizePathSets: require(147),\n    pathCount: require(148)\n};\n\n},{\"141\":141,\"144\":144,\"146\":146,\"147\":147,\"148\":148,\"149\":149,\"150\":150,\"154\":154,\"155\":155}],146:[function(require,module,exports){\nvar isArray = Array.isArray;\n\n/**\n * Takes in a keySet and a note attempts to iterate over it.\n * If the value is a primitive, the key will be returned and the note will\n * be marked done\n * If the value is an object, then each value of the range will be returned\n * and when finished the note will be marked done.\n * If the value is an array, each value will be iterated over, if any of the\n * inner values are ranges, those will be iterated over.  When fully done,\n * the note will be marked done.\n *\n * @param {Object|Array|String|Number} keySet -\n * @param {Object} note - The non filled note\n * @returns {String|Number|undefined} - The current iteration value.\n * If undefined, then the keySet is empty\n * @public\n */\nmodule.exports = function iterateKeySet(keySet, note) {\n    if (note.isArray === undefined) {\n        initializeNote(keySet, note);\n    }\n\n    // Array iteration\n    if (note.isArray) {\n        var nextValue;\n\n        // Cycle through the array and pluck out the next value.\n        do {\n            if (note.loaded && note.rangeOffset > note.to) {\n                ++note.arrayOffset;\n                note.loaded = false;\n            }\n\n            var idx = note.arrayOffset, length = keySet.length;\n            if (idx >= length) {\n                note.done = true;\n                break;\n            }\n\n            var el = keySet[note.arrayOffset];\n            var type = typeof el;\n\n            // Inner range iteration.\n            if (type === 'object') {\n                if (!note.loaded) {\n                    initializeRange(el, note);\n                }\n\n                // Empty to/from\n                if (note.empty) {\n                    continue;\n                }\n\n                nextValue = note.rangeOffset++;\n            }\n\n            // Primitive iteration in array.\n            else {\n                ++note.arrayOffset;\n                nextValue = el;\n            }\n        } while (nextValue === undefined);\n\n        return nextValue;\n    }\n\n    // Range iteration\n    else if (note.isObject) {\n        if (!note.loaded) {\n            initializeRange(keySet, note);\n        }\n        if (note.rangeOffset > note.to) {\n            note.done = true;\n            return undefined;\n        }\n\n        return note.rangeOffset++;\n    }\n\n    // Primitive value\n    else {\n        note.done = true;\n        return keySet;\n    }\n};\n\nfunction initializeRange(key, memo) {\n    var from = memo.from = key.from || 0;\n    var to = memo.to = key.to ||\n        (typeof key.length === 'number' &&\n        memo.from + key.length - 1 || 0);\n    memo.rangeOffset = memo.from;\n    memo.loaded = true;\n    if (from > to) {\n        memo.empty = true;\n    }\n}\n\nfunction initializeNote(key, note) {\n    note.done = false;\n    var isObject = note.isObject = !!(key && typeof key === 'object');\n    note.isArray = isObject && isArray(key);\n    note.arrayOffset = 0;\n}\n\n},{}],147:[function(require,module,exports){\nvar iterateKeySet = require(146);\nvar cloneArray = require(152);\nvar catAndSlice = require(151);\nvar $types = require(153);\nvar $ref = $types.$ref;\nvar followReference = require(143);\n\n/**\n * The fastest possible optimize of paths.\n *\n * What it does:\n * - Any atom short-circuit / found value will be removed from the path.\n * - All paths will be exploded which means that collapse will need to be\n *   ran afterwords.\n * - Any missing path will be optimized as much as possible.\n */\nmodule.exports = function optimizePathSets(cache, paths, maxRefFollow) {\n    var optimized = [];\n    paths.forEach(function(p) {\n        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);\n    });\n\n    return optimized;\n};\n\n\n/**\n * optimizes one pathSet at a time.\n */\nfunction optimizePathSet(cache, cacheRoot, pathSet,\n                         depth, out, optimizedPath, maxRefFollow) {\n\n    // at missing, report optimized path.\n    if (cache === undefined) {\n        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);\n        return;\n    }\n\n    // all other sentinels are short circuited.\n    // Or we found a primitive (which includes null)\n    if (cache === null || (cache.$type && cache.$type !== $ref) ||\n            (typeof cache !== 'object')) {\n        return;\n    }\n\n    // If the reference is the last item in the path then do not\n    // continue to search it.\n    if (cache.$type === $ref && depth === pathSet.length) {\n        return;\n    }\n\n    var keySet = pathSet[depth];\n    var isKeySet = typeof keySet === 'object';\n    var nextDepth = depth + 1;\n    var iteratorNote = false;\n    var key = keySet;\n    if (isKeySet) {\n        iteratorNote = {};\n        key = iterateKeySet(keySet, iteratorNote);\n    }\n    var next, nextOptimized;\n    do {\n        next = cache[key];\n        var optimizedPathLength = optimizedPath.length;\n        if (key !== null) {\n            optimizedPath[optimizedPathLength] = key;\n        }\n\n        if (next && next.$type === $ref && nextDepth < pathSet.length) {\n            var refResults =\n                followReference(cacheRoot, next.value, maxRefFollow);\n            next = refResults[0];\n\n            // must clone to avoid the mutation from above destroying the cache.\n            nextOptimized = cloneArray(refResults[1]);\n        } else {\n            nextOptimized = optimizedPath;\n        }\n\n        optimizePathSet(next, cacheRoot, pathSet, nextDepth,\n                        out, nextOptimized, maxRefFollow);\n        optimizedPath.length = optimizedPathLength;\n\n        if (iteratorNote && !iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (iteratorNote && !iteratorNote.done);\n}\n\n\n\n},{\"143\":143,\"146\":146,\"151\":151,\"152\":152,\"153\":153}],148:[function(require,module,exports){\n\"use strict\";\n\n/**\n * Helper for getPathCount. Used to determine the size of a key or range.\n * @function\n * @param {Object} rangeOrKey\n * @return The size of the key or range passed in.\n */\nfunction getRangeOrKeySize(rangeOrKey) {\n    if (rangeOrKey == null) {\n        return 1;\n    } else if (Array.isArray(rangeOrKey)) {\n        throw new Error(\"Unexpected Array found in keySet: \" + JSON.stringify(rangeOrKey));\n    } else if (typeof rangeOrKey === \"object\") {\n        return getRangeSize(rangeOrKey);\n    } else {\n        return 1;\n    }\n}\n\n/**\n * Returns the size (number of items) in a Range,\n * @function\n * @param {Object} range The Range with both \"from\" and \"to\", or just \"to\"\n * @return The number of items in the range.\n */\nfunction getRangeSize(range) {\n\n    var to = range.to;\n    var length = range.length;\n\n    if (to != null) {\n        if (isNaN(to) || parseInt(to, 10) !== to) {\n            throw new Error(\"Invalid range, 'to' is not an integer: \" + JSON.stringify(range));\n        }\n        var from = range.from || 0;\n        if (isNaN(from) || parseInt(from, 10) !== from) {\n            throw new Error(\"Invalid range, 'from' is not an integer: \" + JSON.stringify(range));\n        }\n        if (from <= to) {\n            return (to - from) + 1;\n        } else {\n            return 0;\n        }\n    } else if (length != null) {\n        if (isNaN(length) || parseInt(length, 10) !== length) {\n            throw new Error(\"Invalid range, 'length' is not an integer: \" + JSON.stringify(range));\n        } else {\n            return length;\n        }\n    } else {\n        throw new Error(\"Invalid range, expected 'to' or 'length': \" + JSON.stringify(range));\n    }\n}\n\n/**\n * Returns a count of the number of paths this pathset\n * represents.\n *\n * For example, [\"foo\", {\"from\":0, \"to\":10}, \"bar\"],\n * would represent 11 paths (0 to 10, inclusive), and\n * [\"foo, [\"baz\", \"boo\"], \"bar\"] would represent 2 paths.\n *\n * @function\n * @param {Object[]} pathSet the path set.\n *\n * @return The number of paths this represents\n */\nfunction getPathCount(pathSet) {\n    if (pathSet.length === 0) {\n        throw new Error(\"All paths must have length larger than zero.\");\n    }\n\n    var numPaths = 1;\n\n    for (var i = 0; i < pathSet.length; i++) {\n        var segment = pathSet[i];\n\n        if (Array.isArray(segment)) {\n\n            var numKeys = 0;\n\n            for (var j = 0; j < segment.length; j++) {\n                var keySet = segment[j];\n\n                numKeys += getRangeOrKeySize(keySet);\n            }\n\n            numPaths *= numKeys;\n\n        } else {\n            numPaths *= getRangeOrKeySize(segment);\n        }\n    }\n\n    return numPaths;\n}\n\n\nmodule.exports = getPathCount;\n\n},{}],149:[function(require,module,exports){\nvar hasIntersection = require(144);\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nmodule.exports = function pathsComplementFromLengthTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        var path = paths[i];\n        if (!hasIntersection(tree[path.length], path, 0)) {\n            out[++outLength] = path;\n        }\n    }\n    return out;\n};\n\n\n},{\"144\":144}],150:[function(require,module,exports){\nvar hasIntersection = require(144);\n\n/**\n * Compares the paths passed in with the tree.  Any of the paths that are in\n * the tree will be stripped from the paths.\n *\n * **Does not mutate** the incoming paths object.\n * **Proper subset** only matching.\n *\n * @param {Array} paths - A list of paths (complex or simple) to strip the\n * intersection\n * @param {Object} tree -\n * @public\n */\nmodule.exports = function pathsComplementFromTree(paths, tree) {\n    var out = [];\n    var outLength = -1;\n\n    for (var i = 0, len = paths.length; i < len; ++i) {\n        // If this does not intersect then add it to the output.\n        if (!hasIntersection(tree, paths[i], 0)) {\n            out[++outLength] = paths[i];\n        }\n    }\n    return out;\n};\n\n\n},{\"144\":144}],151:[function(require,module,exports){\nmodule.exports = function catAndSlice(a, b, slice) {\n    var next = [], i, j, len;\n    for (i = 0, len = a.length; i < len; ++i) {\n        next[i] = a[i];\n    }\n\n    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {\n        next[i] = b[j];\n    }\n\n    return next;\n};\n\n\n},{}],152:[function(require,module,exports){\nfunction cloneArray(arr, index) {\n    var a = [];\n    var len = arr.length;\n    for (var i = index || 0; i < len; i++) {\n        a[i] = arr[i];\n    }\n    return a;\n}\n\nmodule.exports = cloneArray;\n\n\n},{}],153:[function(require,module,exports){\nmodule.exports = {\n    $ref: 'ref',\n    $atom: 'atom',\n    $error: 'error'\n};\n\n\n},{}],154:[function(require,module,exports){\nvar isArray = Array.isArray;\nvar typeOfObject = \"object\";\nvar typeOfString = \"string\";\nvar typeOfNumber = \"number\";\nvar MAX_SAFE_INTEGER = 9007199254740991; // Number.MAX_SAFE_INTEGER in es6\nvar MAX_SAFE_INTEGER_DIGITS = 16; // String(Number.MAX_SAFE_INTEGER).length\nvar MIN_SAFE_INTEGER_DIGITS = 17; // String(Number.MIN_SAFE_INTEGER).length (including sign)\nvar abs = Math.abs;\nvar safeNumberRegEx = /^(0|(\\-?[1-9][0-9]*))$/;\n\n/* jshint forin: false */\nmodule.exports = function toPaths(lengths) {\n    var pathmap;\n    var allPaths = [];\n    var allPathsLength = 0;\n    for (var length in lengths) {\n        if (isSafeNumber(length) && isObject(pathmap = lengths[length])) {\n            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;\n            var pathsIndex = -1;\n            var pathsCount = paths.length;\n            while (++pathsIndex < pathsCount) {\n                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);\n            }\n        }\n    }\n    return allPaths;\n};\n\nfunction isObject(value) {\n    return value !== null && typeof value === typeOfObject;\n}\n\nfunction collapsePathMap(pathmap, depth, length) {\n\n    var key;\n    var code = getHashCode(String(depth));\n    var subs = Object.create(null);\n\n    var codes = [];\n    var codesIndex = -1;\n    var codesCount = 0;\n\n    var pathsets = [];\n    var pathsetsCount = 0;\n\n    var subPath, subCode,\n        subKeys, subKeysIndex, subKeysCount,\n        subSets, subSetsIndex, subSetsCount,\n        pathset, pathsetIndex, pathsetCount,\n        firstSubKey, pathsetClone;\n\n    subKeys = [];\n    subKeysIndex = -1;\n\n    if (depth < length - 1) {\n\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n\n        while (++subKeysIndex < subKeysCount) {\n            key = subKeys[subKeysIndex];\n            subPath = collapsePathMap(pathmap[key], depth + 1, length);\n            subCode = subPath.code;\n            if(subs[subCode]) {\n                subPath = subs[subCode];\n            } else {\n                codes[codesCount++] = subCode;\n                subPath = subs[subCode] = {\n                    keys: [],\n                    sets: subPath.sets\n                };\n            }\n            code = getHashCode(code + key + subCode);\n\n            isSafeNumber(key) &&\n                subPath.keys.push(parseInt(key, 10)) ||\n                subPath.keys.push(key);\n        }\n\n        while(++codesIndex < codesCount) {\n\n            key = codes[codesIndex];\n            subPath = subs[key];\n            subKeys = subPath.keys;\n            subKeysCount = subKeys.length;\n\n            if (subKeysCount > 0) {\n\n                subSets = subPath.sets;\n                subSetsIndex = -1;\n                subSetsCount = subSets.length;\n                firstSubKey = subKeys[0];\n\n                while (++subSetsIndex < subSetsCount) {\n\n                    pathset = subSets[subSetsIndex];\n                    pathsetIndex = -1;\n                    pathsetCount = pathset.length;\n                    pathsetClone = new Array(pathsetCount + 1);\n                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;\n\n                    while (++pathsetIndex < pathsetCount) {\n                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];\n                    }\n\n                    pathsets[pathsetsCount++] = pathsetClone;\n                }\n            }\n        }\n    } else {\n        subKeysCount = getSortedKeys(pathmap, subKeys);\n        if (subKeysCount > 1) {\n            pathsets[pathsetsCount++] = [subKeys];\n        } else {\n            pathsets[pathsetsCount++] = subKeys;\n        }\n        while (++subKeysIndex < subKeysCount) {\n            code = getHashCode(code + subKeys[subKeysIndex]);\n        }\n    }\n\n    return {\n        code: code,\n        sets: pathsets\n    };\n}\n\nfunction collapsePathSetIndexes(pathset) {\n\n    var keysetIndex = -1;\n    var keysetCount = pathset.length;\n\n    while (++keysetIndex < keysetCount) {\n        var keyset = pathset[keysetIndex];\n        if (isArray(keyset)) {\n            pathset[keysetIndex] = collapseIndex(keyset);\n        }\n    }\n\n    return pathset;\n}\n\n/**\n * Collapse range indexers, e.g. when there is a continuous\n * range in an array, turn it into an object instead:\n *\n * [1,2,3,4,5,6] => {\"from\":1, \"to\":6}\n *\n * @private\n */\nfunction collapseIndex(keyset) {\n\n    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?\n    // var hash = {};\n    var keyIndex = -1;\n    var keyCount = keyset.length - 1;\n    var isSparseRange = keyCount > 0;\n\n    while (++keyIndex <= keyCount) {\n\n        var key = keyset[keyIndex];\n\n        if (!isSafeNumber(key) /* || hash[key] === true*/ ) {\n            isSparseRange = false;\n            break;\n        }\n        // hash[key] = true;\n        // Cast number indexes to integers.\n        keyset[keyIndex] = parseInt(key, 10);\n    }\n\n    if (isSparseRange === true) {\n\n        keyset.sort(sortListAscending);\n\n        var from = keyset[0];\n        var to = keyset[keyCount];\n\n        // If we re-introduce deduped integer indexers, change this comparson to \"===\".\n        if (to - from <= keyCount) {\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    return keyset;\n}\n\nfunction sortListAscending(a, b) {\n    return a - b;\n}\n\n/* jshint forin: false */\nfunction getSortedKeys(map, keys, sort) {\n    var len = 0;\n    for (var key in map) {\n        keys[len++] = key;\n    }\n    if (len > 1) {\n        keys.sort(sort);\n    }\n    return len;\n}\n\nfunction getHashCode(key) {\n    var code = 5381;\n    var index = -1;\n    var count = key.length;\n    while (++index < count) {\n        code = (code << 5) + code + key.charCodeAt(index);\n    }\n    return String(code);\n}\n\n/**\n * Return true if argument is a number or can be cast to a number which\n * roundtrips to the same string.\n * @private\n */\nfunction isSafeNumber(val) {\n    var num = val;\n    var type = typeof val;\n    if (type === typeOfString) {\n        var length = val.length;\n        // Number.MIN_SAFE_INTEGER is 17 digits including the sign.\n        // Anything longer cannot be safe.\n        if (length === 0 || length > MIN_SAFE_INTEGER_DIGITS) {\n            return false;\n        }\n        if (!safeNumberRegEx.test(val)) {\n            return false;\n        }\n        // Number.MAX_SAFE_INTEGER is 16 digits.\n        // Anything shorter must be safe.\n        if (length < MAX_SAFE_INTEGER_DIGITS) {\n            return true;\n        }\n        num = +val;\n    } else if (type !== typeOfNumber) {\n        return false;\n    }\n    // Number.isSafeInteger(num) in es6.\n    return num % 1 === 0 && abs(num) <= MAX_SAFE_INTEGER;\n}\n\n// export for testing\nmodule.exports._isSafeNumber = isSafeNumber;\n\n},{}],155:[function(require,module,exports){\nvar iterateKeySet = require(146);\nvar isArray = Array.isArray;\n\n/**\n * @param {Array} paths -\n * @returns {Object} -\n */\nmodule.exports = function toTree(paths) {\n    return paths.reduce(function(acc, path) {\n        innerToTree(acc, path, 0);\n        return acc;\n    }, {});\n};\n\nfunction innerToTree(seed, path, depth) {\n\n    var keySet = path[depth];\n    var iteratorNote = {};\n    var key;\n    var nextDepth = depth + 1;\n\n    key = iterateKeySet(keySet, iteratorNote);\n\n    do {\n\n        var next = seed[key];\n        if (!next) {\n            if (nextDepth === path.length) {\n                seed[key] = null;\n            } else {\n                next = seed[key] = {};\n            }\n        }\n\n        if (nextDepth < path.length) {\n            innerToTree(next, path, nextDepth);\n        }\n\n        if (!iteratorNote.done) {\n            key = iterateKeySet(keySet, iteratorNote);\n        }\n    } while (!iteratorNote.done);\n}\n\n\n},{\"146\":146}],156:[function(require,module,exports){\n'use strict';\n\nmodule.exports = require(161)\n\n},{\"161\":161}],157:[function(require,module,exports){\n'use strict';\n\nvar asap = require(122);\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('Promise constructor\\'s argument is not a function');\n  }\n  this._75 = 0;\n  this._83 = 0;\n  this._18 = null;\n  this._38 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._47 = null;\nPromise._71 = null;\nPromise._44 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n}\nfunction handle(self, deferred) {\n  while (self._83 === 3) {\n    self = self._18;\n  }\n  if (Promise._47) {\n    Promise._47(self);\n  }\n  if (self._83 === 0) {\n    if (self._75 === 0) {\n      self._75 = 1;\n      self._38 = deferred;\n      return;\n    }\n    if (self._75 === 1) {\n      self._75 = 2;\n      self._38 = [self._38, deferred];\n      return;\n    }\n    self._38.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._83 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._83 === 1) {\n        resolve(deferred.promise, self._18);\n      } else {\n        reject(deferred.promise, self._18);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._18);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._83 = 3;\n      self._18 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._83 = 1;\n  self._18 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._83 = 2;\n  self._18 = newValue;\n  if (Promise._71) {\n    Promise._71(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._75 === 1) {\n    handle(self, self._38);\n    self._38 = null;\n  }\n  if (self._75 === 2) {\n    for (var i = 0; i < self._38.length; i++) {\n      handle(self, self._38[i]);\n    }\n    self._38 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  });\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n},{\"122\":122}],158:[function(require,module,exports){\n'use strict';\n\nvar Promise = require(157);\n\nmodule.exports = Promise;\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this;\n  self.then(null, function (err) {\n    setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\n\n},{\"157\":157}],159:[function(require,module,exports){\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require(157);\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._44);\n  p._83 = 1;\n  p._18 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._83 === 3) {\n            val = val._18;\n          }\n          if (val._83 === 1) return res(i, val._18);\n          if (val._83 === 2) reject(val._18);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n},{\"157\":157}],160:[function(require,module,exports){\n'use strict';\n\nvar Promise = require(157);\n\nmodule.exports = Promise;\nPromise.prototype['finally'] = function (f) {\n  return this.then(function (value) {\n    return Promise.resolve(f()).then(function () {\n      return value;\n    });\n  }, function (err) {\n    return Promise.resolve(f()).then(function () {\n      throw err;\n    });\n  });\n};\n\n},{\"157\":157}],161:[function(require,module,exports){\n'use strict';\n\nmodule.exports = require(157);\nrequire(158);\nrequire(160);\nrequire(159);\nrequire(162);\nrequire(163);\n\n},{\"157\":157,\"158\":158,\"159\":159,\"160\":160,\"162\":162,\"163\":163}],162:[function(require,module,exports){\n'use strict';\n\n// This file contains then/promise specific extensions that are only useful\n// for node.js interop\n\nvar Promise = require(157);\nvar asap = require(121);\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  if (\n    typeof argumentCount === 'number' && argumentCount !== Infinity\n  ) {\n    return denodeifyWithCount(fn, argumentCount);\n  } else {\n    return denodeifyWithoutCount(fn);\n  }\n};\n\nvar callbackFn = (\n  'function (err, res) {' +\n  'if (err) { rj(err); } else { rs(res); }' +\n  '}'\n);\nfunction denodeifyWithCount(fn, argumentCount) {\n  var args = [];\n  for (var i = 0; i < argumentCount; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'return new Promise(function (rs, rj) {',\n    'var res = fn.call(',\n    ['self'].concat(args).concat([callbackFn]).join(','),\n    ');',\n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n  return Function(['Promise', 'fn'], body)(Promise, fn);\n}\nfunction denodeifyWithoutCount(fn) {\n  var fnLength = Math.max(fn.length - 1, 3);\n  var args = [];\n  for (var i = 0; i < fnLength; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'var args;',\n    'var argLength = arguments.length;',\n    'if (arguments.length > ' + fnLength + ') {',\n    'args = new Array(arguments.length + 1);',\n    'for (var i = 0; i < arguments.length; i++) {',\n    'args[i] = arguments[i];',\n    '}',\n    '}',\n    'return new Promise(function (rs, rj) {',\n    'var cb = ' + callbackFn + ';',\n    'var res;',\n    'switch (argLength) {',\n    args.concat(['extra']).map(function (_, index) {\n      return (\n        'case ' + (index) + ':' +\n        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +\n        'break;'\n      );\n    }).join(''),\n    'default:',\n    'args[argLength] = cb;',\n    'res = fn.apply(self, args);',\n    '}',\n    \n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n\n  return Function(\n    ['Promise', 'fn'],\n    body\n  )(Promise, fn);\n}\n\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback =\n      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        })\n      }\n    }\n  }\n};\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n};\n\n},{\"121\":121,\"157\":157}],163:[function(require,module,exports){\n'use strict';\n\nvar Promise = require(157);\n\nmodule.exports = Promise;\nPromise.enableSynchronous = function () {\n  Promise.prototype.isPending = function() {\n    return this.getState() == 0;\n  };\n\n  Promise.prototype.isFulfilled = function() {\n    return this.getState() == 1;\n  };\n\n  Promise.prototype.isRejected = function() {\n    return this.getState() == 2;\n  };\n\n  Promise.prototype.getValue = function () {\n    if (this._83 === 3) {\n      return this._18.getValue();\n    }\n\n    if (!this.isFulfilled()) {\n      throw new Error('Cannot get a value of an unfulfilled promise.');\n    }\n\n    return this._18;\n  };\n\n  Promise.prototype.getReason = function () {\n    if (this._83 === 3) {\n      return this._18.getReason();\n    }\n\n    if (!this.isRejected()) {\n      throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n    }\n\n    return this._18;\n  };\n\n  Promise.prototype.getState = function () {\n    if (this._83 === 3) {\n      return this._18.getState();\n    }\n    if (this._83 === -1 || this._83 === -2) {\n      return 0;\n    }\n\n    return this._83;\n  };\n};\n\nPromise.disableSynchronous = function() {\n  Promise.prototype.isPending = undefined;\n  Promise.prototype.isFulfilled = undefined;\n  Promise.prototype.isRejected = undefined;\n  Promise.prototype.getValue = undefined;\n  Promise.prototype.getReason = undefined;\n  Promise.prototype.getState = undefined;\n};\n\n},{\"157\":157}],164:[function(require,module,exports){\n(function (global){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require(165);\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"165\":165}],165:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n},{}]},{},[1])(1)\n});\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/falcor/dist/falcor.browser.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/webpack/buildin/global.js","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js??ref--4-2!../../../node_modules/postcss-loader/lib/index.js??postcss!../../../node_modules/preact-cli/lib/lib/webpack/proxy-loader.js??ref--2-0!./style.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js??ref--4-2!../../../node_modules/postcss-loader/lib/index.js??postcss!../../../node_modules/preact-cli/lib/lib/webpack/proxy-loader.js??ref--2-0!./style.scss\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js??ref--4-2!../../../node_modules/postcss-loader/lib/index.js??postcss!../../../node_modules/preact-cli/lib/lib/webpack/proxy-loader.js??ref--2-0!./style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/chatbox/style.scss\n// module id = kTIn\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/css-loader/lib/css-base.js","'use strict';\n\nif (!global.Promise) global.Promise = require('promise-polyfill');\nif (!global.fetch) global.fetch = require('isomorphic-unfetch');\n\n\n// WEBPACK FOOTER //\n// ../node_modules/preact-cli/lib/lib/webpack/polyfills.js","'use strict';\n\nvar _preact = require('preact');\n\nif (process.env.NODE_ENV === 'development') {\n\trequire('preact/devtools');\n} else if (process.env.ADD_SW && 'serviceWorker' in navigator && location.protocol === 'https:') {\n\tnavigator.serviceWorker.register(__webpack_public_path__ + 'sw.js');\n}\n\nconst interopDefault = m => m && m.default ? m.default : m;\n\nlet app = interopDefault(require('preact-cli-entrypoint'));\n\nif (typeof app === 'function') {\n\tlet root = document.body.firstElementChild;\n\n\tlet init = () => {\n\t\tlet app = interopDefault(require('preact-cli-entrypoint'));\n\t\troot = (0, _preact.render)((0, _preact.h)(app), document.body, root);\n\t};\n\n\tif (module.hot) module.hot.accept('preact-cli-entrypoint', init);\n\n\tinit();\n}\n\n\n// WEBPACK FOOTER //\n// ../node_modules/preact-cli/lib/lib/entry.js"],"sourceRoot":""}